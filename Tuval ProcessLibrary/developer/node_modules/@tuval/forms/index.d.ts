// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../@tuval/core
//   ../../@tuval/cg
//   ../../rxjs
//   ../../@tuval/graphics
//   ../../rxjs-compat/Observable
//   ../../query-string

import { HttpClientResponse, HttpClientRequestConfig } from '@tuval/core';
import { ReadOnlyCollectionBase, IEnumerator } from "@tuval/core";
import { IDisposable, EventHandler } from "@tuval/core";
import { IDisposable } from "@tuval/core";
import { CGColor, CGRectangle } from '@tuval/cg';
import { int, EventArgs, List, Event, Type, Hashtable } from '@tuval/core';
import { Observable, ReplaySubject } from 'rxjs';
import { DashStyle } from "@tuval/graphics";
import { List, int, Event } from '@tuval/core';
import { List } from '@tuval/core';
import { Event, int, Delegate } from '@tuval/core';
import { ReplaySubject } from 'rxjs';
import { Event } from '@tuval/core';
import { Observable } from "rxjs-compat/Observable";
import { List, int } from '@tuval/core';
import { List, int, Router } from '@tuval/core';
import { Delegate, Event, int } from '@tuval/core';
import { TextConsole, Delegate, Event } from '@tuval/core';
import { Delegate, Event } from '@tuval/core';
import { Event, StringBuilder } from '@tuval/core';
import { Event, ByteArray } from '@tuval/core';
import { Umay, int, Delegate, Event } from '@tuval/core';
import { SketchGraphics } from '@tuval/graphics';
import { GuiConsole as GC } from '@tuval/graphics';
import { int } from '@tuval/core';
import { Delegate } from '@tuval/core';
import { ICollection, IEnumerable, IEnumerator, IList } from '@tuval/core';
import { int } from "@tuval/core";
import { int, Event, StringBuilder } from '@tuval/core';
import { Event, int, List } from '@tuval/core';
import { StringBuilder } from '@tuval/core';
import { StringBuilder } from "@tuval/core";
import { float } from '@tuval/core';
import { int, Type } from "@tuval/core";
import { float } from "@tuval/core";
import { EventArgs } from "@tuval/core";
import { Event, int } from '@tuval/core';
import { int, List } from "@tuval/core";
import { Event, Delegate } from '@tuval/core';
import { Observable } from 'rxjs-compat/Observable';
import { EventArgs } from '@tuval/core';
import { ReplaySubject } from "rxjs";
import { int, Event } from '@tuval/core';
import { int, List } from '@tuval/core';
import { CGColor } from '@tuval/cg';
import { CGColor, CGPoint, CGRectangle, CGSize } from "@tuval/cg";
import { float, StringBuilder } from '@tuval/core';
import { Brush, GraphicsPath, Pen } from "@tuval/graphics";
import { ByteArray } from '@tuval/core';
import { stringify } from 'query-string';
import { Event } from "@tuval/core";

export const React: any;
import './windows/Forms/Components/fonts/loadFont';
import './exports';

export declare class BlockUI extends React.Component {
    static defaultProps: {
        id: any;
        blocked: boolean;
        fullScreen: boolean;
        baseZIndex: number;
        autoZIndex: boolean;
        style: any;
        className: any;
        template: any;
        onBlocked: any;
        onUnblocked: any;
    };
    mask: any;
    container: any;
    constructor(props: any);
    block(): void;
    unblock(): void;
    onPortalMounted(): void;
    renderMask(): any;
    componentDidMount(): void;
    componentDidUpdate(prevProps: any, prevState: any): void;
    componentWillUnmount(): void;
    render(): any;
}

export class ProgressBar extends React.Component {
    static defaultProps: {
        id: any;
        value: any;
        showValue: boolean;
        unit: string;
        style: any;
        className: any;
        mode: string;
        displayValueTemplate: any;
        color: any;
    };
    renderLabel(): any;
    renderDeterminate(): any;
    renderIndeterminate(): any;
    render(): any;
}

export const Resources: {
    Icons: {
        Loading: string;
    };
};

export class PointTarget extends React.Component {
    static defaultProps: {
        tolerance: number;
    };
    handleClick: () => void;
    handleTouchStart: (event: any) => void;
    handleTouchMove: (event: any) => void;
    handleTouchCancel: () => void;
    handleTouchEnd: () => void;
    usingTouch: any;
    touchStarted: any;
    touchMoved: any;
    startX: number;
    startY: any;
    componentWillMount(): void;
    render(): any;
}

function createElement(el: any, props: any, ...children: any[]): {
    type: any;
    props: any;
    key: any;
    ref: any;
    _children: any;
    _parent: any;
    _depth: number;
    _dom: any;
    _nextDom: any;
    _component: any;
    _hydrating: any;
    constructor: any;
    _original: any;
};
export const Teact: {
    createElement: typeof createElement;
};
export {};

export const ControlTypes: {
    UIKit: {
        ZStack: symbol;
    };
    Panel: symbol;
    ContainerControl: symbol;
    TabControl: symbol;
    TabPage: symbol;
    ComboBoxBase: symbol;
    MultiComboBox: symbol;
    ListBoxBase: symbol;
    TextBox: symbol;
    ContextMenu: symbol;
    RibbonMenu: symbol;
    FileUpload: symbol;
    TextArea: symbol;
    ScrollPanel: symbol;
    GridView: {
        ImageColumn: symbol;
    };
    TreeView: {
        TreeNode: symbol;
    };
    Dialog: symbol;
    TreeViewEx: symbol;
    Splitter: symbol;
    MenuItem: symbol;
    ISystemMenu: symbol;
    IAppStoreService: symbol;
    IDesktopService: symbol;
    ComboBox: {
        ComboBoxItem: symbol;
    };
    IControlContainer: symbol;
    Form: symbol;
    RadioButtonGroup: {
        RadioButtonGroupItem: symbol;
    };
};

export enum PaddingApplies {
    None = 0,
    Top = 1,
    Left = 2,
    Right = 4,
    Bottom = 8,
    All = 15
}
export class Padding {
    static readonly Empty: Padding;
    Applies: PaddingApplies;
    constructor(all: number);
    constructor(left: number, top: number, right: number, bottom: number, applies?: PaddingApplies);
    get All(): number;
    set All(value: number);
    get Bottom(): number;
    set Bottom(value: number);
    get Left(): number;
    set Left(value: number);
    get Right(): number;
    set Right(value: number);
    get Top(): number;
    set Top(value: number);
    get Horizontal(): number;
    get Vertical(): number;
    get Size(): {
        width: number;
        height: number;
    };
    static Add(p1: Padding, p2: Padding): Padding;
    static Subtract(p1: Padding, p2: Padding): Padding;
    static CreateEmpty(): Padding;
}

export enum BorderApplies {
    None = 0,
    Top = 1,
    Left = 2,
    Right = 4,
    Bottom = 8,
    All = 15
}
export class Border {
    static Empty: Border;
    LeftBorderColor: string;
    TopBorderColor: string;
    RightBorderColor: string;
    BottomBorderColor: string;
    Applies: BorderApplies;
    constructor();
    AddLeftBorder(color: string): void;
    AddTopBorder(color: string): void;
    AddRightBorder(color: string): void;
    AddBottomBorder(color: string): void;
    Inpose(styleObject: any): void;
}

export class DomHandler {
        static calculatedScrollbarWidth: any;
        static browser: any;
        static style: any;
        static zIndex: any;
        static generateZIndex(): number;
        static revertZIndex(): void;
        static getCurrentZIndex(): any;
        static addCssToDocument(css: string, id?: string): string;
        static removeCssToDocument(id: string): void;
        static innerWidth(el: any): any;
        static width(el: any): any;
        static getWindowScrollTop(): number;
        static getWindowScrollLeft(): number;
        static getOuterWidth(el: any, margin?: any): any;
        static getOuterHeight(el: any, margin?: any): any;
        static getClientHeight(el: any, margin?: any): any;
        static getClientWidth(el: any, margin?: any): any;
        static getViewport(): {
                width: number;
                height: number;
        };
        static getOffset(el: any): {
                top: any;
                left: any;
        };
        static index(element: any): number;
        static addMultipleClasses(element: any, className: any): void;
        static removeMultipleClasses(element: any, className: any): void;
        static addClass(element: any, className: any): void;
        static removeClass(element: any, className: any): void;
        static hasClass(element: any, className: any): any;
        static find(element: any, selector: any): unknown[];
        static findSingle(element: any, selector: any): any;
        static getHeight(el: any): any;
        static getWidth(el: any): any;
        static alignOverlay(overlay: any, target: any, appendTo: any, calculateMinWidth?: boolean): void;
        static absolutePosition(element: any, target: any): void;
        static relativePosition(element: any, target: any): void;
        static flipfitCollision(element: any, target: any, my: string, at: string, callback: any): void;
        static findCollisionPosition(position: any): {
                axis: string;
                my: string;
                at: string;
        };
        static getParents(element: any, parents?: any[]): any;
        static getScrollableParents(element: any): any[];
        static getHiddenElementOuterHeight(element: any): any;
        static getHiddenElementOuterWidth(element: any): any;
        static getHiddenElementDimensions(element: any): any;
        static fadeIn(element: any, duration: any): void;
        static fadeOut(element: any, duration: any): void;
        static getUserAgent(): string;
        static isIOS(): boolean;
        static isAndroid(): boolean;
        static isTouchDevice(): boolean;
        static isFunction(obj: any): boolean;
        static appendChild(element: any, target: any): void;
        static removeChild(element: any, target: any): void;
        static isElement(obj: any): boolean;
        static scrollInView(container: any, item: any): void;
        static clearSelection(): void;
        static calculateScrollbarWidth(el?: any): any;
        static getBrowser(): any;
        static resolveUserAgent(): {
                browser: any;
                version: any;
        };
        static isVisible(element: any): boolean;
        static isExist(element: any): any;
        static hasDOM(): boolean;
        static getFocusableElements(element: any, selector?: string): any[];
        static getFirstFocusableElement(element: any, selector?: any): any;
        static getLastFocusableElement(element: any, selector: any): any;
        static getCursorOffset(el: any, prevText: any, nextText: any, currentText: any): {
                left: number;
                top: number;
        } | {
                top: string;
                left: string;
        };
        static invokeElementMethod(element: any, methodName: any, args: any): void;
        static isClickable(element: any): any;
        static applyStyle(element: any, style: any): void;
        static exportCSV(csv: any, filename: any): void;
        /**
            * Anytime an inline style is created check for CSP Nonce.
            * Create React App/Next look for environment variable 'process.env.REACT_APP_CSS_NONCE'.
            * Vite look for environment variable 'import.meta.env.VITE_CSS_NONCE'
            * Finally look for global variable PrimeReact.inlineCssNonce to set a CSP NONCE.
            *
            * @see https://github.com/primefaces/primereact/issues/2423
            * @return HtmlStyleElement
            */
        static createInlineStyle(): HTMLStyleElement;
        /**
            * Remove a style element from the head and attempt to prevent DOM Exception on fast refresh.
            *
            * @see https://github.com/primefaces/primereact/issues/2469
            * @param {HtmlStyleElement} styleElement the element to remove from head
            */
        static removeInlineStyle(styleElement: any): any;
}

export {};

export function UniqueComponentId(prefix?: string): string;

export enum MarginApplies {
    None = 0,
    Top = 1,
    Left = 2,
    Right = 4,
    Bottom = 8,
    All = 15
}
export class Margin {
    static readonly Empty: Margin;
    Applies: MarginApplies;
    constructor(all: number);
    constructor(left: number, top: number, right: number, bottom: number, applies?: MarginApplies);
    get All(): number;
    set All(value: number);
    get Bottom(): number;
    set Bottom(value: number);
    get Left(): number;
    set Left(value: number);
    get Right(): number;
    set Right(value: number);
    get Top(): number;
    set Top(value: number);
    get Horizontal(): number;
    get Vertical(): number;
    get Size(): {
        width: number;
        height: number;
    };
    static Add(p1: Margin, p2: Margin): Margin;
    static Subtract(p1: Margin, p2: Margin): Margin;
    static CreateEmpty(): Margin;
}

/**
    * @param {import('./index').StateUpdater<any>} [initialState]
    */
export function useState(initialState?: any): any;
export function bindState(initialState?: any): any;
/**
    * @param {import('./index').Reducer<any, any>} reducer
    * @param {import('./index').StateUpdater<any>} initialState
    * @param {(initialState: any) => void} [init]
    * @returns {[ any, (state: any) => void ]}
    */
export function useReducer(reducer: any, initialState: any, init?: any): any;
/**
    * @param {import('./internal').Effect} callback
    * @param {any[]} args
    */
export function useEffect(callback: any, args?: any): void;
/**
    * @param {import('./internal').Effect} callback
    * @param {any[]} args
    */
export function useLayoutEffect(callback: any, args: any): void;
export function useRef(initialValue?: any): any;
/**
    * @param {object} ref
    * @param {() => object} createHandle
    * @param {any[]} args
    */
export function useImperativeHandle(ref: any, createHandle: any, args?: any): void;
/**
    * @param {() => any} factory
    * @param {any[]} args
    */
export function useMemo(factory: any, args: any): any;
/**
    * @param {() => void} callback
    * @param {any[]} args
    */
export function useCallback(callback: any, args: any): any;
/**
    * @param {import('./internal').PreactContext} context
    */
export function useContext(context: any): any;
/**
    * Display a custom label for a custom hook for the devtools panel
    * @type {<T>(value: T, cb?: (value: T) => string | number) => void}
    */
export function useDebugValue(value: any, formatter: any): void;
/**
    * @param {(error: any) => void} cb
    */
export function useErrorBoundary(cb: any): any[];

export interface IStackFrame {
    isConstructor?: boolean;
    isEval?: boolean;
    isNative?: boolean;
    isToplevel?: boolean;
    columnNumber?: number;
    lineNumber?: number | string;
    fileName?: string;
    functionName?: string;
    source?: string;
    args?: any[];
    evalOrigin?: IStackFrame;
    toString(): string;
}
export class StackFrame implements IStackFrame {
    isConstructor?: boolean;
    isEval?: boolean;
    isNative?: boolean;
    isToplevel?: boolean;
    columnNumber?: number;
    lineNumber?: number | string;
    fileName?: string;
    functionName?: string;
    source?: string;
    args?: any[];
    evalOrigin?: IStackFrame;
    constructor(obj: IStackFrame);
    toString(): string;
}
export class ErrorStackParser {
    /**
      * Given an Error object, extract the most information from it.
      *
      * @param {Error} error object
      * @return {Array} of StackFrames
      */
    static parse(error: any): any;
    static extractLocation(urlLike: any): any[];
    static parseV8OrIE(error: any): any;
    static parseFFOrSafari(error: any): any;
    static parseOpera(e: any): any;
    static parseOpera9(e: any): any[];
    static parseOpera10(e: any): any[];
    static parseOpera11(error: any): any;
}
export interface IStateService {
    GetSessionId(): string;
    SetSessionId(value: string): void;
}
export class RealmHttpClient {
    static Post<D = any, T = any, R = HttpClientResponse<T>>(url: string, data?: D, config?: HttpClientRequestConfig<D>): Promise<R>;
}

/**
 * Finds first matching elements on the page that may be in a shadow root using a complex selector of n-depth
 *
 * Don't have to specify all shadow roots to button, tree is travered to find the correct element
 *
 * Example querySelectorAllDeep('downloads-item:nth-child(4) #remove');
 *
 * Example should work on chrome://downloads outputting the remove button inside of a download card component
 *
 * Example find first active download link element querySelectorDeep('#downloads-list .is-active a[href^="https://"]');
 *
 * Another example querySelectorAllDeep('#downloads-list div#title-area + a');
e.g.
 */
export function querySelectorAllDeep(selector: any, root?: Document, allElements?: any): any;
export function querySelectorDeep(selector: any, root?: Document, allElements?: any): any;
/**
    * Finds all elements on the page, inclusive of those within shadow roots.
    * @param {string=} selector Simple selector to filter the elements by. e.g. 'a', 'div.main'
    * @return {!Array<string>} List of anchor hrefs.
    * @author ebidel@ (Eric Bidelman)
    * License Apache-2.0
    */
export function collectAllElementsDeep(selector: any, root: any, cachedElements?: any): any[];

export const jss: import("jss").Jss;

/**
    * NOTE: If you refactor this to split up the modules into separate files,
    * you'll need to update the rollup config for router-dom-v5-compat.
    */
export { MemoryRouter, Navigate, Outlet, Route, Router, Routes, createRoutesFromChildren, generatePath, matchRoutes, matchPath, createPath, parsePath, renderMatches, resolvePath, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useNavigationType, useOutlet, useParams, useResolvedPath, useRoutes, useOutletContext, };
export interface BrowserRouterProps {
        basename?: string;
        children?: any;
        window?: Window;
}
/**
    * A `<Router>` for use in web browsers. Provides the cleanest URLs.
    */
export function BrowserRouter({ basename, children, window, }: BrowserRouterProps): any;
export interface HashRouterProps {
        basename?: string;
        children?: any;
        window?: Window;
}
/**
    * A `<Router>` for use in web browsers. Stores the location in the hash
    * portion of the URL so it is not sent to the server.
    */
export function HashRouter({ basename, children, window }: HashRouterProps): any;
export interface HistoryRouterProps {
        basename?: string;
        children?: any;
        history: History;
}
/**
    * A `<Router>` that accepts a pre-instantiated history object. It's important
    * to note that using your own history object is highly discouraged and may add
    * two versions of the history library to your bundles unless you use the same
    * version of the history library that React Router uses internally.
    */
function HistoryRouter({ basename, children, history }: HistoryRouterProps): any;
namespace HistoryRouter {
        var displayName: string;
}
export { HistoryRouter as unstable_HistoryRouter };
export interface LinkProps {
        reloadDocument?: boolean;
        replace?: boolean;
        state?: any;
        to: To;
}
/**
    * The public API for rendering a history-aware <a>.
    */
export const Link: {
        (props: any, ref: any): any;
        $$typeof: number | symbol;
        render: any;
        _forwarded: boolean;
        displayName: string;
};
export interface NavLinkProps extends Omit<LinkProps, "className" | "style" | "children"> {
        children?: any | ((props: {
                isActive: boolean;
        }) => any);
        caseSensitive?: boolean;
        className?: string | ((props: {
                isActive: boolean;
        }) => string | undefined);
        end?: boolean;
        style?: any | ((props: {
                isActive: boolean;
        }) => any);
}
/**
    * A <Link> wrapper that knows if it's "active" or not.
    */
export const NavLink: {
        (props: any, ref: any): any;
        $$typeof: number | symbol;
        render: any;
        _forwarded: boolean;
        displayName: string;
};
/**
    * Handles the click behavior for router `<Link>` components. This is useful if
    * you need to create custom `<Link>` components with the same click behavior we
    * use in our exported `<Link>`.
    */
export function useLinkClickHandler<E extends Element = HTMLAnchorElement>(to: To, { target, replace: replaceProp, state, }?: {
        target?: any;
        replace?: boolean;
        state?: any;
}): (event: any) => void;
/**
    * A convenient wrapper for reading and writing search parameters via the
    * URLSearchParams interface.
    */
export function useSearchParams(defaultInit?: URLSearchParamsInit): readonly [any, any];
export type ParamKeyValuePair = [string, string];
export type URLSearchParamsInit = string | ParamKeyValuePair[] | Record<string, string | string[]> | URLSearchParams;
/**
    * Creates a URLSearchParams object using the given initializer.
    *
    * This is identical to `new URLSearchParams(init)` except it also
    * supports arrays as values in the object form of the initializer
    * instead of just strings. This is convenient when you need multiple
    * values for a given key, but don't want to use an array initializer.
    *
    * For example, instead of:
    *
    *   let searchParams = new URLSearchParams([
    *     ['sort', 'name'],
    *     ['sort', 'price']
    *   ]);
    *
    * you can do:
    *
    *   let searchParams = createSearchParams({
    *     sort: ['name', 'price']
    *   });
    */
export function createSearchParams(init?: URLSearchParamsInit): URLSearchParams;

const version = "17.0.2";
/**
    * Legacy version of createElement.
    * @param {import('./internal').VNode["type"]} type The node name or Component constructor
    */
function createFactory(type: any): (props: any, children?: any) => {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
};
/**
    * Check if the passed element is a valid (p)react node.
    * @param {*} element The element to check
    * @returns {boolean}
    */
function isValidElement(element: any): boolean;
/**
    * Wrap `cloneElement` to abort if the passed element is not a valid element and apply
    * all vnode normalizations.
    * @param {import('./internal').VNode} element The vnode to clone
    * @param {object} props Props to add when cloning
    * @param {Array<import('./internal').ComponentChildren>} rest Optional component children
    */
function cloneElement(element: any, args?: any): any;
/**
    * Remove a component tree from the DOM, including state and event handlers.
    * @param {import('./internal').PreactElement} container
    * @returns {boolean}
    */
function unmountComponentAtNode(container: any): boolean;
/**
    * Get the matching DOM node for a component
    * @param {import('./internal').Component} component
    * @returns {import('./internal').PreactElement | null}
    */
function findDOMNode(component: any): any;
/**
    * Deprecated way to control batched rendering inside the reconciler, but we
    * already schedule in batches inside our rendering code
    * @template Arg
    * @param {(arg: Arg) => void} callback function that triggers the updated
    * @param {Arg} [arg] Optional argument that can be passed to the callback
    */
const unstable_batchedUpdates: (callback: any, arg: any) => any;
/**
    * In React, `flushSync` flushes the entire tree and forces a rerender. It's
    * implmented here as a no-op.
    * @template Arg
    * @template Result
    * @param {(arg: Arg) => Result} callback function that runs before the flush
    * @param {Arg} [arg] Optional arugment that can be passed to the callback
    * @returns
    */
const flushSync: (callback: any, arg: any) => any;
/**
    * Strict Mode is not implemented in Preact, so we provide a stand-in for it
    * that just renders its children without imposing any restrictions.
    */
const StrictMode: typeof Fragment;
export { version, Children, render, hydrate, unmountComponentAtNode, createPortal, Portal, createElement, createContext, createFactory, cloneElement, createRef, Fragment, isValidElement, findDOMNode, Component, PureComponent, memo, forwardRef, flushSync, unstable_batchedUpdates, StrictMode, Suspense, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED };
const _default: {
        useState: typeof useState;
        useReducer: typeof useReducer;
        useEffect: typeof useEffect;
        useLayoutEffect: typeof useLayoutEffect;
        useRef: typeof useRef;
        useImperativeHandle: typeof useImperativeHandle;
        useMemo: typeof useMemo;
        useCallback: typeof useCallback;
        useContext: typeof useContext;
        useDebugValue: typeof useDebugValue;
        version: string;
        Children: {
                map: (children: any, fn: any) => any;
                forEach: (children: any, fn: any) => any;
                count(children: any): any;
                only(children: any): any;
                toArray: typeof import("../index").toChildArray;
        };
        render: typeof render;
        hydrate: typeof hydrate;
        unmountComponentAtNode: typeof unmountComponentAtNode;
        createPortal: typeof createPortal;
        createElement: typeof createElement;
        createContext: typeof createContext;
        createFactory: typeof createFactory;
        cloneElement: typeof cloneElement;
        createRef: typeof createRef;
        Fragment: typeof Fragment;
        isValidElement: typeof isValidElement;
        findDOMNode: typeof findDOMNode;
        Component: typeof Component;
        PureComponent: typeof PureComponent;
        memo: typeof memo;
        forwardRef: typeof forwardRef;
        flushSync: (callback: any, arg: any) => any;
        unstable_batchedUpdates: (callback: any, arg: any) => any;
        StrictMode: typeof Fragment;
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
                ReactCurrentDispatcher: {
                        current: {
                                readContext(context: any): any;
                        };
                };
        };
};
export default _default;

export class __ComponentCollection extends ReadOnlyCollectionBase<IComponent> {
    protected _getCount(): number;
    protected _getEnumerator(): IEnumerator<IComponent>;
    get(name: string): IComponent;
    constructor(components: IComponent[]);
}

export interface IComponent extends IDisposable {
    Site: ISite;
    disposed: EventHandler;
}

export interface IContainer extends IDisposable {
    Components: __ComponentCollection;
    add(component: IComponent): void;
    add(component: IComponent, name: string): void;
    remove(component: IComponent): void;
}

export interface ISite {
    Component: IComponent;
    Container: IContainer;
    DesignMode: boolean;
    Name: string;
}

export interface ITypeDescriptorContext {
    Container: IContainer;
    Instance: any;
    PropertyDescriptor: PropertyDescriptor;
    onComponentChanged(): void;
    onComponentChanging(): boolean;
}

type Constructor<T = any> = new (props: any) => T;
export const RendererTable: Hashtable<Type, Constructor>;
export let lastEnteredPropertyName: string;
export function ConvertToInt$(source: Observable<int>): Observable<int>;
export function ConvertToFunc$(source: Observable<any>, func: (val: any) => void): Observable<any>;
export function throttle$(source: Observable<any>, interv: int): Observable<any>;
export function Subscriber$(source: Observable<any>, func: Function): void;
export interface IControlContainer {
    GetControls(): List<Control<any>>;
}
export enum Modes {
    Component = 0,
    Control = 1
}
export abstract class TComponent extends React.Component {
    Render(): any;
    GetType(): Type;
    PropertyChanged: Event<any>;
    UpdateRequied: Event<any>;
    get Components(): ComponentCollection;
    get Owner(): TComponent;
    set Owner(value: TComponent);
    __Mode__: Modes;
    protected __m_PropertyBag__: any;
    protected __m_PipeBag__: any;
    protected __m_IsComponent__: boolean;
    protected __m_Component__: any;
    get m_PropertyBag(): any;
    set m_PropertyBag(value: any);
    get m_PipeBag(): any;
    set m_PipeBag(value: any);
    get m_IsComponent(): any;
    set m_IsComponent(value: any);
    get m_Component(): any;
    set m_Component(value: any);
    __Bounds__: CGRectangle;
    __Dash__: DashStyle;
    BeginUpdate(): void;
    EndUpdate(): void;
    UnLoad(): void;
    GetPipe<P>(propertyName: string): ReplaySubject<P>;
    protected SetPipe<P>(propertyName: any, value: Observable<P>): void;
    protected SetPropertyInSlient(name: string, value: any): void;
    protected GetPropertyInSlient(name: string): any;
    protected SetProperty(name: string, value: any): void;
    protected GetProperty(name: string): any;
    constructor();
    constructor(props: any);
    protected SetupControlDefaults(): void;
    protected SetupComponentDefaults(): void;
    protected InitComponents(): void;
    ForceUpdate(): void;
    protected OnComponentSet(form: any): void;
    OnFormResized(width: int, height: int): void;
    protected abstract CreateElements<T>(param?: T): any;
    protected CreateElementsInternal(): any;
    OnAdoption(parent: Control<any>): void;
    CreateMainElement(param?: any): any;
    render(): any;
    protected componentWillMount(): void;
    protected componentDidMount(): void;
    componentWillReceiveProps(): void;
    shouldComponentUpdate(nextProps: any, nextState: any): boolean;
    componentWillUpdate(): void;
    componentDidUpdate(prevProps: any, prevState: any): void;
    protected componentWillUnmount(): void;
    protected OnComponentWillMount(): void;
    protected OnComponentDidMount(): void;
    protected OnComponentWillReceiveProps(): void;
    protected OnShouldComponentUpdate(): boolean;
    protected OnComponentWillUpdate(): boolean;
    protected OnComponentDidUpdate(): boolean;
    protected OnComponentWillUnmount(): boolean;
    protected InitializeComponent(): void;
    protected GetRenderer(): any;
}
export abstract class Control<T extends Control = any, TController = any> extends TComponent implements IControl, IRenderable {
    jssStyle: any;
    KeyFrameCollection: KeyFrameCollection[];
    Tooltip: string;
    TabIndex: int;
    protected SendMessageToController(message: string, ...args: any[]): void;
    Appearance: AppearanceObject;
    HoverAppearance: AppearanceObject;
    FocusAppearance: AppearanceObject;
    ActiveAppearance: AppearanceObject;
    DisabledAppearance: AppearanceObject;
    BeforeAppearance: AppearanceObject;
    Loaded: Event<any>;
    UnLoaded: Event<any>;
    OnLoaded(): void;
    OnUnLoaded(): void;
    MouseHover: Event<any>;
    MouseMove: Event<any>;
    Clicked: Event<any>;
    protected CreateFrameElement: boolean;
    Handle: string;
    Id: string;
    Tag: any;
    protected myParent: Control<any>;
    get Parent(): Control<any>;
    set Parent(value: Control<any>);
    get Parent$(): ReplaySubject<any>;
    set Parent$(value: ReplaySubject<any>);
    get BackgroundColor(): string;
    set BackgroundColor(value: string);
    get ForeColor(): string;
    set ForeColor(value: string);
    Visible: boolean;
    get Visible$(): ReplaySubject<boolean>;
    set Visible$(value: ReplaySubject<boolean>);
    Disabled: boolean;
    get Text(): string;
    set Text(value: string);
    Width: int;
    Height: int;
    get Height$(): ReplaySubject<int>;
    set Height$(value: ReplaySubject<int>);
    Padding: Padding;
    Border: Border;
    Margin: Margin;
    Loading: boolean;
    Left?: string;
    Top?: string;
    Bottom?: string;
    Right?: string;
    _Width?: string;
    _Height?: string;
    BackColor: CGColor;
    PaddingAll?: string;
    PaddingLeft?: string;
    PaddingRight?: string;
    PaddingTop?: string;
    PaddingBottom?: string;
    GetForm(): TForm;
    SendResizeRequest(): void;
    protected SetupControlDefaults(): void;
    OnAdoption(parent: Control<any>): void;
    protected CreateElements(param: any): any;
    protected CreateElementsInternal(): any;
    protected GetStyleObject(): any;
    OnFormResized(width: int, height: int): void;
    OnParentSet(parent: Control<any>): void;
    protected InitComponents(): void;
    WndProc(m: Message): void;
    protected wmDestroy(m: Message): void;
    protected OnMouseMove(e: MouseEventArgs): void;
    protected OnMouseHover(e: EventArgs): void;
    protected OnClick(e: EventArgs): void;
}
export {};

export class ControlCollection<TParent extends Control = any, TItem extends Control = any> extends List<any> {
    ItemAdded: Event<any>;
    get Parent(): TParent;
    constructor(parent: TParent);
    Get(index: int): TItem;
    Add(item: TItem): int;
    RemoveAt(index: int): void;
}
export class ComponentCollection<T = TComponent> extends List<T> {
    constructor(parent: TComponent);
    Add(item: T): int;
    RemoveAt(index: int): void;
}

export const ApplicationContext: {
    _id: any;
    _defaultValue: any;
    Consumer(props: any, contextValue: any): any;
    Provider(props: any): any;
};
export function useApplication(): TApplication;
export interface ILogService {
    log(text: string): void;
}
export function useLogService(): ILogService;
export enum ApplicationModes {
    Desktop = 1,
    Portal = 2,
    Mobile = 3
}
export class TApplication extends Control<TApplication> {
    static ApplicationMode: ApplicationModes;
    static get IsDesktop(): boolean;
    static get IsPortal(): boolean;
    static get IsMobile(): boolean;
    get StartResolve(): any;
    set StartResolve(value: any);
    get Icon(): string;
    set Icon(value: string);
    get Disposed(): boolean;
    set Disposed(value: boolean);
    get Name(): string;
    set Name(value: string);
    get Forms(): List<TForm>;
    set Forms(value: List<TForm>);
    protected get Controller(): UIController;
    protected set Controller(value: UIController);
    protected get MainForm(): TForm;
    protected set MainForm(value: TForm);
    get LogService(): ILogService;
    set LogService(value: ILogService);
    protected SetupControlDefaults(): void;
    protected SetupComponentDefaults(): void;
    SetMainForm(mainform: TForm): void;
    SetMainController(mainform: UIController): void;
    protected GetTheme(): any;
    CreateElements(): any;
    Dispose(): void;
    Start(): void;
}

export class TopMaximizeChangeHandler extends Delegate<(topMaximized: boolean) => void> {
}
export class TForm<TController = any> extends Control<TForm, TController> {
    static ActiveForm: TForm;
    m_Dialog: Dialog;
    get OnResizeInternal(): Function;
    set OnResizeInternal(value: Function);
    get ResizeEnd(): Event<EventHandler>;
    set ResizeEnd(value: Event<EventHandler>);
    get ZIndex(): int;
    set ZIndex(value: int);
    get Maximizable(): boolean;
    set Maximizable(value: boolean);
    get TopMaximizable(): boolean;
    set TopMaximizable(value: boolean);
    get IsActive(): boolean;
    set IsActive(value: boolean);
    get Minimizable(): boolean;
    set Minimizable(value: boolean);
    TopMaximized: boolean;
    TopMaximizeChanged: Event<TopMaximizeChangeHandler>;
    DefaultUrl: string;
    get Maximized(): boolean;
    set Maximized(value: boolean);
    get Minimized(): boolean;
    set Minimized(value: boolean);
    get Resizable(): boolean;
    set Resizable(value: boolean);
    get Name(): string;
    set Name(value: string);
    get MainMenu(): Control<MainMenu | RibbonMenu>;
    set MainMenu(value: Control<MainMenu | RibbonMenu>);
    get Application(): TApplication;
    set Application(value: TApplication);
    get Icon(): string;
    set Icon(value: string);
    get Controls(): ControlCollection;
    set Controls(value: ControlCollection);
    get FooterControls(): ControlCollection;
    set FooterControls(value: ControlCollection);
    get ShowHeader(): boolean;
    set ShowHeader(value: boolean);
    get HeaderTitleColor(): string;
    set HeaderTitleColor(value: string);
    get HeaderTitleAlign(): string;
    set HeaderTitleAlign(value: string);
    get HeaderTitleFontSize(): string;
    set HeaderTitleFontSize(value: string);
    get Modal(): boolean;
    set Modal(value: boolean);
    get IsMdiContainer(): boolean;
    set IsMdiContainer(value: boolean);
    get MdiParent(): TForm;
    set MdiParent(value: TForm);
    get HeaderHeight(): string;
    set HeaderHeight(value: string);
    get HeaderPadding(): string;
    set HeaderPadding(value: string);
    get HeaderSubStyle(): string;
    set HeaderSubStyle(value: string);
    get HeaderColor(): string;
    set HeaderColor(value: string);
    get ContentHeight(): int;
    set ContentHeight(value: int);
    get ContentHeight$(): ReplaySubject<int>;
    set ContentHeight$(value: ReplaySubject<int>);
    get ContentPadding(): string;
    set ContentPadding(value: string);
    HScroll: boolean;
    VScroll: boolean;
    constructor();
    constructor(props: any);
    protected SetupControlDefaults(): void;
    protected SetupComponentDefaults(): void;
    componentDidMount(): void;
    componentWillUnmount(): void;
    InitComponents(): void;
    CreateFooterControls(): any[];
    get ZOrder(): int;
    set ZOrder(value: int);
    CreateElements(): any;
    StartFormDrag(event: any): any;
    Maximize(): void;
    TopMaximize(): void;
    OnShown(): void;
    Show(): void;
    ShowDialog(): void;
    Hide(): void;
    protected OnResize(e: any): void;
}

export enum DialogResult {
    Abort = 3,
    Cancel = 2,
    Continue = 11,
    Ignore = 5,
    No = 7,
    None = 0,
    OK = 1,
    Retry = 4,
    TryAgain = 10,
    Yes = 6
}
export class Dialog<TController = any> extends Control<Dialog, TController> {
    DialogResult: DialogResult;
    Position: string;
    get Controls(): ControlCollection;
    set Controls(value: ControlCollection);
    get FooterControls(): ControlCollection;
    set FooterControls(value: ControlCollection);
    SetupControlDefaults(): void;
    CreateElements(): any;
    OnShown(): void;
    ShowDialog(): void;
    protected ShowDialogAsyncResolve: any;
    protected ShowDialogAsyncReject: any;
    ShowDialogAsync(): Promise<any>;
    Hide(): void;
    protected GetStyleObject(): any;
}

export class TTextBox extends Control<TTextBox> implements ITextBox {
    Label: string;
    Placeholder: string;
    Autofocus: boolean;
    LeftIcon: string;
    OnKeyDownInternal: Function;
    KeyDown: Event<any>;
    constructor();
    OnTextChange(text: string): void;
    protected OnKeyDown(e: any): void;
    protected GetRenderer(): any;
}

export class TTextArea extends Control<TTextArea> {
    get Label(): string;
    set Label(value: string);
    CreateElements(): any;
    OnTextChange(text: string): void;
}

export class TabPageCollection<T extends TTabPage> extends ControlCollection<TTabControl, T> {
    Add(item: T): int;
}
export class TTabPage extends Control<TTabPage> {
    get Closable(): boolean;
    set Closable(value: boolean);
    get Controls(): ControlCollection;
    set Controls(value: ControlCollection);
    protected SetupControlDefaults(): void;
    OnActivate(): void;
    AddControl(control: any): void;
    CreateControls(): any;
    CreateElements(): any;
    OnFormResized(width: int, height: int): void;
}
export class TTabControl<T extends TTabPage = TTabPage> extends Control<TTabControl<T>> implements IControlContainer {
    SelectedIndexChanged: Event<any>;
    TabPages: TabPageCollection<T>;
    ShowHeader: boolean;
    Closable: boolean;
    ActiveIndex: int;
    TabPageAdded: Event<any>;
    TabPageRemoved: Event<any>;
    get ActiveIndex$(): Observable<int>;
    set ActiveIndex$(value: Observable<int>);
    get ActiveTabPage(): TTabPage;
    set ActiveTabPage(value: TTabPage);
    constructor();
    AddTabPage(tabPage: T): void;
    protected GetRenderer(): typeof TTabControlRenderer;
    GetControls(): List<Control<any>>;
    OnFormResized(width: int, height: int): void;
    ForceUpdate(): void;
}

export class TComboBox extends Control<TComboBox> {
    get SelectedItem(): any;
    set SelectedItem(value: any);
    get Label(): string;
    set Label(value: string);
    CreateElements(): any;
}

class PageControlCollection extends List<Control<any>> {
    _: any;
    constructor(page: Page);
    Add(item: any): int;
}
export class Page extends Control<Page> {
    get SideBarControls(): PageControlCollection;
    set SideBarControls(value: PageControlCollection);
    get ContentControls(): PageControlCollection;
    set ContentControls(value: PageControlCollection);
    protected SetupControlDefaults(): void;
    InitComponents(): void;
    CreateElements(): any;
}
export {};

export class TSplitter extends Control<TSplitter> {
    get LeftControl(): Control;
    set LeftControl(value: Control);
    get RightControl(): Control;
    set RightControl(value: Control);
    CreateElements(): any;
}

export class TCanvas extends Control<TCanvas> {
    CreateElements(): any;
}

export class MainMenu extends Control<MainMenu> {
    get Model(): any[];
    set Model(value: any[]);
    CreateElements(): any;
}

class DesktopIconCollection extends List<DesktopIcon> {
    _: any;
    constructor(page: Desktop);
    Add(item: DesktopIcon): int;
}
class ModalCollection extends List<Dialog> {
    Remove(removedItem: Dialog): boolean;
}
class ModalDialogContainer extends TComponent {
    ModalDialogs: ModalCollection;
    protected SetupControlDefaults(): void;
    protected CreateElements<T>(param?: T): any;
}
export class Desktop extends Control<Desktop> {
    static TopControl: Control<any>;
    static ModalDialogContainer: ModalDialogContainer;
    static User: string;
    fileUploadRef: any;
    taskbar: Taskbar;
    get AppView(): boolean;
    set AppView(value: boolean);
    get Password(): boolean;
    set Password(value: boolean);
    get Icons(): DesktopIconCollection;
    set Icons(value: DesktopIconCollection);
    get _Router(): Router;
    set _Router(value: Router);
    get ShowAuthemticationDialog(): boolean;
    set ShowAuthemticationDialog(value: boolean);
    SiteMode: boolean;
    protected SetupControlDefaults(): void;
    protected SetupComponentDefaults(): void;
    protected InitComponents(): void;
    InitDesktop(): void;
    static DesktopContextMenu: any;
    get ProfilePicture(): string;
    set ProfilePicture(value: string);
    Controls: ControlCollection;
    CreateElements(): any;
    protected componentDidMount(): void;
    protected componentWillUnmount(): void;
    Start(): void;
}
export {};

class ClickEvent extends Delegate<() => void> {
}
export class DesktopIcon extends TComponent {
    m_OnClick: Event<ClickEvent>;
    Loading: boolean;
    get Text(): string;
    set Text(value: string);
    get Parent(): Desktop;
    set Parent(value: Desktop);
    get Index(): int;
    set Index(value: int);
    get AppInfo(): any;
    set AppInfo(value: any);
    get Icon(): string;
    set Icon(value: string);
    get ApplicationType(): any;
    set ApplicationType(value: any);
    get OnClick(): Event<ClickEvent>;
    set OnClick(value: Event<ClickEvent>);
    protected SetupControlDefaults(): void;
    SetManifest(appInfo: any, applicationType?: any): void;
    componentDidMount(): void;
    protected OnRequestStartApplication(): void;
    CreateElements(): any;
}
export {};

export class TaskManager {
    static Start(appType: any): Promise<TApplication>;
    static Quit(app: TApplication): void;
    static GetApplications(): TApplication[];
}

export class ConsoleReady extends Delegate<(console: TextConsole<any>) => void> {
}
export class Terminal extends Control<Terminal> {
    get OnConsoleReady(): Event<ConsoleReady>;
    set OnConsoleReady(value: Event<ConsoleReady>);
    get Console(): TextConsole<any>;
    set Console(value: TextConsole<any>);
    get Label(): string;
    set Label(value: string);
    protected SetupControlDefaults(): void;
    componentDidMount(): void;
    CreateElements(): any;
}

export class CheckedChangedEventHandler extends Delegate<(checked: boolean) => void> {
}
export class Checkbox extends Control<Checkbox> {
    get Checked(): boolean;
    set Checked(value: boolean);
    get CheckedChanged(): Event<CheckedChangedEventHandler>;
    set CheckedChanged(value: Event<CheckedChangedEventHandler>);
    protected SetupControlDefaults(): void;
    protected SetupComponentDefaults(): void;
    CreateElements(): any;
    OnChange(): void;
}

export enum FormLayoutModes {
    Vertical = 0,
    VerticalGrid = 1,
    HorizontalFixed = 2,
    HorizontalFluid = 3
}
export class FormLayout extends Control<FormLayout> {
    get Layout(): FormLayoutModes;
    set Layout(value: FormLayoutModes);
    get Controls(): ControlCollection;
    set Controls(value: ControlCollection);
    protected SetupControlDefaults(): void;
    CreateElements(): any;
}

export class Panel extends Control<Panel> {
    Controls: ControlCollection;
    constructor();
    protected OnMouseMove(e: EventArgs): void;
}
export class TControlContainer extends Control<Panel> {
    Controls: ControlCollection;
    constructor();
    protected GetRenderer(): any;
    protected OnMouseMove(e: EventArgs): void;
}
export interface IVirtualContainer extends IControl {
    Controls: ControlCollection;
    GetViews(): IRenderable[];
}
export class TVirtualContainer extends Control<Panel> implements IVirtualContainer {
    Controls: ControlCollection;
    GetViews(): IRenderable[];
    constructor();
    protected GetRenderer(): any;
    protected OnMouseMove(e: EventArgs): void;
}
export class TContainerControlRenderer extends ControlHtmlRenderer<IVirtualContainer> {
    ChildrenCreating: Event<any>;
    OnStyleCreating(obj: IVirtualContainer, sb: StringBuilder): void;
    GenerateElement(obj: IVirtualContainer): boolean;
    GenerateBody(obj: IVirtualContainer): void;
    protected CreateControls(obj: IVirtualContainer): any[];
}
export class TFlexContainer extends TVirtualContainer {
    constructor();
}
export class TFlexColumnContainer extends TVirtualContainer {
    constructor();
}
export class TFlexRowContainer extends TVirtualContainer {
    constructor();
}
export class ContainerPanel extends Control<ContainerPanel> {
    get Controls(): ControlCollection;
    set Controls(value: ControlCollection);
    protected SetupControlDefaults(): void;
    InitComponents(): void;
    CreateElements(): any;
}

export class FileUpload extends Control<FileUpload> {
    Url: string;
    get FileReady(): Event<EventHandler>;
    set FileReady(value: Event<EventHandler>);
    get AllowedExtensions(): string;
    set AllowedExtensions(value: string);
    SetupControlDefaults(): void;
    SetupComponentDefaults(): void;
    get Label(): string;
    set Label(value: string);
    get SelectedFileName(): string;
    get SelectedFileExt(): string;
    GetFileContentAsString(): string;
    GetFileContentAsByteArray(): ByteArray;
    SelectFile(): void;
    CreateElements(): any;
}

export class ScrollPanel extends ContainerControl<ScrollPanel> {
    CreateElements(): any;
}

export class MediaPlayer extends Control<MediaPlayer> {
    m_videoComponent: any;
    get Url(): string;
    set Url(value: string);
    get PreviewImage(): string;
    set PreviewImage(value: string);
    get Logo(): string;
    set Logo(value: string);
    get Playing(): boolean;
    set Playing(value: boolean);
    SetupControlDefaults(): void;
    CreateElements(): any;
    Play(): void;
    Stop(): void;
    OnTextChange(text: string): void;
}

export class PanelMenu extends Control<PanelMenu> {
    get Model(): any;
    set Model(value: any);
    CreateElements(): any;
}

export class PaintEventHandler extends Delegate<(g: SketchGraphics) => void> {
}
export class Canvas extends Control<Canvas> {
    get OnPaintInternal(): Function;
    set OnPaintInternal(value: Function);
    get PaintEvent(): Event<PaintEventHandler>;
    set PaintEvent(value: Event<PaintEventHandler>);
    get Graphics(): SketchGraphics;
    get Umay(): Umay;
    set Umay(value: Umay);
    get ID(): string;
    set ID(value: string);
    SetupControlDefaults(): void;
    protected OnPaint(e: SketchGraphics): void;
    componentDidMount(): void;
    ResizeCanvas(width: int, height: int): void;
    componentWillUnmount(): void;
    CreateElements(): any;
}

export class GuiConsole extends Control<GuiConsole> {
    get OnConsoleReady(): Event<ConsoleReady>;
    set OnConsoleReady(value: Event<ConsoleReady>);
    get Console(): GC<any>;
    set Console(value: GC<any>);
    get Label(): string;
    set Label(value: string);
    protected SetupControlDefaults(): void;
    componentDidMount(): void;
    CreateElements(): any;
}

export class PageFrame extends Control<PageFrame> {
    get _Loaded(): boolean;
    set _Loaded(value: boolean);
    get Src(): string;
    set Src(value: string);
    SetupComponentDefaults(): void;
    GetContentHeight(): int;
    GetFrameElement(): any;
    CreateElements(): any;
}

export class Rating extends Control<Rating> {
    get StarColor(): string;
    set StarColor(value: string);
    get Stars(): int;
    set Stars(value: int);
    get Size(): int;
    set Size(value: int);
    get Value(): int;
    set Value(value: int);
    get Cancel(): boolean;
    set Cancel(value: boolean);
    get ReadOnly(): boolean;
    set ReadOnly(value: boolean);
    SetupControlDefaults(): void;
    CreateElements(): any;
}

export let ResizeSensor: any;

export function IpcMessage(target: any, propertyKey: string, descriptor: PropertyDescriptor): void;
export function View<T extends {
    new (...args: any[]): {};
}>(Base: T): {
    new (...args: any[]): {};
} & T;
export function Controller<T extends {
    new (...args: any[]): {};
}>(Base: T): {
    new (...args: any[]): {};
} & T;
export abstract class TController {
    constructor();
    protected SendMessageToView(message: string, ...args: any[]): void;
    SetView(view: any): void;
}

export interface IView {
    Controller: TController;
    SetController(controller: TController): void;
    WndProc(msg: Message): any;
}

export class EventArgs {
    static readonly Empty: EventArgs;
    constructor();
}

export class EventHandler extends Delegate<(e: EventArgs) => void> {
}

export class UIButtonClass extends UIView implements IVirtualContainer {
    setController(controller: UIController): this;
    constructor();
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
    action(actionFunc: Function): this;
}
export function UIButton(...subViews: (UIView | IControl | UIController)[]): UIButtonClass;
export class UITextFieldClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    text(value: string): this;
    GetControl(): Control;
}
export function UITextField(): UITextFieldClass;

export class UISceneClass extends UIView implements IVirtualContainer {
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
    setController(controller: UIController): this;
    constructor();
}
export function UIScene(...subViews: (UIView | IControl | UIController)[]): UISceneClass;
export interface DesktopPreviewParams {
    width?: number | string;
    height?: number | string;
}
export type FunctionDesktopPreview = (...views: UIView[]) => UIView;
export function DesktopPreview(value: DesktopPreviewParams): FunctionDesktopPreview;
export function DesktopPreview(...subViews: (UIView | IControl | UIController)[]): UIView;
type ForEachIterateFunction<T> = (item: T, index?: number) => UIView;
export function ForEach<T>(enumarable: IEnumerator<T> | IEnumerable<T> | IList<T> | Array<T> | ICollection<T> | Iterator<T> | Iterable<T> | Set<T>): (value: ForEachIterateFunction<T>) => any[];
export function Filter(enumarable: any, enumFunc: Function): IRenderable[];
type TrueCaseFunction = (view: UIView) => FalseCaseFunction;
type FalseCaseFunction = {
    else: (view: UIView) => UIView;
};
export function If(condition: boolean): TrueCaseFunction;
export function Case<T extends UIView>(match: string | number, caseObject: any): T;
export {};

export const UIFormContext: {
    _id: any;
    _defaultValue: any;
    Consumer(props: any, contextValue: any): any;
    Provider(props: any): any;
};
export const UIControllerContext: {
    _id: any;
    _defaultValue: any;
    Consumer(props: any, contextValue: any): any;
    Provider(props: any): any;
};
export const bindFormController: () => UIFormController;
export const bindController: () => UIController;
export let currentController: any;
export function Context(): (target: any, key: string, descriptor: PropertyDescriptor) => void;
export class UIController<T = any> extends Control implements IRenderable, IVirtualContainer {
    IsModelBind: boolean;
    Theme: any;
    Error: string;
    Warning: string;
    setTheme(theme: any): void;
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
    ParentController: UIController;
    protected SetupControlDefaults(): void;
    protected InitController(): void;
    $<T>(value: T): BindingClass<T>;
    $$<T>(value: T): BindingClass<T>;
    LoadView(): UIView;
    Bind(model: T): this;
    OnBindModel(model: T): void;
    protected BindRouterParams(params?: any): void;
    protected UseRouter(): boolean;
    _location: any;
    _params: any;
    Application: TApplication;
    navigotor: NavigateFunction;
    dataProvider: any;
    protected OnWired(): void;
    protected OnComponentDidMount(): void;
    protected OnUnWired(): void;
    protected OnComponentWillUnmount(): boolean;
    protected GetDataProvider(): any;
    protected CreateElements(param: any): any;
    Render(): any;
}
export abstract class ValidateRule {
    Field: IField;
    ErrorMessage: string;
    constructor(errorMessage: string);
    setField(field: IField): void;
    abstract validate(): boolean;
}
export class RequiredRule extends ValidateRule {
    validate(): boolean;
}
export class MaxLengthRule extends ValidateRule {
    constructor(maxLength: int, errorMessage: string);
    validate(): boolean;
}
export interface IFieldState {
    errors: string[];
    invalid: boolean;
    isDirty: boolean;
    isTouched: boolean;
}
export interface IFieldOptions {
    rules: ValidateRule[];
}
export interface IField {
    value: any;
    state: IFieldState;
    options: IFieldOptions;
}
export class UIFormController extends UIController {
    validateForm(): any;
    protected OnSubmit(data: any): void;
    Submit(): void;
    ResetForm(): void;
    ClearErrors(): void;
    SetValue(name: string, value: any): void;
    GetValue(name: string): any;
    GetFieldState(name: string): IFieldState;
    SetFieldTouch(name: string, isTouched: boolean): IFieldState;
    register(name: string, rules: ValidateRule[]): void;
    protected SetupControlDefaults(): void;
    protected CreateElements(param: any): any;
}

export type DividerTyype = (view: UIView) => void;
export class VStackDividerTypes {
    static Divide0: (view: UIView) => void;
    static Divide: (view: UIView) => void;
    static Divide2: (view: UIView) => void;
    static Divide4: (view: UIView) => void;
    static Divide8: (view: UIView) => void;
}
export class VStackClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
    divider(value: DividerTyype): this;
    protected CreateControls(obj: VStackClass): any[];
}
interface VStackParams {
    alignment?: AlignmentType;
    spacing?: int;
}
type FunctionVStack = (...views: UIView[]) => VStackClass;
export function VStack(): VStackClass;
export function VStack(...views: (UIView | IControl | UIController)[]): VStackClass;
export function VStack(value: VStackParams): FunctionVStack;
export function Cache(useCache: boolean, builder: () => UIView): UIView;
export function AnimationStack(...subViews: (UIView | IControl | UIController)[]): VStackClass;
export class FVStackClass extends VStackClass {
    Render(): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
    };
}
export function FVStack(): FVStackClass;
export function FVStack(...views: (UIView | IControl | UIController)[]): FVStackClass;
export function FVStack(value: VStackParams): FunctionVStack;
export {};

export class HStackRenderer extends ControlHtmlRenderer<HStackClass> {
    ChildrenCreating: Event<any>;
    OnStyleCreating(obj: HStackClass, sb: StringBuilder): void;
    GenerateElement(obj: HStackClass): boolean;
    GenerateBody(obj: HStackClass): void;
    protected CreateControls(obj: HStackClass): any[];
}
export class HStackClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
}
interface HStackParams {
    alignment?: AlignmentType;
    spacing?: int;
}
type FunctionVStack = (...views: UIView[]) => HStackClass;
export function HStack(): HStackClass | FunctionVStack;
export function HStack(...views: (UIView | IControl | UIController)[]): HStackClass;
export function HStack(value: HStackParams): FunctionVStack;
export class FHStackClass extends UIView {
    constructor();
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
    protected CreateControls(obj: FHStackClass): any[];
    Render(): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
    };
}
export function FHStack(): FHStackClass | FunctionVStack;
export function FHStack(...views: (UIView | IControl | UIController)[]): FHStackClass;
export function FHStack(value: HStackParams): FunctionVStack;
export {};

export class ZStackRenderer extends ControlHtmlRenderer<ZStackClass> {
    GenerateElement(obj: ZStackClass): boolean;
    GenerateBody(obj: ZStackClass): void;
    protected CreateControls(obj: ZStackClass): any[];
}
export class ZStackClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    setChilds(...args: (UIView | IControl | UIController)[]): this;
}
export function ZStack(...subViews: (UIView | IControl | UIController)[]): ZStackClass;

export enum RenderingTypes {
    Normal = 1,
    Markdown = 2
}
export enum TextAlignment {
    center = 0,
    leading = 1,
    trailing = 2
}
export class UITextClass extends UIView implements ILabel {
    setController(controller: UIController): this;
    constructor();
    text(buttonLabel: string): this;
    textAlign(value: string): this;
    render(type: RenderingTypes): this;
    multilineTextAlignment(value: TextAlignment): this;
    whiteSpace(value: string): this;
    textOverflow(value: string): this;
    searchWords(value: string[]): this;
}
export function Text(text: string): UITextClass;
export class UIFastTextClass extends UITextClass implements ILabel {
    Render(): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
    };
}
export function FastText(text: string): UIFastTextClass;

export class DividerClass extends UIView {
    setController(controller: UIController): this;
}
export function VDivider(): DividerClass;
export function HDivider(): DividerClass;

export function Color(value: string): ColorClass;
export namespace Color {
    let black: ColorClass;
    let navy: ColorClass;
    let darkblue: ColorClass;
    let mediumblue: ColorClass;
    let blue: ColorClass;
    let darkgreen: ColorClass;
    let green: ColorClass;
    let teal: ColorClass;
    let darkcyan: ColorClass;
    let deepskyblue: ColorClass;
    let darkturquoise: ColorClass;
    let mediumspringgreen: ColorClass;
    let lime: ColorClass;
    let springgreen: ColorClass;
    let aqua: ColorClass;
    let cyan: ColorClass;
    let midnightblue: ColorClass;
    let dodgerblue: ColorClass;
    let lightseagreen: ColorClass;
    let forestgreen: ColorClass;
    let seagreen: ColorClass;
    let darkslategray: ColorClass;
    let limegreen: ColorClass;
    let mediumseagreen: ColorClass;
    let turquoise: ColorClass;
    let royalblue: ColorClass;
    let steelblue: ColorClass;
    let darkslateblue: ColorClass;
    let mediumturquoise: ColorClass;
    let indigo: ColorClass;
    let darkolivegreen: ColorClass;
    let cadetblue: ColorClass;
    let cornflowerblue: ColorClass;
    let rebeccapurple: ColorClass;
    let mediumaquamarine: ColorClass;
    let dimgray: ColorClass;
    let slateblue: ColorClass;
    let olivedrab: ColorClass;
    let slategray: ColorClass;
    let lightslategray: ColorClass;
    let mediumslateblue: ColorClass;
    let lawngreen: ColorClass;
    let chartreuse: ColorClass;
    let aquamarine: ColorClass;
    let maroon: ColorClass;
    let purple: ColorClass;
    let olive: ColorClass;
    let gray: ColorClass;
    let skyblue: ColorClass;
    let lightskyblue: ColorClass;
    let blueviolet: ColorClass;
    let darkred: ColorClass;
    let darkmagenta: ColorClass;
    let saddlebrown: ColorClass;
    let darkseagreen: ColorClass;
    let lightgreen: ColorClass;
    let mediumpurple: ColorClass;
    let darkviolet: ColorClass;
    let palegreen: ColorClass;
    let darkorchid: ColorClass;
    let yellowgreen: ColorClass;
    let sienna: ColorClass;
    let brown: ColorClass;
    let darkgray: ColorClass;
    let lightblue: ColorClass;
    let greenyellow: ColorClass;
    let paleturquoise: ColorClass;
    let lightsteelblue: ColorClass;
    let powderblue: ColorClass;
    let firebrick: ColorClass;
    let darkgoldenrod: ColorClass;
    let mediumorchid: ColorClass;
    let rosybrown: ColorClass;
    let darkkhaki: ColorClass;
    let silver: ColorClass;
    let mediumvioletred: ColorClass;
    let indianred: ColorClass;
    let peru: ColorClass;
    let chocolate: ColorClass;
    let tan: ColorClass;
    let lightgray: ColorClass;
    let thistle: ColorClass;
    let orchid: ColorClass;
    let goldenrod: ColorClass;
    let palevioletred: ColorClass;
    let crimson: ColorClass;
    let gainsboro: ColorClass;
    let plum: ColorClass;
    let burlywood: ColorClass;
    let lightcyan: ColorClass;
    let lavender: ColorClass;
    let darksalmon: ColorClass;
    let violet: ColorClass;
    let palegoldenrod: ColorClass;
    let lightcoral: ColorClass;
    let khaki: ColorClass;
    let aliceblue: ColorClass;
    let honeydew: ColorClass;
    let azure: ColorClass;
    let sandybrown: ColorClass;
    let wheat: ColorClass;
    let beige: ColorClass;
    let whitesmoke: ColorClass;
    let mintcream: ColorClass;
    let ghostwhite: ColorClass;
    let salmon: ColorClass;
    let antiquewhite: ColorClass;
    let linen: ColorClass;
    let lightgoldenrodyellow: ColorClass;
    let oldlace: ColorClass;
    let red: ColorClass;
    let fuchsia: ColorClass;
    let magenta: ColorClass;
    let deeppink: ColorClass;
    let orangered: ColorClass;
    let tomato: ColorClass;
    let hotpink: ColorClass;
    let coral: ColorClass;
    let darkorange: ColorClass;
    let lightsalmon: ColorClass;
    let orange: ColorClass;
    let lightpink: ColorClass;
    let pink: ColorClass;
    let gold: ColorClass;
    let peachpuff: ColorClass;
    let navajowhite: ColorClass;
    let moccasin: ColorClass;
    let bisque: ColorClass;
    let mistyrose: ColorClass;
    let blanchedalmond: ColorClass;
    let papayawhip: ColorClass;
    let lavenderblush: ColorClass;
    let seashell: ColorClass;
    let cornsilk: ColorClass;
    let lemonchiffon: ColorClass;
    let floralwhite: ColorClass;
    let snow: ColorClass;
    let yellow: ColorClass;
    let lightyellow: ColorClass;
    let ivory: ColorClass;
    let white: ColorClass;
    let blue50: ColorClass;
    let blue100: ColorClass;
    let blue200: ColorClass;
    let blue300: ColorClass;
    let blue400: ColorClass;
    let blue500: ColorClass;
    let blue600: ColorClass;
    let blue700: ColorClass;
    let blue800: ColorClass;
    let blue900: ColorClass;
    let green50: ColorClass;
    let green100: ColorClass;
    let green200: ColorClass;
    let green300: ColorClass;
    let green400: ColorClass;
    let green500: ColorClass;
    let green600: ColorClass;
    let green700: ColorClass;
    let green800: ColorClass;
    let green900: ColorClass;
    let yellow50: ColorClass;
    let yellow100: ColorClass;
    let yellow200: ColorClass;
    let yellow300: ColorClass;
    let yellow400: ColorClass;
    let yellow500: ColorClass;
    let yellow600: ColorClass;
    let yellow700: ColorClass;
    let yellow800: ColorClass;
    let yellow900: ColorClass;
    let cyan50: ColorClass;
    let cyan100: ColorClass;
    let cyan200: ColorClass;
    let cyan300: ColorClass;
    let cyan400: ColorClass;
    let cyan500: ColorClass;
    let cyan600: ColorClass;
    let cyan700: ColorClass;
    let cyan800: ColorClass;
    let cyan900: ColorClass;
    let pink50: ColorClass;
    let pink100: ColorClass;
    let pink200: ColorClass;
    let pink300: ColorClass;
    let pink400: ColorClass;
    let pink500: ColorClass;
    let pink600: ColorClass;
    let pink700: ColorClass;
    let pink800: ColorClass;
    let pink900: ColorClass;
    let indigo50: ColorClass;
    let indigo100: ColorClass;
    let indigo200: ColorClass;
    let indigo300: ColorClass;
    let indigo400: ColorClass;
    let indigo500: ColorClass;
    let indigo600: ColorClass;
    let indigo700: ColorClass;
    let indigo800: ColorClass;
    let indigo900: ColorClass;
    let teal50: ColorClass;
    let teal100: ColorClass;
    let teal200: ColorClass;
    let teal300: ColorClass;
    let teal400: ColorClass;
    let teal500: ColorClass;
    let teal600: ColorClass;
    let teal700: ColorClass;
    let teal800: ColorClass;
    let teal900: ColorClass;
    let orange50: ColorClass;
    let orange100: ColorClass;
    let orange200: ColorClass;
    let orange300: ColorClass;
    let orange400: ColorClass;
    let orange500: ColorClass;
    let orange600: ColorClass;
    let orange700: ColorClass;
    let orange800: ColorClass;
    let orange900: ColorClass;
    let bluegray50: ColorClass;
    let bluegray100: ColorClass;
    let bluegray200: ColorClass;
    let bluegray300: ColorClass;
    let bluegray400: ColorClass;
    let bluegray500: ColorClass;
    let bluegray600: ColorClass;
    let bluegray700: ColorClass;
    let bluegray800: ColorClass;
    let bluegray900: ColorClass;
    let purple50: ColorClass;
    let purple100: ColorClass;
    let purple200: ColorClass;
    let purple300: ColorClass;
    let purple400: ColorClass;
    let purple500: ColorClass;
    let purple600: ColorClass;
    let purple700: ColorClass;
    let purple800: ColorClass;
    let purple900: ColorClass;
    let red50: ColorClass;
    let red100: ColorClass;
    let red200: ColorClass;
    let red300: ColorClass;
    let red400: ColorClass;
    let red500: ColorClass;
    let red600: ColorClass;
    let red700: ColorClass;
    let red800: ColorClass;
    let red900: ColorClass;
    let primary50: ColorClass;
    let primary100: ColorClass;
    let primary200: ColorClass;
    let primary300: ColorClass;
    let primary400: ColorClass;
    let primary500: ColorClass;
    let primary600: ColorClass;
    let primary700: ColorClass;
    let primary800: ColorClass;
    let primary900: ColorClass;
    let surfacea: ColorClass;
    let surfaceb: ColorClass;
    let surfacec: ColorClass;
    let surfaced: ColorClass;
    let surfacee: ColorClass;
    let surfacef: ColorClass;
    let textcolor: ColorClass;
    let textcolorsecondary: ColorClass;
    let primarycolor: ColorClass;
    let primarycolortext: ColorClass;
    let surface0: ColorClass;
    let surface50: ColorClass;
    let surface100: ColorClass;
    let surface200: ColorClass;
    let surface300: ColorClass;
    let surface400: ColorClass;
    let surface500: ColorClass;
    let surface600: ColorClass;
    let surface700: ColorClass;
    let surface800: ColorClass;
    let surface900: ColorClass;
    let gray50: ColorClass;
    let gray100: ColorClass;
    let gray200: ColorClass;
    let gray300: ColorClass;
    let gray400: ColorClass;
    let gray500: ColorClass;
    let gray600: ColorClass;
    let gray700: ColorClass;
    let gray800: ColorClass;
    let gray900: ColorClass;
    let contentpadding: ColorClass;
    let inlinespacing: ColorClass;
    let borderradius: ColorClass;
    let surfaceground: ColorClass;
    let surfacesection: ColorClass;
    let surfacecard: ColorClass;
    let surfaceoverlay: ColorClass;
    let surfaceborder: ColorClass;
    let surfacehover: ColorClass;
}
export class UITemplate {
    primary50: ColorClass;
    primary100: ColorClass;
    primary200: ColorClass;
    primary300: ColorClass;
    primary400: ColorClass;
    primary500: ColorClass;
    primary600: ColorClass;
    primary700: ColorClass;
    primary800: ColorClass;
    primary900: ColorClass;
    surfacea: ColorClass;
    surfaceb: ColorClass;
    surfacec: ColorClass;
    surfaced: ColorClass;
    surfacee: ColorClass;
    surfacef: ColorClass;
    textcolor: ColorClass;
    textcolorsecondary: ColorClass;
    primarycolor: ColorClass;
    primarycolortext: ColorClass;
    surface0: ColorClass;
    surface50: ColorClass;
    surface100: ColorClass;
    surface200: ColorClass;
    surface300: ColorClass;
    surface400: ColorClass;
    surface500: ColorClass;
    surface600: ColorClass;
    surface700: ColorClass;
    surface800: ColorClass;
    surface900: ColorClass;
    gray50: ColorClass;
    gray100: ColorClass;
    gray200: ColorClass;
    gray300: ColorClass;
    gray400: ColorClass;
    gray500: ColorClass;
    gray600: ColorClass;
    gray700: ColorClass;
    gray800: ColorClass;
    gray900: ColorClass;
    contentpadding: ColorClass;
    inlinespacing: ColorClass;
    borderradius: ColorClass;
    surfaceground: ColorClass;
    surfacesection: ColorClass;
    surfacecard: ColorClass;
    surfaceoverlay: ColorClass;
    surfaceborder: ColorClass;
    surfacehover: ColorClass;
    fontFamily: string;
    contentPadding: string;
    inlineSpacing: string;
    borderRadius: string;
    focusRing: string;
    maskbg: string;
}
export interface StyleAttribute {
    default?: string | ColorClass;
    hover?: string | ColorClass;
    active?: string | ColorClass;
    disabled?: string | ColorClass;
    focus?: string | ColorClass;
    before?: string | ColorClass;
}
export type FontWeightModifierTypes = 'normal' | 'bold' | 'lighter' | 'bolder' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900' | 'inherit' | 'initial' | 'revert' | 'unset';
export type TextAligns = 'left' | 'right' | 'center' | 'justify' | 'initial' | 'inherit';
export type VerticalAligns = 'bottom' | 'middle' | 'top';
export type TextTransforms = 'capitalize' | 'uppercase' | 'lowercase' | 'none' | 'full-width' | 'full-size-kana';
export enum ShadowTypes {
    Small = "0 1px 2px 0 rgb(0 0 0 / 0.05)",
    Shadow = "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
    Medium = "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
    Large = "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
    XLarge = "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
    XXLarge = "0 25px 50px -12px rgb(0 0 0 / 0.25)",
    Inner = "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
    None = "0 0 #0000"
}
export enum CornerRadiusTypes {
    None = "0px",
    Small = "0.125rem",
    Rounded = "0.25rem",
    Medium = "0.375rem",
    Large = "0.5rem",
    XLarge = "0.75rem",
    XXLarge = "1rem",
    XXXLarge = "1.5rem",
    Full = "9999px"
}
export class FontSizeTypes {
    static XSmall: (view: UIView) => void;
    static Small: (view: UIView) => void;
    static Base: (view: UIView) => void;
    static Large: (view: UIView) => void;
    static LargeX: (view: UIView) => void;
    static Large2X: (view: UIView) => void;
    static Large3X: (view: UIView) => void;
}
export class FontSmoothingTypes {
    static Antialiased: (view: UIView) => void;
    static Subpixel: (view: UIView) => void;
}
export interface IFont {
    family?: string;
    size?: string;
    weight?: FontWeightModifierTypes;
    leading?: string;
    spacing?: string;
}
export enum PositionTypes {
    Static = "static",
    Fixed = "fixed",
    Absolute = "absolute",
    Relative = "relative",
    Sticky = "sticky"
}
export class Fonts {
    static largeTitle: IFont;
    static title: IFont;
    static title2: IFont;
    static title3: IFont;
    static headline: IFont;
    static body: IFont;
    static callout: IFont;
    static subhead: IFont;
    static footnote: IFont;
    static caption: IFont;
    static caption2: IFont;
}
export enum Alignment {
    topLeading = 0,
    top = 1,
    topTrailing = 2,
    leading = 3,
    center = 4,
    trailing = 5,
    bottomTrailing = 6,
    bottom = 7,
    bottomLeading = 8
}
export function ViewProperty(defaultValue?: any): any;
export class UIView implements IVirtualContainer, IControl, IRenderable {
    PropertyBag(value: any): this;
    _initial: any;
    _animate: any;
    _transition: any;
    _whileHover: any;
    _whileTap: any;
    _whileDrag: any;
    _whileFocus: any;
    _whileInView: any;
    _exit: any;
    renderAsAnimated: boolean;
    protected SubViews: List<IRenderable>;
    controller: UIController;
    protected Renderer: ControlHtmlRenderer<any>;
    vp_Alias: string;
    vp_UseCache: boolean;
    Text: string;
    Tooltip: string;
    Appearance: AppearanceObject;
    HoverAppearance: AppearanceObject;
    FocusAppearance: AppearanceObject;
    ActiveAppearance: AppearanceObject;
    DisabledAppearance: AppearanceObject;
    BeforeAppearance: AppearanceObject;
    PropertyChanged: Event<any>;
    UpdateRequied: Event<any>;
    Controls: ControlCollection<any, any>;
    vp_TableHeaderWidth: string;
    vp_TableHeaderHeight: string;
    vp_Skeleton: boolean;
    vp_Disabled: boolean;
    disabled(value: boolean): this;
    GetViews(): IRenderable[];
    setController(controller: UIController): this;
    initial(value: any): this;
    animate(value: any): this;
    __transition(value: any): this;
    hover(value: any): this;
    tap(value: any): this;
    drag(value: any): this;
    focus(value: any): this;
    constructor();
    OnLoaded(): void;
    OnUnLoaded(): void;
    OnAppearanceChanged(name: string): void;
    TabIndex: int;
    BackgroundColor: string;
    Padding: Padding;
    Border: Border;
    Margin: Margin;
    Id: string;
    Visible: boolean;
    KeyFrameCollection: KeyFrameCollection[];
    vp_SetFocus: Event<any>;
    vp_KillFocus: Event<any>;
    protected WmClick(nativeEvent: any): void;
    onClick(func: Function): this;
    FireClick(nativeEvent?: any): void;
    protected WmDbClick(nativeEvent: any): void;
    onDbClick(func: Function): this;
    protected WmMouseDown(nativeEvent: any): void;
    onMouseDown(func: Function): this;
    protected WmKeyDown(nativeEvent: any): void;
    onKeyDown(func: Function): this;
    protected WmSetFocus(nativeEvent: any): void;
    onFocus(func: Function): this;
    protected WmKillFocus(nativeEvent: any): void;
    onLostFocus(func: Function): this;
    WndProc(msg: Message): void;
    AddSubView(subView: UIView | IControl | UIController): void;
    Ref(refFunc: Function): this;
    protected IsChildValid(renderable: IRenderable): boolean;
    protected DoFlatten(...args: (UIView | IControl | UIController)[]): IRenderable[];
    setChilds(...args: (UIView | IControl | UIController)[]): this;
    If(_case: boolean, func: Function): this;
    ForEach(enumarable: any, enumFunc: Function): this;
    Render(): any;
    ForceUpdate(): void;
    tabIndex(value: int): this;
    zIndex(value: int): this;
    animation(value: KeyFrameCollection, time: string): this;
    variable(name: string, value: StyleAttribute): this;
    tooltip(value: string): this;
    visible(value: boolean): this;
    position(value: PositionTypes): this;
    position(value: StyleAttribute): this;
    position(value: string): this;
    left(value: StyleAttribute): this;
    left(value: string): this;
    top(value: StyleAttribute): this;
    top(value: string): this;
    right(value: StyleAttribute): this;
    right(value: string): this;
    bottom(value: StyleAttribute): this;
    bottom(value: string): this;
    transform(value: StyleAttribute): this;
    transform(value: string): this;
    rotate(value: string): this;
    clipPath(value: string): this;
    filter(value: string): this;
    font(font: IFont): this;
    verticalAlign(value: VerticalAligns): this;
    textAlign(value: TextAligns): this;
    textTransform(value: TextTransforms): this;
    fontFamily(size: string): this;
    fontSmoothing(value: (view: UIView) => void): this;
    fontSize(value: (view: UIView) => void): this;
    fontSize(size: int): this;
    fontSize(size: string): this;
    fontWeight(weight: FontWeightModifierTypes): this;
    lineHeight(size: int): this;
    lineHeight(size: string): this;
    grow(): this;
    width(): this;
    width(value: int): this;
    width(value: string): this;
    width(value: StyleAttribute): this;
    minWidth(): this;
    minWidth(value: int): this;
    minWidth(value: string): this;
    minWidth(value: StyleAttribute): this;
    maxWidth(): this;
    maxWidth(value: int): this;
    maxWidth(value: string): this;
    maxWidth(value: StyleAttribute): this;
    allWidth(): this;
    allWidth(value: int): this;
    allWidth(value: string): this;
    height(): this;
    height(value: int): this;
    height(value: string): this;
    height(value: StyleAttribute): this;
    allHeight(): this;
    allHeight(value: int): this;
    allHeight(value: string): this;
    minHeight(): this;
    minHeight(value: int): this;
    minHeight(value: string): this;
    minHeight(value: StyleAttribute): this;
    maxHeight(): this;
    maxHeight(value: int): this;
    maxHeight(value: string): this;
    maxHeight(value: StyleAttribute): this;
    foregroundColor(value: ColorClass): this;
    foregroundColor(value: StyleAttribute): this;
    foregroundColor(color: string): this;
    foregroundColor(condition: boolean, trueValue: string, falseValue: string): this;
    backgroundImage(value: StyleAttribute): this;
    backgroundImage(value: string): this;
    backgroundColor(value: StyleAttribute): this;
    backgroundColor(value: string): this;
    background(value: ColorClass): this;
    background(value: StyleAttribute): this;
    background(zstack: ZStackClass): this;
    background(color: string): this;
    background(condition: boolean, trueValue: string, falseValue: string): this;
    content(value: StyleAttribute): this;
    content(value: string): this;
    cursor(value: StyleAttribute): this;
    cursor(value: string): this;
    alignItems(value: string): this;
    alignContent(value: string): this;
    justifyContent(value: string): this;
    cornerRadius(): this;
    cornerRadius(value: CornerRadiusTypes): this;
    cornerRadius(value: string): this;
    cornerRadius(value: int): this;
    outline(value: StyleAttribute): this;
    outline(value: string): this;
    border(value: StyleAttribute): this;
    border(value: string): this;
    borderLeft(value: StyleAttribute): this;
    borderLeft(value: string): this;
    borderRight(value: StyleAttribute): this;
    borderRight(value: string): this;
    borderTop(value: StyleAttribute): this;
    borderTop(value: string): this;
    borderBottom(value: StyleAttribute): this;
    borderBottom(value: string): this;
    wrap(value: string): this;
    basis(value: string): this;
    margin(): this;
    margin(value: string): this;
    margin(value: int): this;
    marginVertical(): this;
    marginVertical(value: string): this;
    marginVertical(value: int): this;
    marginHorizontal(): this;
    marginHorizontal(value: string): this;
    marginHorizontal(value: int): this;
    marginLeft(value: string): this;
    marginRight(value: string): this;
    marginTop(value: string): this;
    marginBottom(value: string): this;
    padding(): this;
    padding(value: string): this;
    padding(type: string, value: string): this;
    padding(value: int): this;
    padding(type: string, value: int): this;
    paddingLeft(value: string): this;
    paddingRight(value: string): this;
    paddingTop(value: string): this;
    paddingBottom(value: string): this;
    overflow(value: string): this;
    overflowX(value: string): this;
    overflowY(value: string): this;
    shadow(value: StyleAttribute): this;
    shadow(value: ShadowTypes): this;
    shadow(value: string): this;
    transition(value: string): this;
    opacity(): this;
    opacity(value: int): this;
    opacity(value: string): this;
    opacity(value: StyleAttribute): this;
    display(value: StyleAttribute): this;
    display(value: string): this;
    kerning(value: string): this;
    wordBreak(value: 'normal' | 'break-all' | 'keep-all' | 'break-word'): this;
    wordWrap(value: 'normal' | 'break-word'): this;
    alignment(value: AlignmentType): this;
    protected createStyles(): string;
    alias(value: string): this;
    useCache(value: boolean): this;
    tableHeaderWidth(value: string): this;
    tableHeaderHeight(value: string): this;
    skeleton(value: boolean): this;
    variant(value: string): this;
    jssStyle: any;
    __createStyle(): any;
}

export class SpacerClass extends UIView {
    constructor();
}
export function Spacer(): SpacerClass;

export class RoundedRectangleClass extends UIView {
    setController(controller: UIController): this;
    constructor();
}
export function RoundedRectangle(): RoundedRectangleClass;

interface IImage extends IControl {
    Src: string;
    Img?: any;
}
export class UIImageClass extends UIView implements IImage {
    vp_ImageWidth: string;
    vp_ImageHeight: string;
    vp_ImageBorder: string;
    setController(controller: UIController): this;
    constructor();
    src(value: string): this;
    img(value: HTMLImageElement): this;
    imageWidth(value: int | string): this;
    imageHeight(value: int | string): this;
    imageBorder(value: string): this;
}
export function UIImage(src: string): UIImageClass;
export {};

export class UIAnimationRenderer extends ControlHtmlRenderer<UIAnimationClass> {
    get UseShadowDom(): boolean;
    OnStyleCreating(obj: UIAnimationClass, sb: StringBuilder): void;
    GenerateElement(obj: UIAnimationClass): boolean;
    GenerateBody(obj: UIAnimationClass): void;
    protected CreateControls(obj: UIAnimationClass): any[];
}
export class UIAnimationClass extends UIView {
    ShowAnimation: boolean;
    setController(controller: UIController): this;
    constructor();
    start(show: boolean): this;
}
export function UIAnimation(...subViews: (UIView | IControl | UIController)[]): UIAnimationClass;

export class UIMotionRenderer extends ControlHtmlRenderer<UIMotionClass> {
    get UseShadowDom(): boolean;
    GenerateElement(obj: UIMotionClass): boolean;
    GenerateBody(obj: UIMotionClass): void;
    protected CreateControls(obj: UIMotionClass): any[];
}
export class UIMotionClass extends UIView {
    _animate: any;
    _whileHover: any;
    _whileTap: any;
    _whileDrag: any;
    _whileFocus: any;
    _whileInView: any;
    _exit: any;
    setController(controller: UIController): this;
    constructor();
    animate(value: any): this;
    hover(value: any): this;
    tap(value: any): this;
    drag(value: any): this;
    focus(value: any): this;
}
export function UIMotion(...subViews: (UIView | IControl | UIController)[]): UIMotionClass;

export class GaugeClass extends UIView {
    Color: string;
    MaskColor: string;
    Value: int;
    Stroke: int;
    Radius: int;
    setController(controller: UIController): this;
    constructor();
    value(value: int): this;
    radius(value: int): this;
    stroke(value: int): this;
    color(value: string): this;
    maskColor(value: string): this;
}
export class RangeClass extends UIView {
}
export function Gauge(...subViews: RangeClass[]): GaugeClass;
export function Range(): RangeClass;

export class SliderClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    onSlideEnd(): void;
    action(value: (value: int) => void): this;
    value(value: int): this;
}
export function UISlider(): SliderClass;

export class KeyFrame {
    name: string;
    style: AppearanceObject;
    constructor(name: string);
}
export class KeyFrameCollection extends List<KeyFrame> {
    Name: string;
    constructor(name: string);
    ToString(): string;
}

interface ScrollViewParams {
    axes?: 'cHorizontal' | 'cVertical';
    alignment?: AlignmentType;
    showsIndicators?: boolean;
    content?: any;
}
type FunctionScrollView = (...views: UIView[]) => VStackClass;
export function ScrollView(value: string): FunctionScrollView;
export function ScrollView(...views: UIView[]): VStackClass;
export function ScrollView(value: ScrollViewParams): FunctionScrollView;
export {};

export const cHorizontal = "cHorizontal";
export const cVertical = "cVertical";
export const cLeft = "cLeft";
export const cRight = "cRight";
export const cTopLeading = "cTopLeading";
export const cTop = "cTop";
export const cTopTrailing = "cTopTrailing";
export const cLeading = "cLeading";
export const cCenter = "cCenter";
export const cTrailing = "cTrailing";
export const cBottomTrailing = "cBottomTrailing";
export const cBottom = "cBottom";
export const cBottomLeading = "cBottomLeading";
export type AlignmentType = 'cTopLeading' | 'cTop' | 'cTopTrailing' | 'cLeading' | 'cCenter' | 'cTrailing' | 'cBottomTrailing' | 'cBottom' | 'cBottomLeading';

export class TextFieldRenderer extends ControlHtmlRenderer<TextFieldClass> {
    get UseFrameStyles(): boolean;
    GenerateElement(obj: TextFieldClass): boolean;
    GenerateBody(obj: TextFieldClass): void;
}
export class TextFieldClass extends UIView {
    vp_FormField: {
        name: string;
        rules: ValidateRule[];
    };
    formField(name: string, rules: ValidateRule[]): this;
    vp_FormControl: Form_Control;
    formControl(value: Form_Control): this;
    Value: string;
    Placeholder: string;
    vp_Autofocus: boolean;
    LeftIcon: string;
    InputAppearance: AppearanceObject;
    OnTextChange: Function;
    vp_Multiline: boolean;
    vp_myLostFocus: Function;
    vp_Label: string;
    label(value: string): this;
    vp_LabelTemplate: (label: string) => UIView;
    labelTemplate(value: (label: string) => UIView): this;
    setController(controller: UIController): this;
    constructor();
    onTextChange(value: (text: string) => void): this;
    placeholder(value: string): this;
    value(value: string): this;
    autofocus(value: boolean): this;
    multiline(value: boolean): this;
    onLostFocus(func: Function): this;
}
export function TextField(): TextFieldClass;

export class SecureFieldRenderer extends ControlHtmlRenderer<SecureFieldClass> {
    GenerateElement(obj: SecureFieldClass): boolean;
    protected OnInputDidMount(obj: SecureFieldClass, ref: HTMLElement): void;
    protected OnShadowDomDidMount(ref: any, obj: SecureFieldClass): void;
    GenerateBody(obj: SecureFieldClass): void;
}
export class SecureFieldClass extends UIView {
    Value: string;
    Placeholder: string;
    Autofocus: boolean;
    LeftIcon: string;
    InputAppearance: AppearanceObject;
    OnTextChange: Function;
    setController(controller: UIController): this;
    constructor();
    OnAppearanceChanged(name: string): void;
    onTextChange(value: (text: string) => void): this;
    placeholder(value: string): this;
    value(value: string): this;
}
export function SecureField(): SecureFieldClass;

export class ToggleRenderer extends ControlHtmlRenderer<ToggleClass> {
    OnStyleCreating(obj: ToggleClass, sb: StringBuilder): void;
    GenerateElement(obj: ToggleClass): boolean;
    protected OnInputDidMount(obj: ToggleClass, ref: HTMLElement): void;
    protected OnShadowDomDidMount(ref: any, obj: ToggleClass): void;
    GenerateBody(obj: ToggleClass): void;
}
export class ToggleClass extends UIView {
    vp_checked: boolean;
    vp_onChange: Function;
    setController(controller: UIController): this;
    constructor();
    OnAppearanceChanged(name: string): void;
    onToggleChange(value: (value: boolean) => void): this;
    checked(value: boolean): this;
}
export function Toggle(): ToggleClass;

export class UIContextMenuRenderer extends ControlHtmlRenderer<UIContextMenuClass> {
    shadowDom: any;
    protected menu: any;
    OnStyleCreating(obj: UIContextMenuClass, sb: StringBuilder): void;
    GenerateElement(obj: UIContextMenuClass): boolean;
    protected OnShadowDomDidMount(ref: any, obj: UIContextMenuClass): void;
    GenerateBody(obj: UIContextMenuClass): void;
    protected CreateControls(obj: UIContextMenuClass): any[];
}
export class UIContextMenuClass extends UIView {
    items: UIView[];
    setController(controller: UIController): this;
    constructor();
    setItems(...items: UIView[]): this;
}
type FunctionUIContextMenu = (...content: UIView[]) => UIContextMenuClass;
export function UIContextMenu(...items: UIView[]): FunctionUIContextMenu;
export {};

export class UILinkCLass extends UIView {
    setController(controller: UIController): this;
    constructor();
}
export function UILink(text: string): UILinkCLass;

export function $<T>(value: T): BindingClass<T>;
export class UIRoutesCLass extends UIView {
    vp_Routes: UIRouteClass[];
    vp_Theme: any;
    setController(controller: UIController): this;
    constructor();
    setRoutes(...routes: UIRouteClass[]): this;
    setTheme(theme: any): this;
}
export function UIRoutes(...routes: UIRouteClass[]): UIRoutesCLass;
export type ControllerConstructor = new () => UIController;
export class UIRouteClass extends UIView {
    vp_routePath: string;
    vp_IsIndex: boolean;
    vp_routeController: ControllerConstructor;
    vp_ChildRoutes: UIRouteClass[];
    vp_RedirectTo: string;
    setController(controller: UIController): this;
    constructor();
    setRoutePath(path: string): this;
    setRouteController(controller: ControllerConstructor): this;
    setChildRoutes(...value: UIRouteClass[]): this;
    index(value: boolean): this;
    redirectTo(value: string): this;
}
type UIRouteFunction = (path: string, routeController: ControllerConstructor) => UIRouteClass;
export function UIRoute(path: string, routeController: ControllerConstructor): UIRouteClass;
export function UIRoute(...childRoutes: UIRouteClass[]): UIRouteFunction;
export class UIRouteLinkCLass extends UIView {
    vp_link: string;
    vp_State: any;
    setController(controller: UIController): this;
    constructor();
    link(path: string): this;
    state(value: any): this;
}
type FunctionUIRouteLink = (...views: UIView[]) => UIRouteLinkCLass;
export function UIRouteLink(path: string, state?: any): FunctionUIRouteLink;
export class UIRouteOutletClass extends UIView {
    setController(controller: UIController): this;
    constructor();
}
export function UIRouteOutlet(): UIRouteOutletClass;
export class UINavigateClass extends UIView {
    vp_To: string;
    setController(controller: UIController): this;
    constructor();
    to(value: string): this;
}
export function UINavigate(): UINavigateClass;
export function getRouterParams<ParamsOrKey extends string | Record<string, string | undefined> = string>(): Readonly<[
    ParamsOrKey
] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>>;
export function bindNavigate(): NavigateFunction;
export function binLocation(): import("../history").Location;
export {};

export function UIStep(): UIStepsClass;

export function UISkeleton(): UISkeletonClass;

export type DropDownItemFunction = (selectedItemTemplate: (option: any) => UIView | Function) => DropDownClass;
export function DropDown(itemTemplate: (option: any) => UIView | Function): DropDownItemFunction;

export function AutoComplete(): AutoCompleteClass;

export function OverlayPanel(headerTemplate: UIView): (...content: UIView[]) => OverlayPanelClass;

export function AvatarView(...content: UIView[]): AvatarViewClass;

export function SlideMenuView(...content: UIView[]): SlideMenuViewClass;

export class AppearanceClass {
    Appearance: AppearanceObject;
    HoverAppearance: AppearanceObject;
    FocusAppearance: AppearanceObject;
    ActiveAppearance: AppearanceObject;
    BeforeAppearance: AppearanceObject;
    KeyFrameCollection: KeyFrameCollection[];
    constructor();
    zIndex(value: int): this;
    variable(name: string, value: StyleAttribute): this;
    visible(value: boolean): this;
    position(value: PositionTypes): this;
    position(size: int): this;
    position(size: string): this;
    left(value: string): this;
    top(value: string): this;
    right(value: string): this;
    bottom(value: string): this;
    transform(value: string): this;
    rotate(value: string): this;
    clipPath(value: string): this;
    filter(value: string): this;
    font(font: IFont): this;
    textAlign(value: TextAligns): this;
    textTransform(value: TextTransforms): this;
    fontFamily(size: string): this;
    fontSmoothing(value: (view: UIView) => void): this;
    fontSize(value: (view: UIView) => void): this;
    fontSize(size: int): this;
    fontSize(size: string): this;
    fontWeight(weight: FontWeightModifierTypes): this;
    lineHeight(size: int): this;
    lineHeight(size: string): this;
    grow(): this;
    width(): this;
    width(value: int): this;
    width(value: string): this;
    minWidth(value: string): this;
    maxWidth(value: string): this;
    height(): this;
    height(value: int): this;
    height(value: string): this;
    minHeight(value: string): this;
    maxHeight(value: string): this;
    foregroundColor(value: ColorClass): this;
    foregroundColor(value: StyleAttribute): this;
    foregroundColor(color: string): this;
    foregroundColor(condition: boolean, trueValue: string, falseValue: string): this;
    backgroundImage(value: StyleAttribute): this;
    backgroundImage(value: string): this;
    backgroundColor(value: StyleAttribute): this;
    backgroundColor(value: string): this;
    background(value: ColorClass): this;
    background(value: StyleAttribute): this;
    background(color: string): this;
    background(condition: boolean, trueValue: string, falseValue: string): this;
    cursor(value: string): this;
    alignItems(value: string): this;
    alignContent(value: string): this;
    justifyContent(value: string): this;
    cornerRadius(): this;
    cornerRadius(value: CornerRadiusTypes): this;
    cornerRadius(value: string): this;
    cornerRadius(value: int): this;
    outline(value: StyleAttribute): this;
    outline(value: string): this;
    border(value: StyleAttribute): this;
    border(value: string): this;
    borderLeft(value: string): this;
    borderRight(value: string): this;
    borderTop(value: string): this;
    borderBottom(value: string): this;
    wrap(value: string): this;
    basis(value: string): this;
    margin(): this;
    margin(value: string): this;
    margin(value: int): this;
    marginVertical(): this;
    marginVertical(value: string): this;
    marginVertical(value: int): this;
    marginHorizontal(): this;
    marginHorizontal(value: string): this;
    marginHorizontal(value: int): this;
    marginLeft(value: string): this;
    marginRight(value: string): this;
    marginTop(value: string): this;
    marginBottom(value: string): this;
    padding(): this;
    padding(value: string): this;
    padding(type: string, value: string): this;
    padding(value: int): this;
    padding(type: string, value: int): this;
    paddingLeft(value: string): this;
    paddingRight(value: string): this;
    paddingTop(value: string): this;
    paddingBottom(value: string): this;
    overflow(value: string): this;
    overflowX(value: string): this;
    overflowY(value: string): this;
    shadow(value: StyleAttribute): this;
    shadow(value: ShadowTypes): this;
    shadow(value: string): this;
    transition(value: string): this;
    opacity(value: string): this;
    kerning(value: string): this;
}
export function UIAppearance(): AppearanceClass;

export class BindingClass<T> {
    constructor(controller: UIController, defaultValue: T);
    get(): T;
    set(value: T): void;
}

export function UIAccordion({ header, content }: {
    header: (item: any) => UIView | Function;
    content: (item: any) => UIView | Function;
}): AccordionClass;

export function UIMediaPlayer(): UIMediaPlayerClass;

export function UIChips(): UIChipClass;

export type SideBarPositions = 'left' | 'right' | 'top' | 'bottom';
type FunctionSideBar = (...content: UIView[]) => UISidebarClass;
export function UISidebar({ position }: {
    position: SideBarPositions;
}): FunctionSideBar;
export {};

export function UIDesktop(): UIDesktopClass;

export function UIRadioGroup(): RadioGroupClass;

export function DynamicView(node: any): DynamicViewClass;

export class UIFormClass extends UIView {
    setController(controller: UIController): this;
    constructor();
}
export function UIFormView(...content: UIView[]): UIFormClass;

export class CheckBoxRenderer extends ControlHtmlRenderer<CheckBoxClass> {
    GenerateElement(obj: CheckBoxClass): boolean;
    GenerateBody(obj: CheckBoxClass): void;
}
export class CheckBoxClass extends UIView {
    vp_Value: boolean;
    vp_onChange: Function;
    setController(controller: UIController): this;
    constructor();
    OnAppearanceChanged(name: string): void;
    onChange(value: (value: boolean) => void): this;
    value(value: boolean): this;
}
export function UICheckBox(): CheckBoxClass;

export const Theme: {
    primaryBackgroundHoverColor: string;
    primaryColor: string;
    fontFamily: string;
    applicationBackgroundColor: string;
    textColorOnPrimary: string;
    surfceColor: string;
    darkBackgroundColor: string;
    secondaryBackgroundColor: string;
};

export function getView(controller: UIController, view: any): UIView | UIController | Control;
export function viewFunc(sourceClass: any, viewCreator: Function): any;

export class ColorClass {
    color: string;
    constructor(color: string);
    opacity(value: float): this;
    lighten(volume?: float): this;
    darken(volume?: float): this;
    toString(): string;
}

/**
    * Converts a color from CSS hex format to CSS rgb format.
    * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
    * @returns {string} A CSS rgb color string
    */
export function hexToRgb(color: any): string;
/**
    * Returns an object with the type and values of a color.
    *
    * Note: Does not support rgb % values.
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @returns {object} - A MUI color object: {type: string, values: number[]}
    */
export function decomposeColor(color: any): any;
/**
    * Returns a channel created from the input color.
    *
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @returns {string} - The channel for the color, that can be used in rgba or hsla colors
    */
export const colorChannel: (color: any) => any;
/**
    * Converts a color object with type and values to a string.
    * @param {object} color - Decomposed color
    * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla', 'color'
    * @param {array} color.values - [n,n,n] or [n,n,n,n]
    * @returns {string} A CSS color string
    */
export function recomposeColor(color: any): string;
/**
    * Converts a color from CSS rgb format to CSS hex format.
    * @param {string} color - RGB color, i.e. rgb(n, n, n)
    * @returns {string} A CSS rgb color string, i.e. #nnnnnn
    */
export function rgbToHex(color: any): any;
/**
    * Converts a color from hsl format to rgb format.
    * @param {string} color - HSL color values
    * @returns {string} rgb color values
    */
export function hslToRgb(color: any): string;
/**
    * The relative brightness of any point in a color space,
    * normalized to 0 for darkest black and 1 for lightest white.
    *
    * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @returns {number} The relative brightness of the color in the range 0 - 1
    */
export function getLuminance(color: any): number;
/**
    * Calculates the contrast ratio between two colors.
    *
    * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
    * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
    * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
    * @returns {number} A contrast ratio value in the range 0 - 21.
    */
export function getContrastRatio(foreground: any, background: any): number;
/**
    * Sets the absolute transparency of a color.
    * Any existing alpha values are overwritten.
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @param {number} value - value to set the alpha channel to in the range 0 - 1
    * @returns {string} A CSS color string. Hex input values are returned as rgb
    */
export function alpha(color: any, value: any): string;
/**
    * Darkens a color.
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @param {number} coefficient - multiplier in the range 0 - 1
    * @returns {string} A CSS color string. Hex input values are returned as rgb
    */
export function darken(color: any, coefficient: any): string;
/**
    * Lightens a color.
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @param {number} coefficient - multiplier in the range 0 - 1
    * @returns {string} A CSS color string. Hex input values are returned as rgb
    */
export function lighten(color: any, coefficient: any): string;
/**
    * Darken or lighten a color, depending on its luminance.
    * Light colors are darkened, dark colors are lightened.
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @param {number} coefficient=0.15 - multiplier in the range 0 - 1
    * @returns {string} A CSS color string. Hex input values are returned as rgb
    */
export function emphasize(color: any, coefficient?: number): string;

export function createTheme(options?: any, ...args: any[]): {
    breakpoints: any;
    direction: string;
    components: {};
    palette: any;
    spacing: import("./system/createTheme/createSpacing").Spacing;
    shape: any;
};
export function createMuiTheme(...args: any[]): {
    breakpoints: any;
    direction: string;
    components: {};
    palette: any;
    spacing: import("./system/createTheme/createSpacing").Spacing;
    shape: any;
};

export const light: {
    text: {
        primary: string;
        secondary: string;
        disabled: string;
    };
    divider: string;
    background: {
        paper: string;
        default: string;
    };
    action: {
        active: string;
        hover: string;
        hoverOpacity: number;
        selected: string;
        selectedOpacity: number;
        disabled: string;
        disabledBackground: string;
        disabledOpacity: number;
        focus: string;
        focusOpacity: number;
        activatedOpacity: number;
    };
};
export const dark: {
    text: {
        primary: string;
        secondary: string;
        disabled: string;
        icon: string;
    };
    divider: string;
    background: {
        paper: string;
        default: string;
    };
    action: {
        active: string;
        hover: string;
        hoverOpacity: number;
        selected: string;
        selectedOpacity: number;
        disabled: string;
        disabledBackground: string;
        disabledOpacity: number;
        focus: string;
        focusOpacity: number;
        activatedOpacity: number;
    };
};
export function createPalette(palette: any): any;

/**
  * Component based on `useController` hook to work with controlled component.
  *
  * @remarks
  * [API](https://react-hook-form.com/api/usecontroller/controller)  [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw)  [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)
  *
  * @param props - the path name to the form field value, and validation rules.
  *
  * @returns provide field handler functions, field and form state.
  *
  * @example
  * ```tsx
  * function App() {
  *   const { control } = useForm<FormValues>({
  *     defaultValues: {
  *       test: ""
  *     }
  *   });
  *
  *   return (
  *     <form>
  *       <Controller
  *         control={control}
  *         name="test"
  *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (
  *           <>
  *             <input
  *               onChange={onChange} // send value to hook form
  *               onBlur={onBlur} // notify when input is touched
  *               value={value} // return updated value
  *               ref={ref} // set ref for focus management
  *             />
  *             <p>{formState.isSubmitted ? "submitted" : ""}</p>
  *             <p>{fieldState.isTouched ? "touched" : ""}</p>
  *           </>
  *         )}
  *       />
  *     </form>
  *   );
  * }
  * ```
  */
const Form_Controller: <TFieldValues extends FieldValues = FieldValues, TName extends import("./types").Path<TFieldValues> = import("./types").Path<TFieldValues>>(props: ControllerProps<TFieldValues, TName>) => any;
export { Form_Controller };

export { appendErrors };

/**
  * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.
  *
  * @remarks
  * [API](https://react-hook-form.com/api/usecontroller)  [Demo](https://codesandbox.io/s/usecontroller-0o8px)
  *
  * @param props - the path name to the form field value, and validation rules.
  *
  * @returns field properties, field and form state. {@link UseControllerReturn}
  *
  * @example
  * ```tsx
  * function Input(props) {
  *   const { field, fieldState, formState } = useController(props);
  *   return (
  *     <div>
  *       <input {...field} placeholder={props.name} />
  *       <p>{fieldState.isTouched && "Touched"}</p>
  *       <p>{formState.isSubmitted ? "submitted" : ""}</p>
  *     </div>
  *   );
  * }
  * ```
  */
export function useController<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(props: UseControllerProps<TFieldValues, TName>): UseControllerReturn<TFieldValues, TName>;

/**
  * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc.  [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)  [Video](https://youtu.be/4MrbfGSFY2A)
  *
  * @remarks
  * [API](https://react-hook-form.com/api/usefieldarray)  [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)
  *
  * @param props - useFieldArray props
  *
  * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}
  *
  * @example
  * ```tsx
  * function App() {
  *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({
  *     defaultValues: {
  *       test: []
  *     }
  *   });
  *   const { fields, append } = useFieldArray({
  *     control,
  *     name: "test"
  *   });
  *
  *   return (
  *     <form onSubmit={handleSubmit(data => console.log(data))}>
  *       {fields.map((item, index) => (
  *          <input key={item.id} {...register(`test.${index}.firstName`)}  />
  *       ))}
  *       <button type="button" onClick={() => append({ firstName: "bill" })}>
  *         append
  *       </button>
  *       <input type="submit" />
  *     </form>
  *   );
  * }
  * ```
  */
export function useFieldArray<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>, TKeyName extends string = 'id'>(props: UseFieldArrayProps<TFieldValues, TFieldArrayName, TKeyName>): UseFieldArrayReturn<TFieldValues, TFieldArrayName, TKeyName>;

/**
  * Custom hook to manage the entire form.
  *
  * @remarks
  * [API](https://react-hook-form.com/api/useform)  [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm)  [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)
  *
  * @param props - form configuration and validation parameters.
  *
  * @returns methods - individual functions to manage the form state. {@link UseFormReturn}
  *
  * @example
  * ```tsx
  * function App() {
  *   const { register, handleSubmit, watch, formState: { errors } } = useForm();
  *   const onSubmit = data => console.log(data);
  *
  *   console.log(watch("example"));
  *
  *   return (
  *     <form onSubmit={handleSubmit(onSubmit)}>
  *       <input defaultValue="test" {...register("example")} />
  *       <input {...register("exampleRequired", { required: true })} />
  *       {errors.exampleRequired && <span>This field is required</span>}
  *       <input type="submit" />
  *     </form>
  *   );
  * }
  * ```
  */
export function useForm<TFieldValues extends FieldValues = FieldValues, TContext = any>(props?: UseFormProps<TFieldValues, TContext>): UseFormReturn<TFieldValues, TContext>;

/**
    * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/useformcontext)  [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
    *
    * @returns return all useForm methods
    *
    * @example
    * ```tsx
    * function App() {
    *   const methods = useForm();
    *   const onSubmit = data => console.log(data);
    *
    *   return (
    *     <FormProvider {...methods} >
    *       <form onSubmit={methods.handleSubmit(onSubmit)}>
    *         <NestedInput />
    *         <input type="submit" />
    *       </form>
    *     </FormProvider>
    *   );
    * }
    *
    *  function NestedInput() {
    *   const { register } = useFormContext(); // retrieve all hook methods
    *   return <input {...register("test")} />;
    * }
    * ```
    */
export const useFormContext: <TFieldValues extends FieldValues>() => UseFormReturn<TFieldValues, any>;
/**
    * A provider component that propagates the `useForm` methods to all children components via [React Context](https://reactjs.org/docs/context.html) API. To be used with {@link useFormContext}.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/useformcontext)  [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
    *
    * @param props - all useFrom methods
    *
    * @example
    * ```tsx
    * function App() {
    *   const methods = useForm();
    *   const onSubmit = data => console.log(data);
    *
    *   return (
    *     <FormProvider {...methods} >
    *       <form onSubmit={methods.handleSubmit(onSubmit)}>
    *         <NestedInput />
    *         <input type="submit" />
    *       </form>
    *     </FormProvider>
    *   );
    * }
    *
    *  function NestedInput() {
    *   const { register } = useFormContext(); // retrieve all hook methods
    *   return <input {...register("test")} />;
    * }
    * ```
    */
export const FormProvider: any;

/**
  * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.
  *
  * @remarks
  * [API](https://react-hook-form.com/api/useformstate)  [Demo](https://codesandbox.io/s/useformstate-75xly)
  *
  * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}
  *
  * @example
  * ```tsx
  * function App() {
  *   const { register, handleSubmit, control } = useForm({
  *     defaultValues: {
  *     firstName: "firstName"
  *   }});
  *   const { dirtyFields } = useFormState({
  *     control
  *   });
  *   const onSubmit = (data) => console.log(data);
  *
  *   return (
  *     <form onSubmit={handleSubmit(onSubmit)}>
  *       <input {...register("firstName")} placeholder="First Name" />
  *       {dirtyFields.firstName && <p>Field is dirty.</p>}
  *       <input type="submit" />
  *     </form>
  *   );
  * }
  * ```
  */
function useFormState<TFieldValues extends FieldValues = FieldValues>(props?: UseFormStateProps<TFieldValues>): UseFormStateReturn<TFieldValues>;
export { useFormState };

/**
    * Subscribe to the entire form values change and re-render at the hook level.
    *
    * @remarks
    *
    * [API](https://react-hook-form.com/api/usewatch)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
    *
    * @param props - defaultValue, disable subscription and match exact name.
    *
    * @example
    * ```tsx
    * const { watch } = useForm();
    * const values = useWatch({
    *   control,
    *   defaultValue: {
    *     name: "data"
    *   },
    *   exact: false,
    * })
    * ```
    */
export function useWatch<TFieldValues extends FieldValues = FieldValues>(props: {
        defaultValue?: DeepPartialSkipArrayKey<TFieldValues>;
        control?: Form_Control<TFieldValues>;
        disabled?: boolean;
        exact?: boolean;
}): DeepPartialSkipArrayKey<TFieldValues>;
/**
    * Custom hook to subscribe to field change and isolate re-rendering at the component level.
    *
    * @remarks
    *
    * [API](https://react-hook-form.com/api/usewatch)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
    *
    * @param props - defaultValue, disable subscription and match exact name.
    *
    * @example
    * ```tsx
    * const { watch } = useForm();
    * const values = useWatch({
    *   control,
    *   name: "fieldA",
    *   defaultValue: "default value",
    *   exact: false,
    * })
    * ```
    */
export function useWatch<TFieldValues extends FieldValues = FieldValues, TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(props: {
        name: TFieldName;
        defaultValue?: FieldPathValue<TFieldValues, TFieldName>;
        control?: Form_Control<TFieldValues>;
        disabled?: boolean;
        exact?: boolean;
}): FieldPathValue<TFieldValues, TFieldName>;
/**
    * Custom hook to subscribe to field change and isolate re-rendering at the component level.
    *
    * @remarks
    *
    * [API](https://react-hook-form.com/api/usewatch)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
    *
    * @param props - defaultValue, disable subscription and match exact name.
    *
    * @example
    * ```tsx
    * const { watch } = useForm();
    * const values = useWatch({
    *   control,
    *   name: ["fieldA", "fieldB"],
    *   defaultValue: {
    *     fieldA: "data",
    *     fieldB: "data"
    *   },
    *   exact: false,
    * })
    * ```
    */
export function useWatch<TFieldValues extends FieldValues = FieldValues, TFieldNames extends readonly FieldPath<TFieldValues>[] = readonly FieldPath<TFieldValues>[]>(props: {
        name: readonly [...TFieldNames];
        defaultValue?: DeepPartialSkipArrayKey<TFieldValues>;
        control?: Form_Control<TFieldValues>;
        disabled?: boolean;
        exact?: boolean;
}): FieldPathValues<TFieldValues, TFieldNames>;
/**
    * Custom hook to subscribe to field change and isolate re-rendering at the component level.
    *
    * @remarks
    *
    * [API](https://react-hook-form.com/api/usewatch)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
    *
    * @example
    * ```tsx
    * // can skip passing down the control into useWatch if the form is wrapped with the FormProvider
    * const values = useWatch()
    * ```
    */
export function useWatch<TFieldValues extends FieldValues = FieldValues>(): DeepPartialSkipArrayKey<TFieldValues>;

export { get, set };

import './setBatchUpdatesFn';
import './setLogger';

/**
    * Actions represent the type of change to a location value.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action
    */
export enum Action {
        /**
            * A POP indicates a change to an arbitrary index in the history stack, such
            * as a back or forward navigation. It does not describe the direction of the
            * navigation, only that the current index changed.
            *
            * Note: This is the default action for newly created history objects.
            */
        Pop = "POP",
        /**
            * A PUSH indicates a new entry being added to the history stack, such as when
            * a link is clicked and a new page loads. When this happens, all subsequent
            * entries in the stack are lost.
            */
        Push = "PUSH",
        /**
            * A REPLACE indicates the entry at the current index in the history stack
            * being replaced by a new one.
            */
        Replace = "REPLACE"
}
/**
    * A URL pathname, beginning with a /.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.pathname
    */
export type Pathname = string;
/**
    * A URL search string, beginning with a ?.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.search
    */
export type Search = string;
/**
    * A URL fragment identifier, beginning with a #.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.hash
    */
export type Hash = string;
/**
    * An object that is used to associate some arbitrary data with a location, but
    * that does not appear in the URL path.
    *
    * @deprecated
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.state
    */
export type State = unknown;
/**
    * A unique string associated with a location. May be used to safely store
    * and retrieve data in some other storage API, like `localStorage`.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.key
    */
export type Key = string;
/**
    * The pathname, search, and hash values of a URL.
    */
export interface Path {
        /**
            * A URL pathname, beginning with a /.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.pathname
            */
        pathname: Pathname;
        /**
            * A URL search string, beginning with a ?.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.search
            */
        search: Search;
        /**
            * A URL fragment identifier, beginning with a #.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.hash
            */
        hash: Hash;
}
/**
    * An entry in a history stack. A location contains information about the
    * URL path, as well as possibly some arbitrary state and a key.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location
    */
export interface Location extends Path {
        /**
            * A value of arbitrary data associated with this location.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.state
            */
        state: unknown;
        /**
            * A unique string associated with this location. May be used to safely store
            * and retrieve data in some other storage API, like `localStorage`.
            *
            * Note: This value is always "default" on the initial location.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.key
            */
        key: Key;
}
/**
    * A partial Path object that may be missing some properties.
    *
    * @deprecated
    */
export type PartialPath = Partial<Path>;
/**
    * A partial Location object that may be missing some properties.
    *
    * @deprecated
    */
export type PartialLocation = Partial<Location>;
/**
    * A change to the current location.
    */
export interface Update {
        /**
            * The action that triggered the change.
            */
        action: Action;
        /**
            * The new location.
            */
        location: Location;
}
/**
    * A function that receives notifications about location changes.
    */
export interface Listener {
        (update: Update): void;
}
/**
    * A change to the current location that was blocked. May be retried
    * after obtaining user confirmation.
    */
export interface Transition extends Update {
        /**
            * Retries the update to the current location.
            */
        retry(): void;
}
/**
    * A function that receives transitions when navigation is blocked.
    */
export interface Blocker {
        (tx: Transition): void;
}
/**
    * Describes a location that is the destination of some navigation, either via
    * `history.push` or `history.replace`. May be either a URL or the pieces of a
    * URL path.
    */
export type To = string | Partial<Path>;
/**
    * A history is an interface to the navigation stack. The history serves as the
    * source of truth for the current location, as well as provides a set of
    * methods that may be used to change it.
    *
    * It is similar to the DOM's `window.history` object, but with a smaller, more
    * focused API.
    */
export interface History {
        /**
            * The last action that modified the current location. This will always be
            * Action.Pop when a history instance is first created. This value is mutable.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.action
            */
        readonly action: Action;
        /**
            * The current location. This value is mutable.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.location
            */
        readonly location: Location;
        /**
            * Returns a valid href for the given `to` value that may be used as
            * the value of an <a href> attribute.
            *
            * @param to - The destination URL
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.createHref
            */
        createHref(to: To): string;
        /**
            * Pushes a new location onto the history stack, increasing its length by one.
            * If there were any entries in the stack after the current one, they are
            * lost.
            *
            * @param to - The new URL
            * @param state - Data to associate with the new location
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.push
            */
        push(to: To, state?: any): void;
        /**
            * Replaces the current location in the history stack with a new one.  The
            * location that was replaced will no longer be available.
            *
            * @param to - The new URL
            * @param state - Data to associate with the new location
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.replace
            */
        replace(to: To, state?: any): void;
        /**
            * Navigates `n` entries backward/forward in the history stack relative to the
            * current index. For example, a "back" navigation would use go(-1).
            *
            * @param delta - The delta in the stack index
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.go
            */
        go(delta: number): void;
        /**
            * Navigates to the previous entry in the stack. Identical to go(-1).
            *
            * Warning: if the current location is the first location in the stack, this
            * will unload the current document.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.back
            */
        back(): void;
        /**
            * Navigates to the next entry in the stack. Identical to go(1).
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.forward
            */
        forward(): void;
        /**
            * Sets up a listener that will be called whenever the current location
            * changes.
            *
            * @param listener - A function that will be called when the location changes
            * @returns unlisten - A function that may be used to stop listening
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.listen
            */
        listen(listener: Listener): () => void;
        /**
            * Prevents the current location from changing and sets up a listener that
            * will be called instead.
            *
            * @param blocker - A function that will be called when a transition is blocked
            * @returns unblock - A function that may be used to stop blocking
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.block
            */
        block(blocker: Blocker): () => void;
}
/**
    * A browser history stores the current location in regular URLs in a web
    * browser environment. This is the standard for most web apps and provides the
    * cleanest URLs the browser's address bar.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory
    */
export interface BrowserHistory extends History {
}
/**
    * A hash history stores the current location in the fragment identifier portion
    * of the URL in a web browser environment.
    *
    * This is ideal for apps that do not control the server for some reason
    * (because the fragment identifier is never sent to the server), including some
    * shared hosting environments that do not provide fine-grained controls over
    * which pages are served at which URLs.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory
    */
export interface HashHistory extends History {
}
/**
    * A memory history stores locations in memory. This is useful in stateful
    * environments where there is no web browser, such as node tests or React
    * Native.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#memoryhistory
    */
export interface MemoryHistory extends History {
        readonly index: number;
}
export type BrowserHistoryOptions = {
        window?: Window;
};
/**
    * Browser history stores the location in regular URLs. This is the standard for
    * most web apps, but it requires some configuration on the server to ensure you
    * serve the same app at multiple URLs.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
    */
export function createBrowserHistory(options?: BrowserHistoryOptions): BrowserHistory;
export type HashHistoryOptions = {
        window?: Window;
};
/**
    * Hash history stores the location in window.location.hash. This makes it ideal
    * for situations where you don't want to send the location to the server for
    * some reason, either because you do cannot configure it or the URL space is
    * reserved for something else.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
    */
export function createHashHistory(options?: HashHistoryOptions): HashHistory;
/**
    * A user-supplied object that describes a location. Used when providing
    * entries to `createMemoryHistory` via its `initialEntries` option.
    */
export type InitialEntry = string | Partial<Location>;
export type MemoryHistoryOptions = {
        initialEntries?: InitialEntry[];
        initialIndex?: number;
};
/**
    * Memory history stores the current location in memory. It is designed for use
    * in stateful non-browser environments like tests and React Native.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory
    */
export function createMemoryHistory(options?: MemoryHistoryOptions): MemoryHistory;
/**
    * Creates a string URL path from the given pathname, search, and hash components.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath
    */
export function createPath({ pathname, search, hash, }: Partial<Path>): string;
/**
    * Parses a string URL path into its separate pathname, search, and hash components.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath
    */
export function parsePath(path: string): Partial<Path>;

export type { Hash, IndexRouteProps, LayoutRouteProps, Location, MemoryRouterProps, NavigateFunction, NavigateOptions, NavigateProps, OutletProps, PathMatch, PathPattern, PathRouteProps, RouteMatch, RouteObject, RouteProps, RouterProps, RoutesProps, Navigator, Params, Path, Pathname, Search, To, };
export { MemoryRouter, Navigate, NavigationType, Outlet, Route, Router, Routes, createPath, createRoutesFromChildren, generatePath, matchPath, matchRoutes, parsePath, renderMatches, resolvePath, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRoutes, };

/**
  * Component class with a predefined `shouldComponentUpdate` implementation
  */
export class PureComponent extends Component {
    props: any;
    isPureReactComponent: boolean;
    constructor(p: any);
    shouldComponentUpdate(props: any, state: any): boolean;
}

export const REACT_MEMO_SYMBOL: number | symbol;
/**
  * Memoize a component, so that it only updates when the props actually have
  * changed. This was previously known as `React.pure`.
  * @param {import('./internal').FunctionComponent} c functional component
  * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function
  * @returns {import('./internal').FunctionComponent}
  */
export function memo(c: any, comparer?: any): {
    (props: any): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
    };
    $$typeof: number | symbol;
    displayName: string;
    _forwarded: boolean;
};

export const REACT_FORWARD_SYMBOL: number | symbol;
/**
  * Pass ref down to a child. This is mainly used in libraries with HOCs that
  * wrap components. Using `forwardRef` there is an easy way to get a reference
  * of the wrapped component instead of one of the wrapper itself.
  * @param {import('./index').ForwardFn} fn
  * @returns {import('./internal').FunctionComponent}
  */
export function forwardRef(fn: any): {
    (props: any, ref: any): any;
    $$typeof: number | symbol;
    render: any;
    _forwarded: boolean;
    displayName: string;
};

export const Children: {
    map: (children: any, fn: any) => any;
    forEach: (children: any, fn: any) => any;
    count(children: any): any;
    only(children: any): any;
    toArray: typeof toChildArray;
};

/**
    * Portal component
    * @this {import('./internal').Component}
    * @param {object | null | undefined} props
    *
    * TODO: use createRoot() instead of fake root
    */
export function Portal(props: any): void;
/**
    * Create a `Portal` to continue rendering the vnode tree at a different DOM node
    * @param {import('./internal').VNode} vnode The vnode to render
    * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.
    */
export function createPortal(vnode: any, container: any): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
};

export const REACT_ELEMENT_TYPE: number | symbol;
/**
  * Proxy render() since React returns a Component reference.
  * @param {import('./internal').VNode} vnode VNode tree to render
  * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into
  * @param {() => void} [callback] Optional callback that will be called after rendering
  * @returns {import('./internal').Component | null} The root component reference or null
  */
export function render(vnode: any, parent?: any, callback?: any): any;
export function hydrate(vnode: any, parent: any, callback: any): any;
export const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentDispatcher: {
        current: {
            readContext(context: any): any;
        };
    };
};

export function Suspense(): void;
export namespace Suspense {
    var prototype: Component;
}
/**
  * Checks and calls the parent component's _suspended method, passing in the
  * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified
  * that one of its children/descendants suspended.
  *
  * The parent MAY return a callback. The callback will get called when the
  * suspension resolves, notifying the parent of the fact.
  * Moreover, the callback gets function `unsuspend` as a parameter. The resolved
  * child descendant will not actually get unsuspended until `unsuspend` gets called.
  * This is a way for the parent to delay unsuspending.
  *
  * If the parent does not return a callback then the resolved vnode
  * gets unsuspended immediately when it resolves.
  *
  * @param {import('./internal').VNode} vnode
  * @returns {((unsuspend: () => void) => void)?}
  */
export function suspended(vnode: any): any;
export function lazy(loader: any): {
    (props: any): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
    };
    displayName: string;
    _forwarded: boolean;
};

export interface IAppStoreService {
    GetApps(env: string): Promise<IAppStoreItem[]>;
    GetApps(env: string, category: string): Promise<IAppStoreItem[]>;
}

export class BrokerAppStoreService implements IAppStoreService {
    GetApps(env: string): Promise<IAppStoreItem[]>;
}

export interface IAppStoreItem {
    id: string;
    name: string;
    service: boolean;
    application: boolean;
    category: string;
    icon: string;
}

export class LocalAppStoreService implements IAppStoreService {
    GetApps(env: string): Promise<IAppStoreItem[]>;
    GetApps(env: string, category: string): Promise<IAppStoreItem[]>;
}

export interface IDesktopService {
    GetUserApps(env: string, user: string): Promise<any>;
    LoadApp(appName: string): Promise<any>;
    InstallApp(env: string, user: string, app: IAppStoreItem): Promise<any>;
}

export class LocalDesktopService implements IDesktopService {
    LoadApp(appName: string): Promise<any>;
    GetUserApps(env: string, user: string): Promise<any>;
    InstallApp(env: string, user: string, app: IAppStoreItem): Promise<any>;
}

export class Message {
    get LParam(): any;
    set LParam(value: any);
    get Msg(): int;
    set Msg(value: int);
    get Result(): any;
    set Result(value: any);
    get WParam(): any;
    set WParam(value: any);
    static Create(msg: int, wparam: any, lparam: any): Message;
    static isEqual(a: Message, b: Message): boolean;
    static isNotEqual(a: Message, b: Message): boolean;
    equals(o: Message): boolean;
    getHashCode(): int;
    getLParam(cls: Type): any;
    toString(): string;
}

export class MouseEventArgs extends EventArgs {
    constructor(button: MouseButtons, clicks: number, x: float, y: float, delta: float, htmlEventObject?: MouseEvent);
    get Button(): MouseButtons;
    get Clicks(): number;
    get X(): float;
    get Y(): float;
    get Delta(): number;
    get Location(): {
        x: number;
        y: number;
    };
    get HtmlEventObject(): MouseEvent;
}

export function Skin(styleName: string): (target: any, key: string) => void;
export enum BorderAppearanceStyle {
        None = "none",
        Hidden = "hidden",
        Dotted = "dotted",
        Dashed = "dashed",
        Solid = "solid",
        Double = "double",
        Groove = "groove",
        Ridge = "ridge",
        Inset = "inset",
        Outset = "outset",
        Initial = "initial",
        Inherit = "inherit"
}
export class AppearanceObject {
        IsEmpty: boolean;
        StylePropertyBag: {};
        /**
            * Specifies the alignment of flexible container's items within the flex container.
            */
        AlignContent: string;
        /**
            * Specifies the default alignment for items within the flex container.
            */
        AlignItems: string;
        /**
            * Specifies the alignment for selected items within the flex container.
            */
        AlignSelf: string;
        /**
            * Specifies the keyframe-based animations.
            */
        Animation: string;
        /**
            * Specifies when the animation will start.
            */
        AnimationDelay: string;
        /**
            * Specifies whether the animation should play in reverse on alternate cycles or not.
            */
        AnimationDirection: string;
        /**
            * Specifies the number of seconds or milliseconds an animation should take to complete one cycle.
            */
        AnimationDuration: string;
        /**
            * Specifies how a CSS animation should apply styles to its target before and after it is executing.
            */
        AnimationFillMode: string;
        /**
            * Specifies the number of times an animation cycle should be played before stopping.
            */
        AnimationIterationCount: string;
        /**
            * Specifies the name of @keyframes defined animations that should be applied to the selected element.
            */
        AnimationName: string;
        /**
            * Specifies whether the animation is running or paused.
            */
        AnimationPlayState: string;
        /**
            * Specifies how a CSS animation should progress over the duration of each cycle.
            */
        AnimationTimingFunction: string;
        /**
            * Specifies whether or not the "back" side of a transformed element is visible when facing the user.
            */
        BackfaceVisibility: string;
        /**
            * Defines a variety of background properties within one declaration.
            */
        Background: string;
        /**
            * Specify whether the background image is fixed in the viewport or scrolls.
            */
        BackgroundAttachment: string;
        /**
            * Specifies the painting area of the background.
            */
        BackgroundClip: string;
        /**
            * Defines an element's background color.
            */
        BackgroundColor: string;
        /**
            * Defines an element's background image.
            */
        BackgroundImage: string;
        /**
            * Specifies the positioning area of the background images.
            */
        BackgroundOrigin: string;
        /**
            * Defines the origin of a background image.
            */
        BackgroundPosition: string;
        /**
            * Specify whether/how the background image is tiled.
            */
        BackgroundRepeat: string;
        /**
            * Specifies the size of the background images.
            */
        BackgroundSize: string;
        /**
            * Sets the width, style, and color for all four sides of an element's border.
            */
        Border: string;
        /**
            * Sets the width, style, and color of the bottom border of an element.
            */
        BorderBottom: string;
        /**
            * Sets the color of the bottom border of an element.
            */
        BorderBottomColor: string;
        /**
            * Defines the shape of the bottom-left border corner of an element.
            */
        BorderBottomLeftRadius: string;
        /**
            * Defines the shape of the bottom-right border corner of an element.
            */
        BorderBottomRightRadius: string;
        /**
            * Sets the style of the bottom border of an element.
            */
        BorderBottomStyle: string;
        /**
            * Sets the width of the bottom border of an element.
            */
        BorderBottomWidth: string;
        /**
            * Specifies whether table cell borders are connected or separated.
            */
        BorderCollapse: string;
        /**
            * Sets the color of the border on all the four sides of an element.
            */
        BorderColor: string;
        /**
            * Specifies how an image is to be used in place of the border styles.
            */
        BorderImage: string;
        /**
            * Specifies the amount by which the border image area extends beyond the border box.
            */
        BorderImageOutset: string;
        /**
            * Specifies whether the image-border should be repeated, rounded or stretched.
            */
        BorderImageRepeat: string;
        /**
            * Specifies the inward offsets of the image-border.
            */
        BorderImageSlice: string;
        /**
            * Specifies the location of the image to be used as a border.
            */
        BorderImageSource: string;
        /**
            * 	Specifies the width of the image-border.
            */
        BorderImageWidth: string;
        /**
            * Sets the width, style, and color of the left border of an element.
            */
        BorderLeft: string;
        /**
            * Sets the color of the left border of an element.
            */
        BorderLeftColor: string;
        /**
            * Sets the style of the left border of an element.
            */
        BorderLeftStyle: string;
        /**
            * Sets the width of the left border of an element.
            */
        BorderLeftWidth: string;
        /**
            * Defines the shape of the border corners of an element.
            */
        BorderRadius: string;
        /**
            * Sets the width, style, and color of the right border of an element.
            */
        BorderRight: string;
        /**
            * Sets the color of the right border of an element.
            */
        BorderRightColor: string;
        /**
            * Sets the style of the right border of an element.
            */
        BorderRightStyle: string;
        /**
            * Sets the width of the right border of an element.
            */
        BorderRightWidth: string;
        /**
            * Sets the spacing between the borders of adjacent table cells.
            */
        BorderSpacing: string;
        /**
            * Sets the style of the border on all the four sides of an element.
            */
        BorderStyle: string;
        /**
            * Sets the width, style, and color of the top border of an element.
            */
        BorderTop: string;
        /**
            * Sets the color of the top border of an element.
            */
        BorderTopColor: string;
        /**
            * Defines the shape of the top-left border corner of an element.
            */
        BorderTopLeftRadius: string;
        /**
            * Defines the shape of the top-right border corner of an element.
            */
        BorderTopRightRadius: string;
        /**
            * Sets the style of the top border of an element.
            */
        BorderTopStyle: string;
        /**
            * Sets the width of the top border of an element.
            */
        BorderTopWidth: string;
        /**
            * Sets the width of the border on all the four sides of an element.
            */
        BorderWidth: string;
        /**
            * Specify the location of the bottom edge of the positioned element.
            */
        Bottom: string;
        /**
            * Applies one or more drop-shadows to the element's box.
            */
        BoxShadow: string;
        /**
            * Alter the default CSS box model.
            */
        BoxSizing: string;
        /**
            * Specify the position of table's caption.
            */
        CaptionSide: string;
        /**
            * Specifies the placement of an element in relation to floating elements.
            */
        Clear: string;
        /**
            * Defines the clipping region.
            */
        Clip: string;
        /**
            * Defines the clipping region.
            */
        ClipPath: string;
        /**
        * Defines the filter.
        */
        Filter: string;
        /**
            * Specify the color of the text of an element.
            */
        Color: string;
        /**
            * Specifies the number of columns in a multi-column element.
            */
        ColumnCount: string;
        /**
            * Specifies how columns will be filled.
            */
        ColumnFill: string;
        /**
            * Specifies the gap between the columns in a multi-column element.
            */
        ColumnGap: string;
        /**
            * Specifies a straight line, or "rule", to be drawn between each column in a multi-column element.
            */
        ColumnRule: string;
        /**
            * Specifies the color of the rules drawn between columns in a multi-column layout.
            */
        ColumnRuleColor: string;
        /**
            * Specifies the style of the rule drawn between the columns in a multi-column layout.
            */
        ColumnRuleStyle: string;
        /**
            * Specifies the width of the rule drawn between the columns in a multi-column layout.
            */
        ColumnRuleWidth: string;
        /**
            * Specifies how many columns an element spans across in a multi-column layout.
            */
        ColumnSpan: string;
        /**
            * Specifies the optimal width of the columns in a multi-column element.
            */
        ColumnWidth: string;
        /**
            * A shorthand property for setting column-width and column-count properties.
            */
        Columns: string;
        /**
            * Inserts generated content.
            */
        Content: string;
        /**
            * Increments one or more counter values.
            */
        CounterIncrement: string;
        /**
            * Creates or resets one or more counters.
            */
        CounterReset: string;
        /**
            * Specify the type of cursor.
            */
        Cursor: string;
        /**
            * Define the text direction/writing direction.
            */
        Direction: string;
        /**
            * Specifies how an element is displayed onscreen.
            */
        Display: string;
        /**
            * Show or hide borders and backgrounds of empty table cells.
            */
        EmptyCells: string;
        /**
            * Specifies the components of a flexible length.
            */
        flex: string;
        /**
            * Specifies the initial main size of the flex item.
            */
        FlexBasis: string;
        /**
            * Specifies the direction of the flexible items.
            */
        FlexDirection: string;
        /**
            * A shorthand property for the flex-direction and the flex-wrap properties.
            */
        FlexFlow: string;
        /**
            * Specifies how the flex item will grow relative to the other items inside the flex container.
            */
        FlexGrow: string;
        /**
            * Specifies how the flex item will shrink relative to the other items inside the flex container.
            */
        FlexShrink: string;
        /**
            * Specifies whether the flexible items should wrap or not.
            */
        FlexWrap: string;
        /**
            * Specifies whether or not a box should float.
            */
        Float: string;
        /**
            * Defines a variety of font properties within one declaration.
            */
        Font: string;
        /**
            * Defines a list of fonts for element.
            */
        FontFamily: string;
        /**
            * Defines the font size for the text.
            */
        FontSize: string;
        /**
            * Preserves the readability of text when font fallback occurs.
            */
        FontSizeAdjust: string;
        /**
            * Selects a normal, condensed, or expanded face from a font.
            */
        FontStretch: string;
        /**
            * Defines the font style for the text.
            */
        FontStyle: string;
        /**
            * Specify the font variant.
            */
        FontVariant: string;
        /**
            * Specify the font weight of the text.
            */
        FontWeight: string;
        /**
            * Specify the height of an element.
            */
        Height: string;
        /**
            * Specifies how flex items are aligned along the main axis of the flex container after any flexible lengths and auto margins have been resolved.
            */
        JustifyContent: string;
        /**
    * Specifies how flex items are aligned along the main axis of the flex container after any flexible lengths and auto margins have been resolved.
    */
        JustifyItems: string;
        /**
            * Specify the location of the left edge of the positioned element.
            */
        Left: string;
        /**
            * Sets the extra spacing between letters.
            */
        LetterSpacing: string;
        /**
            * Sets the height between lines of text.
            */
        LineHeight: string;
        /**
            * Defines the display style for a list and list elements.
            */
        ListStyle: string;
        /**
            * Specifies the image to be used as a list-item marker.
            */
        ListStyleImage: string;
        /**
            * Specifies the position of the list-item marker.
            */
        ListStylePosition: string;
        /**
            * Specifies the marker style for a list-item.
            */
        ListStyleType: string;
        /**
            * Sets the margin on all four sides of the element.
            */
        Margin: string;
        /**
            * Sets the bottom margin of the element.
            */
        MarginBottom: string;
        /**
            * Sets the left margin of the element.
            */
        MarginLeft: string;
        /**
            * Sets the right margin of the element.
            */
        MarginRight: string;
        /**
            * Sets the top margin of the element.
            */
        MarginTop: string;
        /**
            * Specify the maximum height of an element.
            */
        MaxHeight: string;
        /**
            * Specify the maximum width of an element.
            */
        MaxWidth: string;
        /**
            * Specify the minimum height of an element.
            */
        MinHeight: string;
        /**
            * Specify the minimum width of an element.
            */
        MinWidth: string;
        /**
            * Specifies the transparency of an element.
            */
        Opacity: string;
        /**
            * Specifies the order in which a flex items are displayed and laid out within a flex container.
            */
        Order: string;
        /**
            * Sets the width, style, and color for all four sides of an element's outline.
            */
        Outline: string;
        /**
            * Sets the color of the outline.
            */
        OutlineColor: string;
        /**
            * Set the space between an outline and the border edge of an element.
            */
        OutlineOffset: string;
        /**
            * Sets a style for an outline.
            */
        OutlineStyle: string;
        /**
            * Sets the width of the outline.
            */
        OutlineWidth: string;
        /**
            * Specifies the treatment of content that overflows the element's box.
            */
        Overflow: string;
        /**
            * Specifies the treatment of content that overflows the element's box horizontally.
            */
        OverflowX: string;
        /**
            * Specifies the treatment of content that overflows the element's box vertically.
            */
        OverflowY: string;
        /**
            * Sets the padding on all four sides of the element.
            */
        Padding: string;
        /**
            * Sets the padding to the bottom side of an element.
            */
        PaddingBottom: string;
        /**
            * Sets the padding to the left side of an element.
            */
        PaddingLeft: string;
        /**
            * Sets the padding to the right side of an element.
            */
        PaddingRight: string;
        /**
            * Sets the padding to the top side of an element.
            */
        PaddingTop: string;
        /**
            * Insert a page breaks after an element.
            */
        PageBreakAfter: string;
        /**
            * Insert a page breaks before an element.
            */
        PageBreakBefore: string;
        /**
            * Insert a page breaks inside an element.
            */
        PageBreakInside: string;
        /**
            * Defines the perspective from which all child elements of the object are viewed.
            */
        Perspective: string;
        /**
            * Defines the origin (the vanishing point for the 3D space) for the perspective property.
            */
        PerspectiveOrigin: string;
        /**
            * Specifies how an element is positioned.
            */
        Position: string;
        /**
            * Specifies quotation marks for embedded quotations.
            */
        Quotes: string;
        /**
            * Specifies whether or not an element is resizable by the user.
            */
        Resize: string;
        /**
            * Specify the location of the right edge of the positioned element.
            */
        Right: string;
        /**
            * Specifies the length of the tab character.
            */
        TabSize: string;
        /**
            * Specifies a table layout algorithm.
            */
        TableLayout: string;
        /**
            * Sets the horizontal alignment of inline content.
            */
        TextAlign: string;
        /**
            * Specifies how the last line of a block or a line right before a forced line break is aligned when text-align is justify.
            */
        TextAlignLast: string;
        /**
            * Specifies the decoration added to text.
            */
        TextDecoration: string;
        /**
            * Specifies the color of the text-decoration-line.
            */
        TextDecorationColor: string;
        /**
            * Specifies what kind of line decorations are added to the element.
            */
        TextDecorationLine: string;
        /**
            * Specifies the style of the lines specified by the text-decoration-line property
            */
        TextDecorationStyle: string;
        /**
            * Indent the first line of text.
            */
        TextIndent: string;
        /**
            * Specifies the justification method to use when the text-align property is set to justify.
            */
        TextJustify: string;
        /**
            * Specifies how the text content will be displayed, when it overflows the block containers.
            */
        TextOverflow: string;
        /**
            * Applies one or more shadows to the text content of an element.
            */
        TextShadow: string;
        /**
            * Transforms the case of the text.
            */
        TextTransform: string;
        /**
            * Specify the location of the top edge of the positioned element.
            */
        Top: string;
        /**
            * Applies a 2D or 3D transformation to an element.
            */
        Transform: string;
        /**
            * Defines the origin of transformation for an element.
            */
        TransformOrigin: string;
        /**
            * Specifies how nested elements are rendered in 3D space.
            */
        TransformStyle: string;
        /**
            * Defines the transition between two states of an element.
            */
        Transition: string;
        /**
            * Specifies when the transition effect will start.
            */
        TransitionDelay: string;
        /**
            * Specifies the number of seconds or milliseconds a transition effect should take to complete.
            */
        TransitionDuration: string;
        /**
            * Specifies the names of the CSS properties to which a transition effect should be applied.
            */
        TransitionProperty: string;
        /**
            * Specifies the speed curve of the transition effect.
            */
        TransitionTimingFunction: string;
        /**
            * Sets the vertical positioning of an element relative to the current text baseline.
            */
        VerticalAlign: string;
        /**
            * Specifies whether or not an element is visible.
            */
        Visibility: string;
        /**
            * Specifies how white space inside the element is handled.
            */
        WhiteSpace: string;
        /**
            * 	Specify the width of an element.
            */
        Width: string;
        /**
            * 	Specifies how to break lines within words.
            */
        WordBreak: string;
        /**
            * Sets the spacing between words.
            */
        WordSpacing: string;
        /**
            * Specifies whether to break words when the content overflows the boundaries of its container.
            */
        WordWrap: string;
        /**
            * Specifies a layering or stacking order for positioned elements.
            */
        ZIndex: string;
        constructor(obj: IControl);
        GetStyleObject(): any;
        SetStyleObject(styleObject: any): void;
        CloneStyleObject(): {};
        Assign(other: AppearanceObject): void;
        ToString(): string;
}

export interface IControl extends IRenderable {
    Text: string;
    TabIndex: int;
    jssStyle: any;
    Appearance: AppearanceObject;
    HoverAppearance: AppearanceObject;
    ActiveAppearance: AppearanceObject;
    DisabledAppearance: AppearanceObject;
    FocusAppearance: AppearanceObject;
    BeforeAppearance: AppearanceObject;
    PropertyChanged: Event<any>;
    UpdateRequied: Event<any>;
    OnLoaded(): void;
    OnUnLoaded(): void;
    Width?: int;
    Height?: int;
    BackgroundColor: string;
    Padding: Padding;
    Border: Border;
    Margin: Margin;
    Left?: string;
    Top?: string;
    Bottom?: string;
    Right?: string;
    _Width?: string;
    _Height?: string;
    Id: string;
    WndProc(msg: Message): any;
    PaddingAll?: string;
    PaddingLeft?: string;
    PaddingRight?: string;
    PaddingTop?: string;
    PaddingBottom?: string;
    BackColor?: any;
    Visible: boolean;
    Tooltip: string;
    KeyFrameCollection: KeyFrameCollection[];
}

export interface IRenderable {
    Appearance: AppearanceObject;
    Render(): any;
}

export class Dialog extends React.Component {
    static defaultProps: {
        id: any;
        header: any;
        footer: any;
        visible: boolean;
        position: string;
        draggable: boolean;
        resizable: boolean;
        modal: boolean;
        isActive: boolean;
        onHide: any;
        onShow: any;
        contentStyle: any;
        contentClassName: any;
        closeOnEscape: boolean;
        dismissableMask: boolean;
        rtl: boolean;
        closable: boolean;
        style: any;
        maskStyle: any;
        className: any;
        maskClassName: any;
        showHeader: boolean;
        headerColor: any;
        headerPadding: any;
        headerSubStyle: any;
        headerHeight: any;
        headerTitleColor: any;
        headerTitleAlign: any;
        headerTitleFontSize: any;
        contentPadding: any;
        appendTo: any;
        baseZIndex: number;
        maximizable: boolean;
        topMaximizable: boolean;
        blockScroll: boolean;
        icons: any;
        ariaCloseIconLabel: string;
        focusOnShow: boolean;
        minX: number;
        minY: number;
        keepInViewport: boolean;
        maximized: boolean;
        topMaximized: boolean;
        breakpoints: any;
        onMaximize: any;
        onTopMaximize: any;
        onDragStart: any;
        onDrag: any;
        onDragEnd: any;
        onResizeStart: any;
        onResize: any;
        onResizeEnd: any;
        onContentResize: any;
        onClick: any;
    };
    id: any;
    attributeSelector: string;
    dialogRef: any;
    mask: any;
    dragging: boolean;
    lastPageX: any;
    lastPageY: any;
    resizing: boolean;
    documentDragListener: any;
    documentDragEndListener: any;
    documentResizeListener: any;
    documentResizeEndListener: any;
    documentKeyDownListener: any;
    styleElement: any;
    closeElement: any;
    headerEl: any;
    headerSubEl: any;
    footerElement: any;
    contentEl: HTMLElement;
    constructor(props: any);
    onClick(event: any): void;
    onClose(event: any): void;
    focus(): void;
    onMaskClick(event: any): void;
    toggleTopMaximize(event: any): void;
    toggleMaximize(event: any): void;
    toggleMinimize(event: any): void;
    onDragStart(event: any): void;
    onDrag(event: any): void;
    onDragEnd(event: any): void;
    onResizeStart(event: any): void;
    onResize(event: any): void;
    onResizeEnd(event: any): void;
    resetPosition(): void;
    getPositionClass(): string;
    get zIndex(): any;
    get topMaximized(): any;
    get maximized(): any;
    get minimized(): any;
    get dialogEl(): any;
    onEnter(): void;
    onEntered(): void;
    onExited(): void;
    enableDocumentSettings(): void;
    disableDocumentSettings(): void;
    bindGlobalListeners(): void;
    unbindGlobalListeners(): void;
    bindDocumentDragListener(): void;
    unbindDocumentDragListener(): void;
    bindDocumentResizeListeners(): void;
    unbindDocumentResizeListeners(): void;
    bindDocumentKeyDownListener(): void;
    unbindDocumentKeyDownListener(): void;
    createStyle(): void;
    componentDidMount(): void;
    componentDidUpdate(prevProps: any): void;
    changeScrollOnMaximizable(): void;
    componentWillUnmount(): void;
    renderCloseIcon(): any;
    renderTopMaximizeIcon(): any;
    renderMaximizeIcon(): any;
    renderMinimizeIcon(): any;
    renderHeader(): any;
    renderContent(): any;
    renderFooter(): any;
    renderResizer(): any;
    renderElement(): any;
    render(): any;
}

export interface ITextBox extends IControl {
    Autofocus: boolean;
    LeftIcon: string;
    Disabled: boolean;
    Placeholder: string;
    OnKeyDownInternal: Function;
}

export class TTabControlRenderer extends ControlHtmlRenderer<TTabControl> {
    GenerateBody(obj: TTabControl): void;
    protected OnComponentDidUpdate(obj: TTabControl): void;
}

export class MultiComboBox extends Control<MultiComboBox> {
    Label: string;
    Placeholder: string;
    SelectedItems: TextMultiComboBoxItem[];
    Items: MultiComboBoxItemCollection;
    protected SetupControlDefaults(): void;
    CreateElements(): any;
}

export abstract class MultiComboBoxItem {
    Parent: MultiComboBox;
    Key: string;
    Text: string;
    Tag: any;
    abstract GetItemTemplate(): any;
    abstract ToObject(): any;
}

export class MultiComboBoxItemCollection extends List<MultiComboBoxItem> {
    ComboBox: MultiComboBox;
    constructor(comboBox: MultiComboBox);
    Add(text: string): MultiComboBoxItem;
    Add(key: int, text: string): MultiComboBoxItem;
    Add(key: string, text: string): MultiComboBoxItem;
    Add(treeNode: MultiComboBoxItem): int;
    Clear(): int;
    ToObject(): any[];
}

export class ComboBox extends ComboBoxBase {
    CreateElements(): any;
}

export abstract class ComboBoxBase extends Control<ComboBoxBase> {
    get OnChanged(): any;
    set OnChanged(value: any);
    get Label(): string;
    set Label(value: string);
    get SelectedItem(): ComboBoxItem;
    set SelectedItem(value: ComboBoxItem);
    get Items(): ComboBoxItemCollection;
    set Items(value: ComboBoxItemCollection);
    get Placeholder(): string;
    set Placeholder(value: string);
    get Filter(): boolean;
    set Filter(value: boolean);
    Editable: boolean;
    protected SetupControlDefaults(): void;
    InitComponents(): void;
}

export abstract class ComboBoxItem {
    Parent: ComboBoxBase;
    Key: string;
    Text: string;
    Tag: any;
    abstract GetItemTemplate(): any;
    abstract ToObject(): any;
}

export class ComboBoxItemCollection extends List<ComboBoxItem> {
    ComboBox: ComboBoxBase;
    constructor(comboBox: ComboBoxBase);
    Add(text: string): ComboBoxItem;
    Add(key: int, text: string): ComboBoxItem;
    Add(key: string, text: string): ComboBoxItem;
    Add(treeNode: ComboBoxItem): int;
    Clear(): int;
    ToObject(): any[];
}

export class ListBox extends ListBoxBase {
    CreateElements(): any;
}

export abstract class ListBoxBase extends Control<ListBoxBase> {
    get OnChanged(): any;
    set OnChanged(value: any);
    get Label(): string;
    set Label(value: string);
    get SelectedItem(): ListBoxItem;
    set SelectedItem(value: ListBoxItem);
    get Items(): ListBoxItemCollection;
    set Items(value: ListBoxItemCollection);
    get Placeholder(): string;
    set Placeholder(value: string);
    get Filter(): boolean;
    set Filter(value: boolean);
    protected SetupControlDefaults(): void;
    InitComponents(): void;
}

export abstract class ListBoxItem {
    Parent: ListBoxBase;
    Key: string;
    Text: string;
    Tag: any;
    abstract GetItemTemplate(): any;
    abstract ToObject(): any;
}

export class ListBoxItemCollection extends List<ListBoxItem> {
    ListBox: ListBoxBase;
    constructor(ListBox: ListBoxBase);
    Add(text: string): ListBoxItem;
    Add(key: int, text: string): ListBoxItem;
    Add(key: string, text: string): ListBoxItem;
    Add(treeNode: ListBoxItem): int;
    Clear(): int;
    ToObject(): any[];
}

export class SelectionChanged extends Delegate<(key: string) => void> {
}
export class TTreeView extends Control<TTreeView> {
    get AfterSelect(): Event<TreeViewEventHandler>;
    set AfterSelect(value: Event<TreeViewEventHandler>);
    get BeforeSelect(): Event<TreeViewCancelEventHandler>;
    set BeforeSelect(value: Event<TreeViewCancelEventHandler>);
    get SelectedItem(): any;
    set SelectedItem(value: any);
    get Label(): string;
    set Label(value: string);
    get SelectedKey(): string;
    set SelectedKey(value: string);
    get SelectedKey$(): Observable<string>;
    set SelectedKey$(value: Observable<string>);
    get SelectedNode(): TreeNode;
    set SelectedNode(value: TreeNode);
    get Nodes(): TreeNodeCollection;
    set Nodes(value: TreeNodeCollection);
    NodeMouseDoubleClick: Event<any>;
    ItemDrag: Event<any>;
    protected SetupControlDefaults(): void;
    protected SetupComponentDefaults(): void;
    Expand(node: TreeNode): void;
    CreateElements(): any;
    OnSelectionChanged(): void;
    onNodeSelect(): void;
    onNodeUnselect(): void;
}

export class TreeNode {
    Key: string;
    Icon: string;
    Selectable: boolean;
    Tag: any;
    get TreeView(): TTreeView;
    set TreeView(value: TTreeView);
    Text: string;
    Nodes: TreeNodeCollection;
    constructor(text: string);
    constructor(key: string, text: string);
    ToObject(): any;
}

export class TreeViewEventArgs extends EventArgs {
    constructor(node: TreeNode, action?: TreeViewAction);
    get Action(): TreeViewAction;
    get Node(): TreeNode;
}

export class TreeViewCancelEventArgs {
    constructor(node: TreeNode, cancel: boolean, action: TreeViewAction);
    get Node(): TreeNode;
    get Action(): TreeViewAction;
    get Cancel(): boolean;
    set Cancel(value: boolean);
}

export class RowClickEvent extends Delegate<() => void> {
}
export class GridView extends Control<GridView> {
    get KeyField(): string;
    set KeyField(value: string);
    get SelectedRow(): any;
    set SelectedRow(value: any);
    get Columns(): ColumnCollection;
    set Columns(value: ColumnCollection);
    get Data(): any;
    set Data(value: any);
    get ScrollHeight(): int;
    set ScrollHeight(value: int);
    get OnRowDoubleClick(): Event<RowClickEvent>;
    set OnRowDoubleClick(value: Event<RowClickEvent>);
    SetupControlDefaults(): void;
    protected componentWillUnmount(): void;
    CreateElements(): any;
}

export abstract class GridViewBase extends Control<GridViewBase> {
    get AutoGenerateColumns(): boolean;
    set AutoGenerateColumns(value: boolean);
    get Columns(): ColumnCollection;
    set Columns(value: ColumnCollection);
    get DataSource(): any;
    set DataSource(value: any);
    get ScrollHeight(): int;
    set ScrollHeight(value: int);
    SetupControlDefaults(): void;
    protected componentWillUnmount(): void;
    RefreshColumns(): void;
    protected abstract RefreshColumnsInternal(): void;
}

export enum ColumnClipModes {
    /** Truncates the cell content when it overflows its area. */
    Clip = "Clip",
    /** Displays ellipsis when the cell content overflows its area. */
    Ellipsis = "Ellipsis",
    /** Displays ellipsis when the cell content overflows its area also it will display tooltip while hover on ellipsis applied cell. */
    EllipsisWithTooltip = "EllipsisWithTooltip"
}
export enum TextAlign {
    /**  Defines Left alignment */
    Left = "Left",
    /**  Defines Right alignment */
    Right = "Right",
    /**  Defines Center alignment */
    Center = "Center",
    /**  Defines Justify alignment */
    Justify = "Justify"
}
export class GridColumn implements IDataGridColumn {
    allowEditing: boolean;
    allowFiltering: boolean;
    allowGrouping: boolean;
    allowReordering: boolean;
    allowResizing: boolean;
    allowSearching: boolean;
    allowSorting: boolean;
    autoFit: boolean;
    clipMode: ColumnClipModes;
    columns: List<IDataGridColumn>;
    commands: any[];
    customAttributes: Object;
    dataSource: Object[];
    defaultValue: string;
    disableHtmlEncode: boolean;
    displayAsCheckBox: boolean;
    edit: any;
    editTemplate: string;
    editType: string;
    enableGroupByFormat: boolean;
    field: string;
    filter: any;
    filterBarTemplate: any;
    filterTemplate: string;
    foreignKeyField: string;
    foreignKeyValue: string;
    format: string;
    formatter: Object | ICellFormatter | Function;
    headerTemplate: string;
    headerText: string;
    headerTextAlign: TextAlign;
    headerValueAccessor: string;
    hideAtMedia: string;
    index: number;
    isFrozen: boolean;
    isIdentity: boolean;
    isPrimaryKey: boolean;
    lockColumn: boolean;
    maxWidth: string | number;
    minWidth: string | number;
    showColumnMenu: boolean;
    showInColumnChooser: boolean;
    sortComparer: string;
    template: string;
    textAlign: TextAlign;
    type: string;
    uid: string;
    validationRules: Object;
    valueAccessor: string;
    visible: boolean;
    width: string | number;
    constructor(header: string);
    constructor(field: string, header: string);
    GetBodyTemplate(rowData: any): any;
}

export interface ICellFormatter {
    getValue(column: IDataGridColumn, data: Object): Object;
}
export interface IDataGridColumn {
    allowEditing: boolean;
    allowFiltering: boolean;
    allowGrouping: boolean;
    allowReordering: boolean;
    allowResizing: boolean;
    allowSearching: boolean;
    allowSorting: boolean;
    autoFit: boolean;
    clipMode: ColumnClipModes;
    columns: List<IDataGridColumn>;
    commands: any[];
    customAttributes: Object;
    dataSource: any;
    defaultValue: string;
    disableHtmlEncode: boolean;
    displayAsCheckBox: boolean;
    edit: any;
    editTemplate: string;
    editType: string;
    enableGroupByFormat: boolean;
    field: string;
    filter: any;
    filterBarTemplate: any;
    filterTemplate: string;
    foreignKeyField: string;
    foreignKeyValue: string;
    format: string;
    formatter: Object | ICellFormatter | Function;
    headerTemplate: string;
    headerText: string;
    headerTextAlign: string;
    headerValueAccessor: string;
    hideAtMedia: string;
    index: int;
    isFrozen: boolean;
    isIdentity: boolean;
    isPrimaryKey: boolean;
    lockColumn: boolean;
    maxWidth: string | int;
    minWidth: string | int;
    showColumnMenu: boolean;
    showInColumnChooser: boolean;
    sortComparer: string;
    template: string;
    textAlign: string;
    type: string;
    uid: string;
    validationRules: Object;
    valueAccessor: string;
    visible: boolean;
    width: string | int;
}

export class ImageColumn extends GridColumn {
    Image: string;
    ImageSize: int;
    imageTemplate(rowData: any): any;
}

export class Toolbar extends Control<Toolbar> {
    CreateElements(): any;
}

export class DropEventArgs {
    sender: any;
    nativeEvent: DragEvent;
    constructor(sender: any, nativeEvent: DragEvent);
}
export class DragEnterEventHandler extends Delegate<(e: DragEvent) => void> {
}
export class DragLeaveEventHandler extends Delegate<(e: DragEvent) => void> {
}
export class DragOverEventHandler extends Delegate<(e: DragEvent) => void> {
}
export class DropEventHandler extends Delegate<(e: DropEventArgs) => void> {
}
export class DropArea extends Control<DropArea> {
    AllowDrop: boolean;
    Controls: ControlCollection;
    DragEnter: Event<DragEnterEventHandler>;
    DragLeave: Event<DragLeaveEventHandler>;
    DragOver: Event<DragOverEventHandler>;
    Drop: Event<DropEventHandler>;
    protected SetupControlDefaults(): void;
    CreateElements(): any;
    protected GetStyleObject(): any;
}

export class Taskbar extends Control<Taskbar> {
    get UserName(): string;
    set UserName(value: string);
    get ProfilePicture(): string;
    set ProfilePicture(value: string);
    SetupControlDefaults(): void;
    CreateElements(): any;
}

export class ContainerControl<T extends Control<any>> extends Control<ContainerControl<T>> implements IControlContainer {
    get Controls(): ControlCollection;
    set Controls(value: ControlCollection);
    protected SetupControlDefaults(): void;
    protected CreateControls(): any[];
    CreateElements(): void;
    GetControls(): List<Control<any>>;
}
export class EndLayout extends ContainerControl<EndLayout> {
    CreateElements(): any;
}

export class VerticalLayout extends ContainerControl<VerticalLayout> {
    CreateElements(): any;
}

export class HorizontalLayout extends ContainerControl<HorizontalLayout> {
    CreateElements(): any;
}

export enum SizingModes {
    LeftFixed = 0,
    RightFixed = 1,
    Left2Right10 = 2,
    Left3Right9 = 3,
    Left6Right6 = 4,
    Right2Left10 = 5
}
export class LayoutPanel extends Control<LayoutPanel> {
    RightPaneElementRef: HTMLElement;
    get SizingMode(): SizingModes;
    set SizingMode(value: SizingModes);
    get LeftSize(): int;
    set LeftSize(value: int);
    get LeftControl(): Control<any>;
    set LeftControl(value: Control<any>);
    get RightControl(): Control<any>;
    set RightControl(value: Control<any>);
    SetupControlDefaults(): void;
    componentDidMount(): void;
    CreateElements(): any;
    OnFormResized(width: int, height: int): void;
    GetLeftPanelRect(): DOMRect;
}

export class RibbonMenu extends Control<RibbonMenu> {
    get Tabs(): RibbonTabCollection;
    set Tabs(value: RibbonTabCollection);
    get ActiveTabIndex(): int;
    set ActiveTabIndex(value: int);
    SetupControlDefaults(): void;
    CreateTabs(data: any): any[];
    CreateContentPanels(data: any): any[];
    CreateElements(): any;
}

export class RibbonTab {
    Text: string;
    IsStatic: boolean;
    Groups: RibbonGroupCollection;
    ToModel(): any;
}

class ClickEvent extends Delegate<() => void> {
}
export class ListView extends Control<ListView> {
    get DbClick(): Event<ClickEvent>;
    set DbClick(value: Event<ClickEvent>);
    get SelectedItemIndex(): int;
    set SelectedItemIndex(value: int);
    get Items(): ListViewItemCollection;
    set Items(value: ListViewItemCollection);
    SetupControlDefaults(): void;
    CreateElements(): any;
}
export {};

export class ListViewItem {
    Text: string;
    Icon: string;
    Tag: any;
}

export class ContextMenu extends Control<ContextMenu> {
    get MenuItems(): MenuItemCollection;
    set MenuItems(value: MenuItemCollection);
    SetupControlDefaults(): void;
    CreateElements(): any;
}

export interface ISystemMenu {
    GetMenuItems(): MenuItem[];
}

class ClickEvent extends Delegate<() => void> {
}
export class MenuItem {
    Text: string;
    Icon: string;
    Click: Event<ClickEvent>;
    Items: MenuItemCollection;
    Serialize(): object;
}
export {};

export class MenuItemCollection extends List<MenuItem> {
    ContextMenu: ContextMenu;
    constructor(contextMenu?: ContextMenu);
    Add(text: string): MenuItem;
    Add(treeNode: MenuItem): int;
    Serialize(): any[];
}

class ClickEvent extends Delegate<() => void> {
}
export enum CardSizes {
    Small = 0,
    Medium = 1,
    Large = 2
}
export class CardView extends Control<CardView> {
    get _OnClick(): Event<ClickEvent>;
    set _OnClick(value: Event<ClickEvent>);
    get CardSize(): CardSizes;
    set CardSize(value: CardSizes);
    get Items(): CardViewItemCollection;
    set Items(value: CardViewItemCollection);
    SetupControlDefaults(): void;
    renderItem(item: CardViewItem): any;
    renderLargeItem(item: CardViewItem): any;
    CreateElements(): any;
}
export {};

export class ClickEvent extends Delegate<() => void> {
}
export class CardViewItem {
    CardView: CardView;
    get Title(): string;
    set Title(value: string);
    get TopTitle(): string;
    set TopTitle(value: string);
    get SubTitle(): string;
    set SubTitle(value: string);
    get Image(): string;
    set Image(value: string);
    get Tag(): any;
    set Tag(value: any);
    get ButtonText(): string;
    set ButtonText(value: string);
    get Description(): string;
    set Description(value: string);
    FooterControl: Control<any>;
    OnClick: Event<ClickEvent>;
}

export class DragStartEventHandler extends Delegate<(e: DragEvent) => void> {
}
export class ListMenu extends Control<ListMenu> {
    DragStart: Event<DragStartEventHandler>;
    EditMode: boolean;
    HeaderText: string;
    ItemHeight: int;
    ItemColor: string;
    SelectedItemColor: string;
    ItemBorder: Border;
    SelectedIndexChanged: Event<any>;
    get SelectedIndex(): int;
    set SelectedIndex(value: int);
    get SelectedIndex$(): Observable<int>;
    set SelectedIndex$(value: Observable<int>);
    get Items(): ListMenuItemCollection;
    set Items(value: ListMenuItemCollection);
    Controls: ControlCollection;
    constructor();
    protected GetRenderer(): typeof ListMenuRenderer;
    protected OnItemClick(item: ListMenuItem): void;
    OnSelectedIndexChanged(): void;
}

export class ListMenuItemBase extends TVirtualContainer {
    get Selectable(): boolean;
    get Parent(): ListMenu;
    set Parent(value: ListMenu);
    protected OnClick(e: EventArgs): void;
    protected OnGotSelection(): void;
    protected OnLostSelection(): void;
}
export class ListMenuItem extends ListMenuItemBase {
    get Text(): string;
    set Text(value: string);
    get BackgroundColor(): string;
    set BackgroundColor(value: string);
    Image: string;
    Icon: FontIcon;
    IconRight: FontIcon;
    Label: TLabel;
    ImageSelected: string;
    ImageRight: string;
    ImageRightSelected: string;
    Tag: any;
    constructor();
    protected OnClick(e: EventArgs): void;
    protected OnGotSelection(): void;
    protected OnLostSelection(): void;
}

export class BottomMenu extends Control<BottomMenu> {
    get Items(): BottomMenuItemCollection;
    set Items(value: BottomMenuItemCollection);
    SetupControlDefaults(): void;
    renderMenuItem(item: BottomMenuItem): any;
    CreateElements(): any;
}

export class BottomMenuItem {
    BottomMenu: BottomMenu;
    Text: string;
    Image: string;
    Icon: string;
    MenuModel: any;
    OnClick: Event<EventHandler>;
    get Disabled(): boolean;
    set Disabled(value: boolean);
    constructor(bottomMenu: BottomMenu);
}

export class BottomMenuItemCollection extends List<BottomMenuItem> {
    ListView: BottomMenu;
    constructor(listView: BottomMenu);
    Add(icon: string): BottomMenuItem;
    Add(treeNode: BottomMenuItem): int;
}

export class Tag {
    Text: any;
}

export class TagCollection extends List<Tag> {
    TagsControl: TagsControl;
    constructor(tagsControl: TagsControl);
    Add(text: string): Tag;
    Add(tag: Tag): int;
}

export class TagsControl extends Control<TagsControl> {
    get Tags(): TagCollection;
    set Tags(value: TagCollection);
    SetupControlDefaults(): void;
    CreateElements(): any;
}

export enum Orientations {
    Horizontal = "horizontal",
    Vertical = "vertical"
}
export class Slider extends Control<Slider> {
    Orientation: Orientations;
    get SlideEnd(): any;
    set SlideEnd(value: any);
    get Value(): int;
    set Value(value: int);
    get Max(): int;
    set Max(value: int);
    get Min(): int;
    set Min(value: int);
    get Value$(): ReplaySubject<int>;
    set Value$(value: ReplaySubject<int>);
    SetupControlDefaults(): void;
    GetRenderer(): any;
}

export class SelectButton extends Control<SelectButton> {
    get Value(): string;
    set Value(value: string);
    get OptionLabel(): string;
    set OptionLabel(value: string);
    get OptionValue(): any;
    set OptionValue(value: any);
    get Options(): any;
    set Options(value: any);
    get Value$(): ReplaySubject<int>;
    set Value$(value: ReplaySubject<int>);
    get Changed(): Event<any>;
    set Changed(value: Event<any>);
    SetupControlDefaults(): void;
    CreateElements(): any;
}

export class RadioButtonGroup extends Control<RadioButtonGroup> {
    get Items(): RadioGroupItemCollection;
    set Items(value: RadioGroupItemCollection);
    get Value(): RadioButtonGroupItem;
    set Value(value: RadioButtonGroupItem);
    get Value$(): ReplaySubject<RadioButtonGroupItem>;
    set Value$(value: ReplaySubject<RadioButtonGroupItem>);
    protected SetupControlDefaults(): void;
    CreateElements(): any;
}

export class RadioButtonGroupItem {
    Parent: RadioButtonGroup;
    Key: string;
    Text: string;
    Tag: any;
    constructor(text: string);
    constructor(key: string, text: string);
    ToObject(): any;
}

export class TRadioButton extends TFlexContainer {
    get Checked(): boolean;
    set Checked(value: boolean);
    get Text(): string;
    set Text(value: string);
    constructor();
}

export class TRadioButtonGroup extends TFlexColumnContainer {
    constructor();
}

export class Accordion extends Control<Accordion> {
    get ActiveIndexes(): int[];
    set ActiveIndexes(value: int[]);
    get HeaderText(): string;
    set HeaderText(value: string);
    get Tabs(): AccordionTabCollection;
    set Tabs(value: AccordionTabCollection);
    SetupControlDefaults(): void;
    CreateElements(): any;
}

export class AccordionTab extends ContainerControl<any> {
    CreateElements(): any;
}

export class AccordionTabCollection extends List<AccordionTab> {
    Accordion: Accordion;
    constructor(listView: Accordion);
    Add(text: string): AccordionTab;
    Add(treeNode: AccordionTab): int;
}

export function EventProperty(): any;
export function Property(defaultValue?: any): any;
export function State(defaultValue?: Function): any;
export function Binding<T>(defaultValue?: T): any;
export function Ref(defaultValue?: Function): any;
export function _State(target: Object, key: string): void;

export class ShadowRootPanel extends Control<ShadowRootPanel> {
    Style: string;
    Controls: ControlCollection;
    protected SetupControlDefaults(): void;
    CreateElements(): any;
}

export class FontIcon extends Control<FontIcon> implements IFontIcon {
    FontFamily: string;
    Content: string;
    Size: int;
    Color: CGColor;
    constructor();
    GetRenderer(): any;
}

export class UIIconClass extends UIView implements IFontIcon {
    setController(controller: UIController): this;
    constructor();
    size(size: int): this;
    Render(): any;
}
export function Icon(icon: IconType): UIIconClass;
export function Icon(content: string): UIIconClass;

export class IconType {
    constructor(title: string, name: string, filled: string);
    GetTitle(): string;
    GetCode(): string;
}
export const IconLibrary: {
    Search: IconType;
    Home: IconType;
    AccountCircle: IconType;
    Settings: IconType;
    Done: IconType;
    Info: IconType;
    CheckCircle: IconType;
    Delete: IconType;
    ShoppingCart: IconType;
    Visibility: IconType;
    Favorite: IconType;
    Logout: IconType;
    Description: IconType;
    FavoriteBorder: IconType;
    Lock: IconType;
    Schedule: IconType;
    Language: IconType;
    Face: IconType;
    HelpOutline: IconType;
    ManageAccounts: IconType;
    FilterAlt: IconType;
    Fingerprint: IconType;
    Event: IconType;
    Verified: IconType;
    ThumbUp: IconType;
    Dashboard: IconType;
    Login: IconType;
    CalendarToday: IconType;
    VisibilityOff: IconType;
    List: IconType;
    CheckCircleOutline: IconType;
    HighlightOff: IconType;
    Help: IconType;
    DateRange: IconType;
    QuestionAnswer: IconType;
    TaskAlt: IconType;
    Paid: IconType;
    Article: IconType;
    ShoppingBag: IconType;
    Lightbulb: IconType;
    OpenInNew: IconType;
    PermIdentity: IconType;
    TrendingUp: IconType;
    History: IconType;
    CreditCard: IconType;
    AccountBalance: IconType;
    DeleteOutline: IconType;
    ReportProblem: IconType;
    FactCheck: IconType;
    Assignment: IconType;
    VerifiedUser: IconType;
    ArrowRightAlt: IconType;
    StarRate: IconType;
    AccountBalanceWallet: IconType;
    Analytics: IconType;
    Autorenew: IconType;
    Work: IconType;
    Build: IconType;
    ViewList: IconType;
    Print: IconType;
    Store: IconType;
    Today: IconType;
    DeleteForever: IconType;
    AdminPanelSettings: IconType;
    LockOpen: IconType;
    Savings: IconType;
    Room: IconType;
    Code: IconType;
    Grade: IconType;
    Receipt: IconType;
    WatchLater: IconType;
    Update: IconType;
    AddShoppingCart: IconType;
    ContactSupport: IconType;
    PowerSettingsNew: IconType;
    Pets: IconType;
    DoneAll: IconType;
    Explore: IconType;
    Bookmark: IconType;
    BookmarkBorder: IconType;
    NoteAdd: IconType;
    Reorder: IconType;
    AccountBox: IconType;
    ShoppingBasket: IconType;
    PendingActions: IconType;
    DragIndicator: IconType;
    Payment: IconType;
    Launch: IconType;
    CalendarMonth: IconType;
    SupervisorAccount: IconType;
    Pending: IconType;
    ZoomIn: IconType;
    TouchApp: IconType;
    Assessment: IconType;
    ThumbUpOffAlt: IconType;
    OpenInFull: IconType;
    Leaderboard: IconType;
    DoneOutline: IconType;
    ExitToApp: IconType;
    Preview: IconType;
    AssignmentInd: IconType;
    CardGiftcard: IconType;
    ViewInAr: IconType;
    WorkOutline: IconType;
    PublishedWithChanges: IconType;
    Feedback: IconType;
    Timeline: IconType;
    Dns: IconType;
    SwapHoriz: IconType;
    SyncAlt: IconType;
    AssignmentTurnedIn: IconType;
    FlightTakeoff: IconType;
    Stars: IconType;
    Book: IconType;
    Label: IconType;
    PanTool: IconType;
    BugReport: IconType;
    ContactPage: IconType;
    Gavel: IconType;
    Cached: IconType;
    Alarm: IconType;
    Translate: IconType;
    SpaceDashboard: IconType;
    Android: IconType;
    SupervisedUserCircle: IconType;
    EditCalendar: IconType;
    Accessibility: IconType;
    Minimize: IconType;
    Extension: IconType;
    GetApp: IconType;
    TipsAndUpdates: IconType;
    RecordVoiceOver: IconType;
    AddTask: IconType;
    TrendingFlat: IconType;
    HourglassEmpty: IconType;
    HelpCenter: IconType;
    ThumbDown: IconType;
    AccessibilityNew: IconType;
    StickyNote2: IconType;
    Rule: IconType;
    FlutterDash: IconType;
    DashboardCustomize: IconType;
    Source: IconType;
    Support: IconType;
    FindInPage: IconType;
    CloseFullscreen: IconType;
    SettingsApplications: IconType;
    Redeem: IconType;
    ViewHeadline: IconType;
    Announcement: IconType;
    Loyalty: IconType;
    AdsClick: IconType;
    GroupWork: IconType;
    SwapVert: IconType;
    Restore: IconType;
    EuroSymbol: IconType;
    Sensors: IconType;
    Dangerous: IconType;
    CompareArrows: IconType;
    NightlightRound: IconType;
    RocketLaunch: IconType;
    PrivacyTip: IconType;
    ArrowCircleRight: IconType;
    QuestionMark: IconType;
    Subject: IconType;
    DisabledByDefault: IconType;
    TrackChanges: IconType;
    TableView: IconType;
    Https: IconType;
    Grading: IconType;
    Copyright: IconType;
    Toc: IconType;
    ArrowCircleUp: IconType;
    Bookmarks: IconType;
    Api: IconType;
    QueryBuilder: IconType;
    PermMedia: IconType;
    BuildCircle: IconType;
    Input: IconType;
    BookOnline: IconType;
    ZoomOut: IconType;
    Backup: IconType;
    PermContactCalendar: IconType;
    ViewModule: IconType;
    OpenWith: IconType;
    SettingsPhone: IconType;
    CircleNotifications: IconType;
    ThreeDRotation: IconType;
    ArrowCircleDown: IconType;
    LabelImportant: IconType;
    CardMembership: IconType;
    PermPhoneMsg: IconType;
    FilePresent: IconType;
    Wysiwyg: IconType;
    Pageview: IconType;
    Swipe: IconType;
    IntegrationInstructions: IconType;
    Upgrade: IconType;
    TrendingDown: IconType;
    ChangeHistory: IconType;
    Class: IconType;
    Accessible: IconType;
    SettingsAccessibility: IconType;
    ProductionGuantityLimits: IconType;
    OfflineBolt: IconType;
    Expand: IconType;
    ModelTraining: IconType;
    DonutLarge: IconType;
    AspectRatio: IconType;
    SettingsBackupRestore: IconType;
    CalendarViewMonth: IconType;
    Segment: IconType;
    ViewColumn: IconType;
    ScheduleSend: IconType;
    Maximize: IconType;
    BookmarkAdd: IconType;
    Percent: IconType;
    ArrowCircleLeft: IconType;
    ArrowDropDown: IconType;
    FileDownload: IconType;
    ExpandMore: IconType;
    Download: IconType;
    KeyboardArrowDown: IconType;
    ArrowDownward: IconType;
    Dashboard1: IconType;
    Error: IconType;
    Clock9: IconType;
};

export declare abstract class ControlHtmlRenderer<T extends IControl> extends HtmlRenderer<T> {
    DecideCache(obj: T): void;
    GenerateElement(obj: T): boolean;
    protected OnComponentDidMount(ref: any, obj: T): void;
    protected OnComponentWillUnmount(obj: T): void;
    GenerateAttributes(obj: T): void;
    abstract GenerateBody(obj: T): void;
    GenerateElementFinish(obj: T): void;
}

export declare abstract class HtmlRenderer<T extends IControl> extends XmlTransformer<T> {
    protected Ref: any;
    protected contextMenu: any;
    constructor(props: any);
    protected InitializeRenderer(obj: T): void;
    TranslateAlpha(c: CGColor): float;
    TranslateColor(c: CGColor): string;
    TranslateGraphicsPath(path: GraphicsPath): string;
    WriteBrushAttributes(brush: Brush): void;
    WriteEllipse(p: Pen, b: Brush, r: CGRectangle): void;
    WriteLine(p: Pen, a: CGPoint, b: CGPoint): void;
    WriteLines(p: Pen, v: CGPoint[]): void;
    WritePath(p: Pen, b: Brush, pathdesc: string): void;
    WritePenAttributes(pen: Pen): void;
    WritePolygon(p: Pen, b: Brush, poly: CGPoint[]): void;
    WriteRectangle(p: Pen, b: Brush, r: CGRectangle, corner: CGSize): void;
    protected OnShadowDomWillMount(ref: any, obj: T): void;
    protected OnShadowDomDidMount(ref: any, obj: T): void;
    protected OnShadowDomWillUnmount(ref: any, obj: T): void;
    protected OnComponentWillMount(ref: any, obj: T): void;
    protected OnComponentDidMount(ref: any, obj: T): void;
    protected OnComponentWillReceiveProps(obj: T): void;
    protected OnShouldComponentUpdate(obj: T): boolean;
    protected OnComponentWillUpdate(obj: T): void;
    protected OnComponentDidUpdate(obj: T): void;
    protected OnComponentWillUnmount(obj: T): void;
    protected GetStyleObject(): any;
    get UseShadowDom(): boolean;
    get UseFrameStyles(): boolean;
    OnStyleCreating(obj: T, sb: StringBuilder): void;
    OnCustomAttributesCreating(obj: T, attributeObject: any): void;
    GetCustomJss(obj: T): Object;
    render(param?: any): any;
}

export class TLabel extends Control<TLabel> implements ILabel {
    HtmlFor: string;
    TextAlign: string;
    constructor();
    protected GetRenderer(): any;
}

export abstract class ControlHtmlRenderer<T extends IControl> extends HtmlRenderer<T> {
    DecideCache(obj: T): void;
    GenerateElement(obj: T): boolean;
    protected OnComponentDidMount(ref: any, obj: T): void;
    protected OnComponentWillUnmount(obj: T): void;
    GenerateAttributes(obj: T): void;
    abstract GenerateBody(obj: T): void;
    GenerateElementFinish(obj: T): void;
}

export interface ILabel extends IControl {
    HtmlFor: string;
    TextAlign: string;
}

export interface TwoColumnWithHeaderFooterLayoutParams {
    header: UIView[];
    left: UIView[];
    right: UIView[];
    footer: UIView[];
}
export function TwoColumnWithHeaderFooterLayout(params: TwoColumnWithHeaderFooterLayoutParams): UIView;

export interface TwoColumnWithHeaderLayoutParams {
    header: UIView[];
    left: UIView[];
    right: UIView[];
}
export function TwoColumnWithHeaderLayout(params: TwoColumnWithHeaderLayoutParams): UIView;

export interface TwoColumnLayoutParams {
    left: UIView[];
    right: UIView[];
}
export function TwoColumnLayout(params: TwoColumnLayoutParams): UIView;
export function TwoColumnLayout2(params: TwoColumnLayoutParams): UIView;

export class UISpinner extends UIView {
    setController(controller: UIController): this;
    constructor();
}
export function Spinner(): UISpinner;

export class UIStepsClass extends UIView {
    setController(controller: UIController): this;
    constructor();
}

export interface IUploadFileReady {
    GetFileContentAsString(): string;
    fileName: string;
    fileExt: string;
    fileAsByteArray: ByteArray;
    file: any;
}

export function UIFileUpload(...content: UIView[]): UIFileUploadClass;

export class UISkeletonClass extends UIView {
    setController(controller: UIController): this;
    constructor();
}

export class DropDownClass extends UIView {
    vp_model: any[];
    vp_fields: {
        text: string;
        value: string;
    };
    vp_itemTemplate: (option: any) => UIView | Function;
    vp_emptyTemplate: () => UIView | Function;
    vp_selectedItemTemplate: (option: any) => UIView | Function;
    vp_onSelected: Function;
    vp_value: any;
    vp_PlaceHolder: string;
    setController(controller: UIController): this;
    constructor();
    itemTemplate(value: (option: any) => UIView | Function): this;
    emptyTemplate(value: () => UIView | Function): this;
    selectedItemTemplate(value: (option: any) => UIView | Function): this;
    model(value: any[]): this;
    onSelected(value: Function): this;
    value(value: any): this;
    fields(value: {
        text: string;
        value: string;
    }): this;
    placeholder(value: string): this;
    vp_FormField: {
        name: string;
        rules: ValidateRule[];
    };
    formField(name: string, rules: ValidateRule[]): this;
    vp_Label: string;
    label(value: string): this;
    vp_LabelTemplate: (label: string) => UIView;
    labelTemplate(value: (label: string) => UIView): this;
}

export class AutoCompleteClass extends UIView {
    vp_model: any[];
    vp_itemTemplate: (option: any) => UIView | Function;
    vp_onSelected: Function;
    vp_items: any[];
    vp_PlaceHolder: string;
    vp_SearchMethod: Function;
    vp_Field: string;
    vp_Value: any;
    vp_OnChange: Function;
    setController(controller: UIController): this;
    constructor();
    itemTemplate(value: (option: any) => UIView | Function): this;
    model(value: any[]): this;
    onSelected(value: Function): this;
    items(value: any[]): this;
    placeholder(value: string): this;
    searchMethod(value: Function): this;
    field(value: string): this;
    value(value: any): this;
    onChange(value: Function): this;
}

export function DataTable(): DataTableClass;

export class ColumnClass {
    _field: string;
    _header: string;
    _width: string;
    _body: UIView;
    field(value: string): this;
    header(value: string): this;
    width(value: string): this;
    body(value: UIView): this;
}
export function Column(): ColumnClass;

export class OverlayPanelClass extends UIView {
    _show: boolean;
    vp_HeaderTemplate: UIView;
    setController(controller: UIController): this;
    constructor();
    show(value: boolean): this;
    headerTemplate(value: UIView): this;
}

export class AvatarViewClass extends UIView {
    setController(controller: UIController): this;
    constructor();
}

export class SlideMenuViewClass extends UIView {
    vp_ViewportHeight: int;
    viewportHeight(value: int): this;
    setController(controller: UIController): this;
    constructor();
}

export class TableColumnClass extends UIView {
    setHeaderView(value: UIView): this;
    setRowFunction(value: (dataRow: any) => UIView): this;
    headerWidth(value: string): this;
    setController(controller: UIController): this;
}
export interface HeaderParams {
}
export type FunctionHeader = (...views: UIView[]) => TableColumnClass;
export type FunctionRow = (rowFunction: (dataRow: any) => UIView) => TableColumnClass;
export function TableColumn(): TableColumnClass;
export function TableColumn(...views: (UIView | IControl | UIController)[]): FunctionRow;
export function TableColumn(value: HeaderParams): FunctionHeader;

export class BodyClass extends UIView {
    setController(controller: UIController): this;
}
export interface BodyParams {
}
export type FunctionBody = (...views: UIView[]) => BodyClass;
export function TBody(): BodyClass;
export function TBody(...views: (UIView | IControl | UIController)[]): BodyClass;
export function TBody(value: BodyParams): FunctionBody;

export class TableClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
    value(value: any[]): this;
    headerAppearance(value: AppearanceClass): this;
    rowAppearance(value: AppearanceClass): this;
}
export function UITable(...columns: TableColumnClass[]): TableClass;

export class AccordionClass extends UIView {
    vp_headerTemplate: (option: any) => UIView | Function;
    vp_contentTemplate: (option: any) => UIView | Function;
    vp_items: any[];
    vp_ActiveIndex: int;
    setController(controller: UIController): this;
    constructor();
    headerTemplate(value: (option: any) => UIView | Function): this;
    contentTemplate(value: (option: any) => UIView | Function): this;
    items(value: any[]): this;
}

export class UIMediaPlayerClass extends UIView {
    url(value: string): this;
    previewImage(value: string): this;
    logo(value: string): this;
    playing(value: boolean): this;
    onProgress(value: Function): this;
    onEnded(value: Function): this;
    setController(controller: UIController): this;
    constructor();
}

export interface UIChartOptions {
        annotations?: TuvalAnnotations;
        chart?: TuvalChart;
        colors?: any[];
        dataLabels?: TuvalDataLabels;
        fill?: TuvalFill;
        forecastDataPoints?: TuvalForecastDataPoints;
        grid?: TuvalGrid;
        labels?: string[];
        legend?: TuvalLegend;
        markers?: TuvalMarkers;
        noData?: TuvalNoData;
        plotOptions?: TuvalPlotOptions;
        responsive?: TuvalResponsive[];
        series?: TuvalAxisChartSeries | TuvalNonAxisChartSeries;
        states?: TuvalStates;
        stroke?: TuvalStroke;
        subtitle?: TuvalTitleSubtitle;
        theme?: TuvalTheme;
        title?: TuvalTitleSubtitle;
        tooltip?: TuvalTooltip;
        xaxis?: TuvalXAxis;
        yaxis?: TuvalYAxis | TuvalYAxis[];
}
export type TuvalDropShadow = {
        enabled?: boolean;
        top?: number;
        left?: number;
        blur?: number;
        opacity?: number;
        color?: string;
};
export type TuvalChart = {
        width?: string | number;
        height?: string | number;
        type?: 'line' | 'area' | 'bar' | 'histogram' | 'pie' | 'donut' | 'radialBar' | 'scatter' | 'bubble' | 'heatmap' | 'candlestick' | 'boxPlot' | 'radar' | 'polarArea' | 'rangeBar' | 'treemap';
        foreColor?: string;
        fontFamily?: string;
        background?: string;
        offsetX?: number;
        offsetY?: number;
        dropShadow?: TuvalDropShadow & {
                enabledOnSeries?: undefined | number[];
                color?: string | string[];
        };
        events?: {
                animationEnd?(chart: any, options?: any): void;
                beforeMount?(chart: any, options?: any): void;
                mounted?(chart: any, options?: any): void;
                updated?(chart: any, options?: any): void;
                mouseMove?(e: any, chart?: any, options?: any): void;
                mouseLeave?(e: any, chart?: any, options?: any): void;
                click?(e: any, chart?: any, options?: any): void;
                legendClick?(chart: any, seriesIndex?: number, options?: any): void;
                markerClick?(e: any, chart?: any, options?: any): void;
                selection?(chart: any, options?: any): void;
                dataPointSelection?(e: any, chart?: any, options?: any): void;
                dataPointMouseEnter?(e: any, chart?: any, options?: any): void;
                dataPointMouseLeave?(e: any, chart?: any, options?: any): void;
                beforeZoom?(chart: any, options?: any): void;
                beforeResetZoom?(chart: any, options?: any): void;
                zoomed?(chart: any, options?: any): void;
                scrolled?(chart: any, options?: any): void;
                brushScrolled?(chart: any, options?: any): void;
        };
        brush?: {
                enabled?: boolean;
                autoScaleYaxis?: boolean;
                target?: string;
        };
        id?: string;
        group?: string;
        locales?: TuvalLocale[];
        defaultLocale?: string;
        parentHeightOffset?: number;
        redrawOnParentResize?: boolean;
        redrawOnWindowResize?: boolean | Function;
        sparkline?: {
                enabled?: boolean;
        };
        stacked?: boolean;
        stackType?: 'normal' | '100%';
        toolbar?: {
                show?: boolean;
                offsetX?: number;
                offsetY?: number;
                tools?: {
                        download?: boolean | string;
                        selection?: boolean | string;
                        zoom?: boolean | string;
                        zoomin?: boolean | string;
                        zoomout?: boolean | string;
                        pan?: boolean | string;
                        reset?: boolean | string;
                        customIcons?: {
                                icon?: string;
                                title?: string;
                                index?: number;
                                class?: string;
                                click?(chart?: any, options?: any, e?: any): any;
                        }[];
                };
                export?: {
                        csv?: {
                                filename?: undefined | string;
                                columnDelimiter?: string;
                                headerCategory?: string;
                                headerValue?: string;
                                dateFormatter?(timestamp?: number): any;
                        };
                        svg?: {
                                filename?: undefined | string;
                        };
                        png?: {
                                filename?: undefined | string;
                        };
                };
                autoSelected?: 'zoom' | 'selection' | 'pan';
        };
        zoom?: {
                enabled?: boolean;
                type?: 'x' | 'y' | 'xy';
                autoScaleYaxis?: boolean;
                zoomedArea?: {
                        fill?: {
                                color?: string;
                                opacity?: number;
                        };
                        stroke?: {
                                color?: string;
                                opacity?: number;
                                width?: number;
                        };
                };
        };
        selection?: {
                enabled?: boolean;
                type?: string;
                fill?: {
                        color?: string;
                        opacity?: number;
                };
                stroke?: {
                        width?: number;
                        color?: string;
                        opacity?: number;
                        dashArray?: number;
                };
                xaxis?: {
                        min?: number;
                        max?: number;
                };
                yaxis?: {
                        min?: number;
                        max?: number;
                };
        };
        animations?: {
                enabled?: boolean;
                easing?: 'linear' | 'easein' | 'easeout' | 'easeinout';
                speed?: number;
                animateGradually?: {
                        enabled?: boolean;
                        delay?: number;
                };
                dynamicAnimation?: {
                        enabled?: boolean;
                        speed?: number;
                };
        };
};
export type TuvalStates = {
        normal?: {
                filter?: {
                        type?: string;
                        value?: number;
                };
        };
        hover?: {
                filter?: {
                        type?: string;
                        value?: number;
                };
        };
        active?: {
                allowMultipleDataPointsSelection?: boolean;
                filter?: {
                        type?: string;
                        value?: number;
                };
        };
};
export type TuvalTitleSubtitle = {
        text?: string;
        align?: 'left' | 'center' | 'right';
        margin?: number;
        offsetX?: number;
        offsetY?: number;
        floating?: boolean;
        style?: {
                fontSize?: string;
                fontFamily?: string;
                fontWeight?: string | number;
                color?: string;
        };
};
export type TuvalAxisChartSeries = {
        name?: string;
        type?: string;
        color?: string;
        data: (number | null)[] | {
                x: any;
                y: any;
                fillColor?: string;
                strokeColor?: string;
                meta?: any;
                goals?: any;
        }[] | [number, number | null][] | [number, (number | null)[]][];
}[];
export type TuvalNonAxisChartSeries = number[];
type TuvalStroke = {
        show?: boolean;
        curve?: 'smooth' | 'straight' | 'stepline' | ('smooth' | 'straight' | 'stepline')[];
        lineCap?: 'butt' | 'square' | 'round';
        colors?: string[];
        width?: number | number[];
        dashArray?: number | number[];
        fill?: TuvalFill;
};
type TuvalAnnotations = {
        position?: string;
        yaxis?: YAxisAnnotations[];
        xaxis?: XAxisAnnotations[];
        points?: PointAnnotations[];
        texts?: TextAnnotations[];
        images?: ImageAnnotations[];
};
type AnnotationLabel = {
        borderColor?: string;
        borderWidth?: number;
        borderRadius?: number;
        text?: string;
        textAnchor?: string;
        offsetX?: number;
        offsetY?: number;
        style?: AnnotationStyle;
        position?: string;
        orientation?: string;
        mouseEnter?: Function;
        mouseLeave?: Function;
        click?: Function;
};
type AnnotationStyle = {
        background?: string;
        color?: string;
        fontFamily?: string;
        fontWeight?: string | number;
        fontSize?: string;
        cssClass?: string;
        padding?: {
                left?: number;
                right?: number;
                top?: number;
                bottom?: number;
        };
};
type XAxisAnnotations = {
        id?: number | string;
        x?: null | number | string;
        x2?: null | number | string;
        strokeDashArray?: number;
        fillColor?: string;
        borderColor?: string;
        borderWidth?: number;
        opacity?: number;
        offsetX?: number;
        offsetY?: number;
        label?: AnnotationLabel;
};
type YAxisAnnotations = {
        id?: number | string;
        y?: null | number | string;
        y2?: null | number | string;
        strokeDashArray?: number;
        fillColor?: string;
        borderColor?: string;
        borderWidth?: number;
        opacity?: number;
        offsetX?: number;
        offsetY?: number;
        width?: number | string;
        yAxisIndex?: number;
        label?: AnnotationLabel;
};
type PointAnnotations = {
        id?: number | string;
        x?: number | string;
        y?: null | number;
        yAxisIndex?: number;
        seriesIndex?: number;
        mouseEnter?: Function;
        mouseLeave?: Function;
        click?: Function;
        marker?: {
                size?: number;
                fillColor?: string;
                strokeColor?: string;
                strokeWidth?: number;
                shape?: string;
                offsetX?: number;
                offsetY?: number;
                radius?: number;
                cssClass?: string;
        };
        label?: AnnotationLabel;
        image?: {
                path?: string;
                width?: number;
                height?: number;
                offsetX?: number;
                offsetY?: number;
        };
};
type TextAnnotations = {
        x?: number;
        y?: number;
        text?: string;
        textAnchor?: string;
        foreColor?: string;
        fontSize?: string | number;
        fontFamily?: undefined | string;
        fontWeight?: string | number;
        backgroundColor?: string;
        borderColor?: string;
        borderRadius?: number;
        borderWidth?: number;
        paddingLeft?: number;
        paddingRight?: number;
        paddingTop?: number;
        paddingBottom?: number;
};
type ImageAnnotations = {
        path?: string;
        x?: number;
        y?: number;
        width?: number;
        height?: number;
};
/**
    * Options for localization.
    * See https://apexcharts.com/docs/options/chart/locales
    */
type TuvalLocale = {
        name?: string;
        options?: {
                months?: string[];
                shortMonths?: string[];
                days?: string[];
                shortDays?: string[];
                toolbar?: {
                        download?: string;
                        selection?: string;
                        selectionZoom?: string;
                        zoomIn?: string;
                        zoomOut?: string;
                        pan?: string;
                        reset?: string;
                        exportToSVG?: string;
                        exportToPNG?: string;
                        exportToCSV: string;
                };
        };
};
/**
    * PlotOptions for specifying chart-type-specific configuration.
    * See https://apexcharts.com/docs/options/plotoptions/bar/
    */
type TuvalPlotOptions = {
        area?: {
                fillTo?: 'origin' | 'end';
        };
        bar?: {
                horizontal?: boolean;
                columnWidth?: string;
                barHeight?: string;
                distributed?: boolean;
                borderRadius?: number | number[];
                rangeBarOverlap?: boolean;
                rangeBarGroupRows?: boolean;
                colors?: {
                        ranges?: {
                                from?: number;
                                to?: number;
                                color?: string;
                        }[];
                        backgroundBarColors?: string[];
                        backgroundBarOpacity?: number;
                        backgroundBarRadius?: number;
                };
                dataLabels?: {
                        maxItems?: number;
                        hideOverflowingLabels?: boolean;
                        position?: string;
                        orientation?: 'horizontal' | 'vertical';
                };
        };
        bubble?: {
                minBubbleRadius?: number;
                maxBubbleRadius?: number;
        };
        candlestick?: {
                colors?: {
                        upward?: string;
                        downward?: string;
                };
                wick?: {
                        useFillColor?: boolean;
                };
        };
        boxPlot?: {
                colors?: {
                        upper?: string;
                        lower?: string;
                };
        };
        heatmap?: {
                radius?: number;
                enableShades?: boolean;
                shadeIntensity?: number;
                reverseNegativeShade?: boolean;
                distributed?: boolean;
                useFillColorAsStroke?: boolean;
                colorScale?: {
                        ranges?: {
                                from?: number;
                                to?: number;
                                color?: string;
                                foreColor?: string;
                                name?: string;
                        }[];
                        inverse?: boolean;
                        min?: number;
                        max?: number;
                };
        };
        treemap?: {
                enableShades?: boolean;
                shadeIntensity?: number;
                distributed?: boolean;
                reverseNegativeShade?: boolean;
                useFillColorAsStroke?: boolean;
                colorScale?: {
                        inverse?: boolean;
                        ranges?: {
                                from?: number;
                                to?: number;
                                color?: string;
                                foreColor?: string;
                                name?: string;
                        }[];
                        min?: number;
                        max?: number;
                };
        };
        pie?: {
                startAngle?: number;
                endAngle?: number;
                customScale?: number;
                offsetX?: number;
                offsetY?: number;
                expandOnClick?: boolean;
                dataLabels?: {
                        offset?: number;
                        minAngleToShowLabel?: number;
                };
                donut?: {
                        size?: string;
                        background?: string;
                        labels?: {
                                show?: boolean;
                                name?: {
                                        show?: boolean;
                                        fontSize?: string;
                                        fontFamily?: string;
                                        fontWeight?: string | number;
                                        color?: string;
                                        offsetY?: number;
                                        formatter?(val: string): string;
                                };
                                value?: {
                                        show?: boolean;
                                        fontSize?: string;
                                        fontFamily?: string;
                                        fontWeight?: string | number;
                                        color?: string;
                                        offsetY?: number;
                                        formatter?(val: string): string;
                                };
                                total?: {
                                        show?: boolean;
                                        showAlways?: boolean;
                                        fontFamily?: string;
                                        fontWeight?: string | number;
                                        fontSize?: string;
                                        label?: string;
                                        color?: string;
                                        formatter?(w: any): string;
                                };
                        };
                };
        };
        polarArea?: {
                rings?: {
                        strokeWidth?: number;
                        strokeColor?: string;
                };
                spokes?: {
                        strokeWidth?: number;
                        connectorColors?: string | string[];
                };
        };
        radar?: {
                size?: number;
                offsetX?: number;
                offsetY?: number;
                polygons?: {
                        strokeColors?: string | string[];
                        strokeWidth?: string | string[];
                        connectorColors?: string | string[];
                        fill?: {
                                colors?: string[];
                        };
                };
        };
        radialBar?: {
                inverseOrder?: boolean;
                startAngle?: number;
                endAngle?: number;
                offsetX?: number;
                offsetY?: number;
                hollow?: {
                        margin?: number;
                        size?: string;
                        background?: string;
                        image?: string;
                        imageWidth?: number;
                        imageHeight?: number;
                        imageOffsetX?: number;
                        imageOffsetY?: number;
                        imageClipped?: boolean;
                        position?: 'front' | 'back';
                        dropShadow?: TuvalDropShadow;
                };
                track?: {
                        show?: boolean;
                        startAngle?: number;
                        endAngle?: number;
                        background?: string;
                        strokeWidth?: string;
                        opacity?: number;
                        margin?: number;
                        dropShadow?: TuvalDropShadow;
                };
                dataLabels?: {
                        show?: boolean;
                        name?: {
                                show?: boolean;
                                fontFamily?: string;
                                fontWeight?: string | number;
                                fontSize?: string;
                                color?: string;
                                offsetY?: number;
                        };
                        value?: {
                                show?: boolean;
                                fontFamily?: string;
                                fontSize?: string;
                                fontWeight?: string | number;
                                color?: string;
                                offsetY?: number;
                                formatter?(val: number): string;
                        };
                        total?: {
                                show?: boolean;
                                label?: string;
                                color?: string;
                                fontFamily?: string;
                                fontWeight?: string | number;
                                fontSize?: string;
                                formatter?(opts: any): string;
                        };
                };
        };
};
type TuvalFill = {
        colors?: any[];
        opacity?: number | number[];
        type?: string | string[];
        gradient?: {
                shade?: string;
                type?: string;
                shadeIntensity?: number;
                gradientToColors?: string[];
                inverseColors?: boolean;
                opacityFrom?: number | number[];
                opacityTo?: number | number[];
                stops?: number[];
                colorStops?: any[];
        };
        image?: {
                src?: string | string[];
                width?: number;
                height?: number;
        };
        pattern?: {
                style?: string | string[];
                width?: number;
                height?: number;
                strokeWidth?: number;
        };
};
/**
    * Chart Legend configuration options.
    * See https://apexcharts.com/docs/options/legend/
    */
type TuvalLegend = {
        show?: boolean;
        showForSingleSeries?: boolean;
        showForNullSeries?: boolean;
        showForZeroSeries?: boolean;
        floating?: boolean;
        inverseOrder?: boolean;
        position?: 'top' | 'right' | 'bottom' | 'left';
        horizontalAlign?: 'left' | 'center' | 'right';
        fontSize?: string;
        fontFamily?: string;
        fontWeight?: string | number;
        width?: number;
        height?: number;
        offsetX?: number;
        offsetY?: number;
        formatter?(legendName: string, opts?: any): string;
        tooltipHoverFormatter?(legendName: string, opts?: any): string;
        textAnchor?: string;
        customLegendItems?: string[];
        labels?: {
                colors?: string | string[];
                useSeriesColors?: boolean;
        };
        markers?: {
                width?: number;
                height?: number;
                strokeColor?: string;
                strokeWidth?: number;
                fillColors?: string[];
                offsetX?: number;
                offsetY?: number;
                radius?: number;
                customHTML?(): any;
                onClick?(): void;
        };
        itemMargin?: {
                horizontal?: number;
                vertical?: number;
        };
        containerMargin?: {
                left?: number;
                top?: number;
        };
        onItemClick?: {
                toggleDataSeries?: boolean;
        };
        onItemHover?: {
                highlightDataSeries?: boolean;
        };
};
type TuvalMarkerShape = "circle" | "square" | "rect" | string[];
type TuvalDiscretePoint = {
        seriesIndex?: number;
        dataPointIndex?: number;
        fillColor?: string;
        strokeColor?: string;
        size?: number;
        shape?: TuvalMarkerShape;
};
type TuvalMarkers = {
        size?: number | number[];
        colors?: string | string[];
        strokeColors?: string | string[];
        strokeWidth?: number | number[];
        strokeOpacity?: number | number[];
        strokeDashArray?: number | number[];
        fillOpacity?: number | number[];
        discrete?: TuvalDiscretePoint[];
        shape?: TuvalMarkerShape;
        width?: number | number[];
        height?: number | number[];
        radius?: number;
        offsetX?: number;
        offsetY?: number;
        showNullDataPoints?: boolean;
        onClick?(e?: any): void;
        onDblClick?(e?: any): void;
        hover?: {
                size?: number;
                sizeOffset?: number;
        };
};
type TuvalNoData = {
        text?: string;
        align?: 'left' | 'right' | 'center';
        verticalAlign?: 'top' | 'middle' | 'bottom';
        offsetX?: number;
        offsetY?: number;
        style?: {
                color?: string;
                fontSize?: string;
                fontFamily?: string;
        };
};
/**
    * Chart Datalabels options
    * See https://apexcharts.com/docs/options/datalabels/
    */
type TuvalDataLabels = {
        enabled?: boolean;
        enabledOnSeries?: undefined | number[];
        textAnchor?: 'start' | 'middle' | 'end';
        distributed?: boolean;
        offsetX?: number;
        offsetY?: number;
        style?: {
                fontSize?: string;
                fontFamily?: string;
                fontWeight?: string | number;
                colors?: any[];
        };
        background?: {
                enabled?: boolean;
                foreColor?: string;
                borderRadius?: number;
                padding?: number;
                opacity?: number;
                borderWidth?: number;
                borderColor?: string;
                dropShadow: TuvalDropShadow;
        };
        dropShadow?: TuvalDropShadow;
        formatter?(val: string | number | number[], opts?: any): string | number;
};
type TuvalResponsive = {
        breakpoint?: number;
        options?: any;
};
type TuvalTooltipY = {
        title?: {
                formatter?(seriesName: string): string;
        };
        formatter?(val: number, opts?: any): string;
};
/**
    * Chart Tooltip options
    * See https://apexcharts.com/docs/options/tooltip/
    */
type TuvalTooltip = {
        enabled?: boolean;
        enabledOnSeries?: undefined | number[];
        shared?: boolean;
        followCursor?: boolean;
        intersect?: boolean;
        inverseOrder?: boolean;
        custom?: ((options: any) => any) | ((options: any) => any)[];
        fillSeriesColor?: boolean;
        theme?: string;
        cssClass?: string;
        style?: {
                fontSize?: string;
                fontFamily?: string;
        };
        onDatasetHover?: {
                highlightDataSeries?: boolean;
        };
        x?: {
                show?: boolean;
                format?: string;
                formatter?(val: number, opts?: any): string;
        };
        y?: TuvalTooltipY | TuvalTooltipY[];
        z?: {
                title?: string;
                formatter?(val: number): string;
        };
        marker?: {
                show?: boolean;
                fillColors?: string[];
        };
        items?: {
                display?: string;
        };
        fixed?: {
                enabled?: boolean;
                position?: string;
                offsetX?: number;
                offsetY?: number;
        };
};
/**
    * X Axis options
    * See https://apexcharts.com/docs/options/xaxis/
    */
type TuvalXAxis = {
        type?: 'category' | 'datetime' | 'numeric';
        categories?: any;
        overwriteCategories?: number[] | string[] | undefined;
        offsetX?: number;
        offsetY?: number;
        sorted?: boolean;
        labels?: {
                show?: boolean;
                rotate?: number;
                rotateAlways?: boolean;
                hideOverlappingLabels?: boolean;
                showDuplicates?: boolean;
                trim?: boolean;
                minHeight?: number;
                maxHeight?: number;
                style?: {
                        colors?: string | string[];
                        fontSize?: string;
                        fontFamily?: string;
                        fontWeight?: string | number;
                        cssClass?: string;
                };
                offsetX?: number;
                offsetY?: number;
                format?: string;
                formatter?(value: string, timestamp?: number, opts?: any): string | string[];
                datetimeUTC?: boolean;
                datetimeFormatter?: {
                        year?: string;
                        month?: string;
                        day?: string;
                        hour?: string;
                        minute?: string;
                };
        };
        group?: {
                groups?: {
                        title: string;
                        cols: number;
                }[];
                style?: {
                        colors?: string | string[];
                        fontSize?: string;
                        fontFamily?: string;
                        fontWeight?: string | number;
                        cssClass?: string;
                };
        };
        axisBorder?: {
                show?: boolean;
                color?: string;
                offsetX?: number;
                offsetY?: number;
                strokeWidth?: number;
        };
        axisTicks?: {
                show?: boolean;
                borderType?: string;
                color?: string;
                height?: number;
                offsetX?: number;
                offsetY?: number;
        };
        tickPlacement?: string;
        tickAmount?: number | 'dataPoints';
        min?: number;
        max?: number;
        range?: number;
        floating?: boolean;
        decimalsInFloat?: number;
        position?: string;
        title?: {
                text?: string;
                offsetX?: number;
                offsetY?: number;
                style?: {
                        color?: string;
                        fontFamily?: string;
                        fontWeight?: string | number;
                        fontSize?: string;
                        cssClass?: string;
                };
        };
        crosshairs?: {
                show?: boolean;
                width?: number | string;
                position?: string;
                opacity?: number;
                stroke?: {
                        color?: string;
                        width?: number;
                        dashArray?: number;
                };
                fill?: {
                        type?: string;
                        color?: string;
                        gradient?: {
                                colorFrom?: string;
                                colorTo?: string;
                                stops?: number[];
                                opacityFrom?: number;
                                opacityTo?: number;
                        };
                };
                dropShadow?: TuvalDropShadow;
        };
        tooltip?: {
                enabled?: boolean;
                offsetY?: number;
                formatter?(value: string, opts?: object): string;
                style?: {
                        fontSize?: string;
                        fontFamily?: string;
                };
        };
};
/**
    * Y Axis options
    * See https://apexcharts.com/docs/options/yaxis/
    */
type TuvalYAxis = {
        show?: boolean;
        showAlways?: boolean;
        showForNullSeries?: boolean;
        seriesName?: string;
        opposite?: boolean;
        reversed?: boolean;
        logarithmic?: boolean;
        logBase?: number;
        tickAmount?: number;
        forceNiceScale?: boolean;
        min?: number | ((min: number) => number);
        max?: number | ((max: number) => number);
        floating?: boolean;
        decimalsInFloat?: number;
        labels?: {
                show?: boolean;
                minWidth?: number;
                maxWidth?: number;
                offsetX?: number;
                offsetY?: number;
                rotate?: number;
                align?: 'left' | 'center' | 'right';
                padding?: number;
                style?: {
                        colors?: string | string[];
                        fontSize?: string;
                        fontWeight?: string | number;
                        fontFamily?: string;
                        cssClass?: string;
                };
                formatter?(val: number, opts?: any): string | string[];
        };
        axisBorder?: {
                show?: boolean;
                color?: string;
                width?: number;
                offsetX?: number;
                offsetY?: number;
        };
        axisTicks?: {
                show?: boolean;
                color?: string;
                width?: number;
                offsetX?: number;
                offsetY?: number;
        };
        title?: {
                text?: string;
                rotate?: number;
                offsetX?: number;
                offsetY?: number;
                style?: {
                        color?: string;
                        fontSize?: string;
                        fontWeight?: string | number;
                        fontFamily?: string;
                        cssClass?: string;
                };
        };
        crosshairs?: {
                show?: boolean;
                position?: string;
                stroke?: {
                        color?: string;
                        width?: number;
                        dashArray?: number;
                };
        };
        tooltip?: {
                enabled?: boolean;
                offsetX?: number;
        };
};
type TuvalForecastDataPoints = {
        count?: number;
        fillOpacity?: number;
        strokeWidth?: undefined | number;
        dashArray: number;
};
/**
    * Plot X and Y grid options
    * See https://apexcharts.com/docs/options/grid/
    */
type TuvalGrid = {
        show?: boolean;
        borderColor?: string;
        strokeDashArray?: number;
        position?: 'front' | 'back';
        xaxis?: {
                lines?: {
                        show?: boolean;
                        offsetX?: number;
                        offsetY?: number;
                };
        };
        yaxis?: {
                lines?: {
                        show?: boolean;
                        offsetX?: number;
                        offsetY?: number;
                };
        };
        row?: {
                colors?: string[];
                opacity?: number;
        };
        column?: {
                colors?: string[];
                opacity?: number;
        };
        padding?: {
                top?: number;
                right?: number;
                bottom?: number;
                left?: number;
        };
};
type TuvalTheme = {
        mode?: 'light' | 'dark';
        palette?: string;
        monochrome?: {
                enabled?: boolean;
                color?: string;
                shadeTo?: 'light' | 'dark';
                shadeIntensity?: number;
        };
};
export {};

export function UIChart(): ChartClass;

export type TypographyFunc = (text: string) => TypographyClass;
export function Typography({ variant }: {
    variant: string;
}): TypographyFunc;

export type UIProgressBarTemplate = (value: int) => UIView;
export function UIProgressBar(viewTemplate: UIProgressBarTemplate): UIProgressBarClass;
export function UIProgressBar(): UIProgressBarClass;

export type ButtonTemplate = (...subViews: (UIView | IControl | UIController)[]) => ButtonView;
export function Button(props: IButtonProps): ButtonTemplate;
export function Button(...subViews: (UIView | IControl | UIController)[]): ButtonView;

export class UIChipClass extends UIView {
    vp_PlaceHolder: string;
    placeholder(value: string): this;
    vp_Value: string[];
    value(value: string[]): this;
    vp_OnChange: Function;
    onChange(value: Function): this;
    setController(controller: UIController): this;
    constructor();
}

export class UISidebarClass extends UIView {
    vp_SiodebarPosition: string;
    siodebarPosition(value: string): this;
    vp_Visible: boolean;
    visible(value: boolean): this;
    vp_OnHide: Function;
    onHide(value: Function): this;
    setController(controller: UIController): this;
    constructor();
}

export class UIDesktopClass extends UIView {
    vp_Desktop: Desktop;
    setController(controller: UIController): this;
    constructor();
}

export interface IRadioButton {
    value: string;
    label: string;
}
export class RadioGroupClass extends UIView {
    vp_RadioButtons: IRadioButton[];
    radioButtons(value: IRadioButton[]): this;
    vp_OnChange: Function;
    onChange(value: Function): this;
    setController(controller: UIController): this;
    constructor();
}

export class DynamicViewClass extends UIView {
    vp_Node: any;
    node(value: any): this;
    setController(controller: UIController): this;
    constructor();
}

export function _DataContext(...content: UIView[]): DataContextClass;
export function DataContext(content: () => UIView | Function): DataContextClass;

export class DataContextClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    vp_DataProvider: any;
    dataProvider(value: any): this;
    vp_QueryClient: any;
    queryClient(value: any): this;
}

export function _RecordContext(...content: UIView[]): RecordContextClass;
export function UIRecordContext(content: (data?: any) => UIView | Function): RecordContextClass;

export class RecordContextClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    vp_Content: Function;
    _content(value: Function): this;
    vp_Resource: string;
    resource(value: string): this;
    vp_Filter: any;
    filter(value: any): this;
}

export function UICreateContext(content: (create?: Function, isLoading?: boolean, isSuccess?: boolean) => UIView | Function): CreateContextClass;

export class CreateContextClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    vp_Content: Function;
    _content(value: Function): this;
    vp_Resource: string;
    resource(value: string): this;
    vp_Filter: any;
    filter(value: any): this;
}

const _default: (name: InternalFieldName, validateAllFieldCriteria: boolean, errors: InternalFieldErrors, type: string, message: ValidateResult) => {};
export default _default;

export type ControllerFieldState = {
        /**
            * @deprecated check `fieldState.error` instead
            * ```jsx
            * {fieldState.error && <p>{fieldState.error.message}</p>}
            * ```
            */
        invalid: boolean;
        isTouched: boolean;
        isDirty: boolean;
        error?: FieldError;
};
export type ControllerRenderProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
        onChange: (...event: any[]) => void;
        onBlur: Noop;
        value: FieldPathValue<TFieldValues, TName>;
        name: TName;
        ref: RefCallBack;
};
export type UseControllerProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
        name: TName;
        rules?: Omit<RegisterOptions<TFieldValues, TName>, 'valueAsNumber' | 'valueAsDate' | 'setValueAs' | 'disabled'>;
        shouldUnregister?: boolean;
        defaultValue?: FieldPathValue<TFieldValues, TName>;
        control?: Form_Control<TFieldValues>;
};
export type UseControllerReturn<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
        field: ControllerRenderProps<TFieldValues, TName>;
        formState: UseFormStateReturn<TFieldValues>;
        fieldState: ControllerFieldState;
};
/**
    * Render function to provide the control for the field.
    *
    * @returns all the event handler, and relevant field and form state.
    *
    * @example
    * ```tsx
    * const { field, fieldState, formState } = useController();
    *
    * <Controller
    *   render={({ field, formState, fieldState }) => ({
    *     <input
    *       onChange={field.onChange}
    *       onBlur={field.onBlur}
    *       name={field.name}
    *       ref={field.ref} // optional for focus management
    *     />
    *   })}
    * />
    * ```
    */
export type ControllerProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
        render: ({ field, fieldState, formState, }: {
                field: ControllerRenderProps<TFieldValues, TName>;
                fieldState: ControllerFieldState;
                formState: UseFormStateReturn<TFieldValues>;
        }) => any;
} & UseControllerProps<TFieldValues, TName>;

export type Message = string;
export type MultipleFieldErrors = {
    [K in keyof RegisterOptions]?: ValidateResult;
} & {
    [key: string]: ValidateResult;
};
export type FieldError = {
    type: LiteralUnion<keyof RegisterOptions, string>;
    root?: FieldError;
    ref?: Form_Ref;
    types?: MultipleFieldErrors;
    message?: Message;
};
export type ErrorOption = {
    message?: Message;
    type?: LiteralUnion<keyof RegisterOptions, string>;
    types?: MultipleFieldErrors;
};
export type DeepRequired<T> = T extends BrowserNativeObject | Blob ? T : {
    [K in keyof T]-?: NonNullable<DeepRequired<T[K]>>;
};
export type FieldErrorsImpl<T extends FieldValues = FieldValues> = {
    [K in keyof T]?: T[K] extends BrowserNativeObject | Blob ? FieldError : T[K] extends object ? Merge<FieldError, FieldErrorsImpl<T[K]>> : FieldError;
};
export type FieldErrors<T extends FieldValues = FieldValues> = Partial<FieldValues extends IsAny<FieldValues> ? any : FieldErrorsImpl<DeepRequired<T>>>;
export type InternalFieldErrors = Partial<Record<InternalFieldName, FieldError>>;

export type EventType = 'focus' | 'blur' | 'change' | 'changeText' | 'valueChange' | 'contentSizeChange' | 'endEditing' | 'keyPress' | 'submitEditing' | 'layout' | 'selectionChange' | 'longPress' | 'press' | 'pressIn' | 'pressOut' | 'momentumScrollBegin' | 'momentumScrollEnd' | 'scroll' | 'scrollBeginDrag' | 'scrollEndDrag' | 'load' | 'error' | 'progress' | 'custom';

export type UseFieldArrayProps<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>, TKeyName extends string = 'id'> = {
        name: TFieldArrayName;
        keyName?: TKeyName;
        control?: Form_Control<TFieldValues>;
        rules?: {
                validate?: Validate<FieldArray<TFieldValues, TFieldArrayName>[]> | Record<string, Validate<FieldArray<TFieldValues, TFieldArrayName>[]>>;
        } & Pick<RegisterOptions<TFieldValues>, 'maxLength' | 'minLength' | 'required'>;
        shouldUnregister?: boolean;
};
/**
    * `useFieldArray` returned `fields` with unique id
    */
export type FieldArrayWithId<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>, TKeyName extends string = 'id'> = FieldArray<TFieldValues, TFieldArrayName> & Record<TKeyName, string>;
export type FieldArray<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = FieldArrayPathValue<TFieldValues, TFieldArrayName> extends ReadonlyArray<infer U> | null | undefined ? U : never;
/**
    * `useFieldArray` focus option, ability to toggle focus on and off with `shouldFocus` and setting focus by either field index or name.
    */
export type FieldArrayMethodProps = {
        shouldFocus?: boolean;
        focusIndex?: number;
        focusName?: string;
};
/**
    * Swap field array by supplying from and to index
    *
    * @remarks
    * [API](https://react-hook-form.com/api/usefieldarray)  [Demo](https://codesandbox.io/s/calc-i231d)
    *
    * @param indexA - from index
    * @param indexB - to index
    *
    * @example
    * ```tsx
    * <button type="button" onClick={() => swap(0, 1)}>swap</button>
    * ```
    */
export type UseFieldArraySwap = (indexA: number, indexB: number) => void;
/**
    * Move field array by supplying from and to index
    *
    * @remarks
    * [API](https://react-hook-form.com/api/usefieldarray)  [Demo](https://codesandbox.io/s/calc-i231d)
    *
    * @param indexA - from index
    * @param indexB - to index
    *
    * @example
    * ```tsx
    * <button type="button" onClick={() => move(0, 1)}>swap</button>
    * ```
    */
export type UseFieldArrayMove = (indexA: number, indexB: number) => void;
/**
    * Prepend field/fields to the start of the fields and optionally focus. The input value will be registered during this action.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/usefieldarray)  [Demo](https://codesandbox.io/s/calc-i231d)
    *
    * @param value - prepend items or items
    * @param options - focus options
    *
    * @example
    * ```tsx
    * <button type="button" onClick={() => prepend({ name: "data" })}>Prepend</button>
    * <button type="button" onClick={() => prepend({ name: "data" }, { shouldFocus: false })}>Prepend</button>
    * <button
    *   type="button"
    *   onClick={() => prepend([{ name: "data" }, { name: "data" }])}
    * >
    *   Prepend
    * </button>
    * ```
    */
export type UseFieldArrayPrepend<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (value: FieldArray<TFieldValues, TFieldArrayName> | FieldArray<TFieldValues, TFieldArrayName>[], options?: FieldArrayMethodProps) => void;
/**
    * Append field/fields to the end of your fields and focus. The input value will be registered during this action.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/usefieldarray)  [Demo](https://codesandbox.io/s/calc-i231d)
    *
    * @param value - append items or items.
    * @param options - focus options
    *
    * @example
    * ```tsx
    * <button type="button" onClick={() => append({ name: "data" })}>Append</button>
    * <button type="button" onClick={() => append({ name: "data" }, { shouldFocus: false })}>Append</button>
    * <button
    *   type="button"
    *   onClick={() => append([{ name: "data" }, { name: "data" }])}
    * >
    *   Append
    * </button>
    * ```
    */
export type UseFieldArrayAppend<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (value: FieldArray<TFieldValues, TFieldArrayName> | FieldArray<TFieldValues, TFieldArrayName>[], options?: FieldArrayMethodProps) => void;
/**
    * Remove field/fields at particular position.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/usefieldarray)  [Demo](https://codesandbox.io/s/calc-i231d)
    *
    * @param index - index to remove at, or remove all when no index provided.
    *
    * @example
    * ```tsx
    * <button type="button" onClick={() => remove(0)}>Remove</button>
    * <button
    *   type="button"
    *   onClick={() => remove()}
    * >
    *   Remove all
    * </button>
    * ```
    */
export type UseFieldArrayRemove = (index?: number | number[]) => void;
/**
    * Insert field/fields at particular position and focus.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/usefieldarray)  [Demo](https://codesandbox.io/s/calc-i231d)
    *
    * @param index - insert position
    * @param value - insert field or fields
    * @param options - focus options
    *
    * @example
    * ```tsx
    * <button type="button" onClick={() => insert(1, { name: "data" })}>Insert</button>
    * <button type="button" onClick={() => insert(1, { name: "data" }, { shouldFocus: false })}>Insert</button>
    * <button
    *   type="button"
    *   onClick={() => insert(1, [{ name: "data" }, { name: "data" }])}
    * >
    *   Insert
    * </button>
    * ```
    */
export type UseFieldArrayInsert<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (index: number, value: FieldArray<TFieldValues, TFieldArrayName> | FieldArray<TFieldValues, TFieldArrayName>[], options?: FieldArrayMethodProps) => void;
/**
    * Update field/fields at particular position.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/usefieldarray)  [Demo](https://codesandbox.io/s/calc-i231d)
    *
    * @param index - insert position
    * @param value - insert field or fields
    *
    * @example
    * ```tsx
    * <button type="button" onClick={() => update(1, { name: "data" })}>Update</button>
    * <button
    *   type="button"
    *   onClick={() => update(1, [{ name: "data" }, { name: "data" }])}
    * >
    *   Update
    * </button>
    * ```
    */
export type UseFieldArrayUpdate<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (index: number, value: FieldArray<TFieldValues, TFieldArrayName>) => void;
/**
    * Replace the entire field array values.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/usefieldarray)  [Demo](https://codesandbox.io/s/calc-i231d)
    *
    * @param value - the entire field values.
    *
    * @example
    * ```tsx
    * <button
    *   type="button"
    *   onClick={() => update([{ name: "data" }, { name: "data" }])}
    * >
    *   Replace
    * </button>
    * ```
    */
export type UseFieldArrayReplace<TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>> = (value: FieldArray<TFieldValues, TFieldArrayName> | FieldArray<TFieldValues, TFieldArrayName>[]) => void;
export type UseFieldArrayReturn<TFieldValues extends FieldValues = FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>, TKeyName extends string = 'id'> = {
        swap: UseFieldArraySwap;
        move: UseFieldArrayMove;
        prepend: UseFieldArrayPrepend<TFieldValues, TFieldArrayName>;
        append: UseFieldArrayAppend<TFieldValues, TFieldArrayName>;
        remove: UseFieldArrayRemove;
        insert: UseFieldArrayInsert<TFieldValues, TFieldArrayName>;
        update: UseFieldArrayUpdate<TFieldValues, TFieldArrayName>;
        replace: UseFieldArrayReplace<TFieldValues, TFieldArrayName>;
        fields: FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>[];
};

export type InternalFieldName = string;
export type FieldName<TFieldValues extends FieldValues> = IsFlatObject<TFieldValues> extends true ? Extract<keyof TFieldValues, string> : string;
export type CustomElement<TFieldValues extends FieldValues> = {
    name: FieldName<TFieldValues>;
    type?: string;
    value?: any;
    disabled?: boolean;
    checked?: boolean;
    options?: HTMLOptionsCollection;
    files?: FileList | null;
    focus?: Noop;
};
export type FieldValue<TFieldValues extends FieldValues> = TFieldValues[InternalFieldName];
export type FieldValues = Record<string, any>;
export type NativeFieldValue = string | number | boolean | null | undefined | unknown[];
export type FieldElement<TFieldValues extends FieldValues = FieldValues> = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement | CustomElement<TFieldValues>;
export type Form_Ref = FieldElement;
export type Field = {
    _f: {
        ref: Form_Ref;
        name: InternalFieldName;
        refs?: HTMLInputElement[];
        mount?: boolean;
    } & RegisterOptions;
};
export type FieldRefs = Partial<Record<InternalFieldName, Field>>;

const $NestedValue: unique symbol;
/**
    * @deprecated to be removed in the next major version
    */
export type NestedValue<TValue extends object = object> = {
        [$NestedValue]: never;
} & TValue;
/**
    * @deprecated to be removed in the next major version
    */
export type UnpackNestedValue<T> = T extends NestedValue<infer U> ? U : T extends Date | FileList | File | Blob ? T : T extends object ? {
        [K in keyof T]: UnpackNestedValue<T[K]>;
} : T;
export type DefaultValues<TFieldValues> = DeepPartial<TFieldValues>;
export type InternalNameSet = Set<InternalFieldName>;
export type ValidationMode = {
        onBlur: 'onBlur';
        onChange: 'onChange';
        onSubmit: 'onSubmit';
        onTouched: 'onTouched';
        all: 'all';
};
export type Mode = keyof ValidationMode;
export type CriteriaMode = 'firstError' | 'all';
export type SubmitHandler<TFieldValues extends FieldValues> = (data: TFieldValues, event?: any) => any | Promise<any>;
export type SubmitErrorHandler<TFieldValues extends FieldValues> = (errors: FieldErrors<TFieldValues>, event?: any) => any | Promise<any>;
export type SetValueConfig = Partial<{
        shouldValidate: boolean;
        shouldDirty: boolean;
        shouldTouch: boolean;
}>;
export type TriggerConfig = Partial<{
        shouldFocus: boolean;
}>;
export type ChangeHandler = (event: {
        target: any;
        type?: any;
}) => Promise<void | boolean>;
export type DelayCallback = (wait: number) => void;
export type UseFormProps<TFieldValues extends FieldValues = FieldValues, TContext = any> = Partial<{
        mode: Mode;
        reValidateMode: Exclude<Mode, 'onTouched' | 'all'>;
        defaultValues: DefaultValues<TFieldValues>;
        resolver: Resolver<TFieldValues, TContext>;
        context: TContext;
        shouldFocusError: boolean;
        shouldUnregister: boolean;
        shouldUseNativeValidation: boolean;
        criteriaMode: CriteriaMode;
        delayError: number;
}>;
export type FieldNamesMarkedBoolean<TFieldValues extends FieldValues> = DeepMap<DeepPartial<TFieldValues>, boolean>;
export type FormStateProxy<TFieldValues extends FieldValues = FieldValues> = {
        isDirty: boolean;
        isValidating: boolean;
        dirtyFields: FieldNamesMarkedBoolean<TFieldValues>;
        touchedFields: FieldNamesMarkedBoolean<TFieldValues>;
        errors: boolean;
        isValid: boolean;
};
export type ReadFormState = {
        [K in keyof FormStateProxy]: boolean | 'all';
};
export type FormState<TFieldValues extends FieldValues> = {
        isDirty: boolean;
        isSubmitted: boolean;
        isSubmitSuccessful: boolean;
        isSubmitting: boolean;
        isValidating: boolean;
        isValid: boolean;
        submitCount: number;
        defaultValues?: Readonly<DeepPartial<TFieldValues>> | TFieldValues;
        dirtyFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;
        touchedFields: Partial<Readonly<FieldNamesMarkedBoolean<TFieldValues>>>;
        errors: FieldErrors<TFieldValues>;
};
export type KeepStateOptions = Partial<{
        keepDirtyValues: boolean;
        keepErrors: boolean;
        keepDirty: boolean;
        keepValues: boolean;
        keepDefaultValues: boolean;
        keepIsSubmitted: boolean;
        keepTouched: boolean;
        keepIsValid: boolean;
        keepSubmitCount: boolean;
}>;
export type SetFieldValue<TFieldValues extends FieldValues> = FieldValue<TFieldValues>;
export type RefCallBack = (instance: any) => void;
export type UseFormRegisterReturn<TFieldName extends InternalFieldName = InternalFieldName> = {
        onChange: ChangeHandler;
        onBlur: ChangeHandler;
        ref: RefCallBack;
        name: TFieldName;
        min?: string | number;
        max?: string | number;
        maxLength?: number;
        minLength?: number;
        pattern?: string;
        required?: boolean;
        disabled?: boolean;
};
/**
    * Register field into hook form with or without the actual DOM ref. You can invoke register anywhere in the component including at `useEffect`.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/useform/register)  [Demo](https://codesandbox.io/s/react-hook-form-register-ts-ip2j3)  [Video](https://www.youtube.com/watch?v=JFIpCoajYkA)
    *
    * @param name - the path name to the form field value, name is required and unique
    * @param options - register options include validation, disabled, unregister, value as and dependent validation
    *
    * @returns onChange, onBlur, name, ref, and native contribute attribute if browser validation is enabled.
    *
    * @example
    * ```tsx
    * // Register HTML native input
    * <input {...register("input")} />
    * <select {...register("select")} />
    *
    * // Register options
    * <textarea {...register("textarea", { required: "This is required.", maxLength: 20 })} />
    * <input type="number" {...register("name2", { valueAsNumber: true })} />
    * <input {...register("name3", { deps: ["name2"] })} />
    *
    * // Register custom field at useEffect
    * useEffect(() => {
    *   register("name4");
    *   register("name5", { value: '"hiddenValue" });
    * }, [register])
    *
    * // Register without ref
    * const { onChange, onBlur, name } = register("name6")
    * <input onChange={onChange} onBlur={onBlur} name={name} />
    * ```
    */
export type UseFormRegister<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(name: TFieldName, options?: RegisterOptions<TFieldValues, TFieldName>) => UseFormRegisterReturn<TFieldName>;
export type SetFocusOptions = Partial<{
        shouldSelect: boolean;
}>;
/**
    * Set focus on a registered field. You can start to invoke this method after all fields are mounted to the DOM.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/useform/setfocus)  [Demo](https://codesandbox.io/s/setfocus-rolus)
    *
    * @param name - the path name to the form field value.
    * @param options - input focus behavior options
    *
    * @example
    * ```tsx
    * useEffect(() => {
    *   setFocus("name");
    * }, [setFocus])
    * // shouldSelect allows to select input's content on focus
    * <button onClick={() => setFocus("name", { shouldSelect: true })}>Focus</button>
    * ```
    */
export type UseFormSetFocus<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(name: TFieldName, options?: SetFocusOptions) => void;
export type UseFormGetValues<TFieldValues extends FieldValues> = {
        /**
            * Get the entire form values when no argument is supplied to this function.
            *
            * @remarks
            * [API](https://react-hook-form.com/api/useform/getvalues)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-getvalues-txsfg)
            *
            * @returns form values
            *
            * @example
            * ```tsx
            * <button onClick={() => getValues()}>getValues</button>
            *
            * <input {...register("name", {
            *   validate: () => getValues().otherField === "test";
            * })} />
            * ```
            */
        (): TFieldValues;
        /**
            * Get a single field value.
            *
            * @remarks
            * [API](https://react-hook-form.com/api/useform/getvalues)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-getvalues-txsfg)
            *
            * @param name - the path name to the form field value.
            *
            * @returns the single field value
            *
            * @example
            * ```tsx
            * <button onClick={() => getValues("name")}>getValues</button>
            *
            * <input {...register("name", {
            *   validate: () => getValues('otherField') === "test";
            * })} />
            * ```
            */
        <TFieldName extends FieldPath<TFieldValues>>(name: TFieldName): FieldPathValue<TFieldValues, TFieldName>;
        /**
            * Get an array of field values.
            *
            * @remarks
            * [API](https://react-hook-form.com/api/useform/getvalues)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-getvalues-txsfg)
            *
            * @param names - an array of field names
            *
            * @returns An array of field values
            *
            * @example
            * ```tsx
            * <button onClick={() => getValues(["name", "name1"])}>getValues</button>
            *
            * <input {...register("name", {
            *   validate: () => getValues(["fieldA", "fieldB"]).includes("test");
            * })} />
            * ```
            */
        <TFieldNames extends FieldPath<TFieldValues>[]>(names: readonly [...TFieldNames]): [...FieldPathValues<TFieldValues, TFieldNames>];
};
/**
    * This method will return individual field states. It will be useful when you are trying to retrieve the nested value field state in a typesafe approach.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/useform/getfieldstate)  [Demo](https://codesandbox.io/s/getfieldstate-jvekk)
    *
    * @param name - the path name to the form field value.
    *
    * @returns invalid, isDirty, isTouched and error object
    *
    * @example
    * ```tsx
    * // those formState has to be subscribed
    * const { formState: { dirtyFields, errors, touchedFields } } = formState();
    * getFieldState('name')
    * // Get field state when form state is not subscribed yet
    * getFieldState('name', formState)
    *
    * // It's ok to combine with useFormState
    * const formState = useFormState();
    * getFieldState('name')
    * getFieldState('name', formState)
    * ```
    */
export type UseFormGetFieldState<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues>>(name: TFieldName, formState?: FormState<TFieldValues>) => {
        /**
            * @deprecated check `fieldState.error` instead
            * ```jsx
            * {fieldState.error && <p>{fieldState.error.message}</p>}
            * ```
            */
        invalid: boolean;
        isDirty: boolean;
        isTouched: boolean;
        error?: FieldError;
};
export type UseFormWatch<TFieldValues extends FieldValues> = {
        /**
            * Watch and subscribe to the entire form update/change based on onChange and re-render at the useForm.
            *
            * @remarks
            * [API](https://react-hook-form.com/api/useform/watch)  [Demo](https://codesandbox.io/s/react-hook-form-watch-v7-ts-8et1d)  [Video](https://www.youtube.com/watch?v=3qLd69WMqKk)
            *
            * @returns return the entire form values
            *
            * @example
            * ```tsx
            * const formValues = watch();
            * ```
            */
        (): TFieldValues;
        /**
            * Watch and subscribe to an array of fields used outside of render.
            *
            * @remarks
            * [API](https://react-hook-form.com/api/useform/watch)  [Demo](https://codesandbox.io/s/react-hook-form-watch-v7-ts-8et1d)  [Video](https://www.youtube.com/watch?v=3qLd69WMqKk)
            *
            * @param names - an array of field names
            * @param defaultValue - defaultValues for the entire form
            *
            * @returns return an array of field values
            *
            * @example
            * ```tsx
            * const [name, name1] = watch(["name", "name1"]);
            * ```
            */
        <TFieldNames extends readonly FieldPath<TFieldValues>[]>(names: readonly [...TFieldNames], defaultValue?: DeepPartial<TFieldValues>): FieldPathValues<TFieldValues, TFieldNames>;
        /**
            * Watch and subscribe to a single field used outside of render.
            *
            * @remarks
            * [API](https://react-hook-form.com/api/useform/watch)  [Demo](https://codesandbox.io/s/react-hook-form-watch-v7-ts-8et1d)  [Video](https://www.youtube.com/watch?v=3qLd69WMqKk)
            *
            * @param name - the path name to the form field value.
            * @param defaultValue - defaultValues for the entire form
            *
            * @returns return the single field value
            *
            * @example
            * ```tsx
            * const name = watch("name");
            * ```
            */
        <TFieldName extends FieldPath<TFieldValues>>(name: TFieldName, defaultValue?: FieldPathValue<TFieldValues, TFieldName>): FieldPathValue<TFieldValues, TFieldName>;
        /**
            * Subscribe to field update/change without trigger re-render
            *
            * @remarks
            * [API](https://react-hook-form.com/api/useform/watch)  [Demo](https://codesandbox.io/s/react-hook-form-watch-v7-ts-8et1d)  [Video](https://www.youtube.com/watch?v=3qLd69WMqKk)
            *
            * @param callback - call back function to subscribe all fields change and return unsubscribe function
            * @param defaultValues - defaultValues for the entire form
            *
            * @returns unsubscribe function
            *
            * @example
            * ```tsx
            * useEffect(() => {
            *   const { unsubscribe } = watch((value) => {
            *     console.log(value);
            *   });
            *   return () => unsubscribe();
            * }, [watch])
            * ```
            */
        (callback: WatchObserver<TFieldValues>, defaultValues?: DeepPartial<TFieldValues>): Subscription;
};
/**
    * Trigger field or form validation
    *
    * @remarks
    * [API](https://react-hook-form.com/api/useform/trigger)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-triggervalidation-forked-xs7hl)  [Video](https://www.youtube.com/watch?v=-bcyJCDjksE)
    *
    * @param name - provide empty argument will trigger the entire form validation, an array of field names will validate an arrange of fields, and a single field name will only trigger that field's validation.
    * @param options - should focus on the error field
    *
    * @returns validation result
    *
    * @example
    * ```tsx
    * useEffect(() => {
    *   trigger();
    * }, [trigger])
    *
    * <button onClick={async () => {
    *   const result = await trigger(); // result will be a boolean value
    * }}>
    *  trigger
    *  </button>
    * ```
    */
export type UseFormTrigger<TFieldValues extends FieldValues> = (name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[], options?: TriggerConfig) => Promise<boolean>;
/**
    * Clear the entire form errors.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/useform/clearerrors)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-clearerrors-w3ymx)
    *
    * @param name - the path name to the form field value.
    *
    * @example
    * Clear all errors
    * ```tsx
    * clearErrors(); // clear the entire form error
    * clearErrors(["name", "name1"]) // clear an array of fields' error
    * clearErrors("name2"); // clear a single field error
    * ```
    */
export type UseFormClearErrors<TFieldValues extends FieldValues> = (name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[]) => void;
/**
    * Set a single field value, or a group of fields value.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/useform/setvalue)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-setvalue-8z9hx)  [Video](https://www.youtube.com/watch?v=qpv51sCH3fI)
    *
    * @param name - the path name to the form field value.
    * @param value - field value
    * @param options - should validate or update form state
    *
    * @example
    * ```tsx
    * // Update a single field
    * setValue('name', 'value', {
    *   shouldValidate: true, // trigger validation
    *   shouldTouch: true, // update touched fields form state
    *   shouldDirty: true, // update dirty and dirty fields form state
    * });
    *
    * // Update a group fields
    * setValue('root', {
    *   a: 'test', // setValue('root.a', 'data')
    *   b: 'test1', // setValue('root.b', 'data')
    * });
    *
    * // Update a nested object field
    * setValue('select', { label: 'test', value: 'Test' });
    * ```
    */
export type UseFormSetValue<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(name: TFieldName, value: FieldPathValue<TFieldValues, TFieldName>, options?: SetValueConfig) => void;
/**
    * Set an error for the field. When set an error which is not associated to a field then manual `clearErrors` invoke is required.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/useform/seterror)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-seterror-nfxxu)  [Video](https://www.youtube.com/watch?v=raMqvE0YyIY)
    *
    * @param name - the path name to the form field value.
    * @param error - an error object which contains type and optional message
    * @param options - whether or not to focus on the field
    *
    * @example
    * ```tsx
    * // when the error is not associated with any fields, `clearError` will need to invoke to clear the error
    * const onSubmit = () => setError("serverError", { type: "server", message: "Error occurred"})
    *
    * <button onClick={() => setError("name", { type: "min" })} />
    *
    * // focus on the input after setting the error
    * <button onClick={() => setError("name", { type: "max" }, { shouldFocus: true })} />
    * ```
    */
export type UseFormSetError<TFieldValues extends FieldValues> = (name: FieldPath<TFieldValues>, error: ErrorOption, options?: {
        shouldFocus: boolean;
}) => void;
/**
    * Unregister a field reference and remove its value.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/useform/unregister)  [Demo](https://codesandbox.io/s/react-hook-form-unregister-4k2ey)  [Video](https://www.youtube.com/watch?v=TM99g_NW5Gk&feature=emb_imp_woyt)
    *
    * @param name - the path name to the form field value.
    * @param options - keep form state options
    *
    * @example
    * ```tsx
    * register("name", { required: true })
    *
    * <button onClick={() => unregister("name")} />
    * // there are various keep options to retain formState
    * <button onClick={() => unregister("name", { keepErrors: true })} />
    * ```
    */
export type UseFormUnregister<TFieldValues extends FieldValues> = (name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[], options?: Omit<KeepStateOptions, 'keepIsSubmitted' | 'keepSubmitCount' | 'keepValues' | 'keepDefaultValues' | 'keepErrors'> & {
        keepValue?: boolean;
        keepDefaultValue?: boolean;
        keepError?: boolean;
}) => void;
/**
    * Validate the entire form. Handle submit and error callback.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/useform/handlesubmit)  [Demo](https://codesandbox.io/s/react-hook-form-handlesubmit-ts-v7-lcrtu)  [Video](https://www.youtube.com/watch?v=KzcPKB9SOEk)
    *
    * @param onValid - callback function invoked after form pass validation
    * @param onInvalid - callback function invoked when form failed validation
    *
    * @returns callback - return callback function
    *
    * @example
    * ```tsx
    * const onSubmit = (data) => console.log(data);
    * const onError = (error) => console.log(error);
    *
    * <form onSubmit={handleSubmit(onSubmit, onError)} />
    * ```
    */
export type UseFormHandleSubmit<TFieldValues extends FieldValues> = (onValid: SubmitHandler<TFieldValues>, onInvalid?: SubmitErrorHandler<TFieldValues>) => (e?: any) => Promise<void>;
/**
    * Reset a field state and reference.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/useform/resetfield)  [Demo](https://codesandbox.io/s/priceless-firefly-d0kuv)  [Video](https://www.youtube.com/watch?v=IdLFcNaEFEo)
    *
    * @param name - the path name to the form field value.
    * @param options - keep form state options
    *
    * @example
    * ```tsx
    * <input {...register("firstName", { required: true })} />
    * <button type="button" onClick={() => resetField("firstName"))}>Reset</button>
    * ```
    */
export type UseFormResetField<TFieldValues extends FieldValues> = <TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(name: TFieldName, options?: Partial<{
        keepDirty: boolean;
        keepTouched: boolean;
        keepError: boolean;
        defaultValue: any;
}>) => void;
type ResetAction<TFieldValues> = (formValues: TFieldValues) => TFieldValues;
/**
    * Reset at the entire form state.
    *
    * @remarks
    * [API](https://react-hook-form.com/api/useform/reset)  [Demo](https://codesandbox.io/s/react-hook-form-reset-v7-ts-pu901)  [Video](https://www.youtube.com/watch?v=qmCLBjyPwVk)
    *
    * @param values - the entire form values to be reset
    * @param keepStateOptions - keep form state options
    *
    * @example
    * ```tsx
    * useEffect(() => {
    *   // reset the entire form after component mount or form defaultValues is ready
    *   reset({
    *     fieldA: "test"
    *     fieldB: "test"
    *   });
    * }, [reset])
    *
    * // reset by combine with existing form values
    * reset({
    *   ...getValues(),
    *  fieldB: "test"
    *});
    *
    * // reset and keep form state
    * reset({
    *   ...getValues(),
    *}, {
    *   keepErrors: true,
    *   keepDirty: true
    *});
    * ```
    */
export type UseFormReset<TFieldValues extends FieldValues> = (values?: DefaultValues<TFieldValues> | TFieldValues | ResetAction<TFieldValues>, keepStateOptions?: KeepStateOptions) => void;
export type WatchInternal<TFieldValues> = (fieldNames?: InternalFieldName | InternalFieldName[], defaultValue?: DeepPartial<TFieldValues>, isMounted?: boolean, isGlobal?: boolean) => FieldPathValue<FieldValues, InternalFieldName> | FieldPathValues<FieldValues, InternalFieldName[]>;
export type GetIsDirty = <TName extends InternalFieldName, TData>(name?: TName, data?: TData) => boolean;
export type FormStateSubjectRef<TFieldValues extends FieldValues> = Subject<Partial<FormState<TFieldValues>> & {
        name?: InternalFieldName;
}>;
export type Subjects<TFieldValues extends FieldValues = FieldValues> = {
        watch: Subject<{
                name?: InternalFieldName;
                type?: EventType;
                values?: FieldValues;
        }>;
        array: Subject<{
                name?: InternalFieldName;
                values?: FieldValues;
        }>;
        state: FormStateSubjectRef<TFieldValues>;
};
export type Names = {
        mount: InternalNameSet;
        unMount: InternalNameSet;
        array: InternalNameSet;
        watch: InternalNameSet;
        focus: InternalFieldName;
        watchAll: boolean;
};
export type BatchFieldArrayUpdate = <T extends Function, TFieldValues extends FieldValues, TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>>(name: InternalFieldName, updatedFieldArrayValues?: Partial<FieldArray<TFieldValues, TFieldArrayName>>[], method?: T, args?: Partial<{
        argA: unknown;
        argB: unknown;
}>, shouldSetValue?: boolean, shouldUpdateFieldsAndErrors?: boolean) => void;
export type Form_Control<TFieldValues extends FieldValues = FieldValues, TContext = any> = {
        _subjects: Subjects<TFieldValues>;
        _removeUnmounted: Noop;
        _focusError: Noop;
        _names: Names;
        _stateFlags: {
                mount: boolean;
                action: boolean;
                watch: boolean;
        };
        _options: UseFormProps<TFieldValues, TContext>;
        _getDirty: GetIsDirty;
        _formState: FormState<TFieldValues>;
        _updateValid: Noop;
        _fields: FieldRefs;
        _formValues: FieldValues;
        _proxyFormState: ReadFormState;
        _defaultValues: Partial<DefaultValues<TFieldValues>>;
        _getWatch: WatchInternal<TFieldValues>;
        _updateFieldArray: BatchFieldArrayUpdate;
        _getFieldArray: <TFieldArrayValues>(name: InternalFieldName) => Partial<TFieldArrayValues>[];
        _executeSchema: (names: InternalFieldName[]) => Promise<{
                errors: FieldErrors;
        }>;
        register: UseFormRegister<TFieldValues>;
        unregister: UseFormUnregister<TFieldValues>;
        getFieldState: UseFormGetFieldState<TFieldValues>;
};
export type WatchObserver<TFieldValues extends FieldValues> = (value: DeepPartial<TFieldValues>, info: {
        name?: FieldPath<TFieldValues>;
        type?: EventType;
        value?: unknown;
}) => void;
export type UseFormReturn<TFieldValues extends FieldValues = FieldValues, TContext = any> = {
        watch: UseFormWatch<TFieldValues>;
        getValues: UseFormGetValues<TFieldValues>;
        getFieldState: UseFormGetFieldState<TFieldValues>;
        setError: UseFormSetError<TFieldValues>;
        clearErrors: UseFormClearErrors<TFieldValues>;
        setValue: UseFormSetValue<TFieldValues>;
        trigger: UseFormTrigger<TFieldValues>;
        formState: FormState<TFieldValues>;
        resetField: UseFormResetField<TFieldValues>;
        reset: UseFormReset<TFieldValues>;
        handleSubmit: UseFormHandleSubmit<TFieldValues>;
        unregister: UseFormUnregister<TFieldValues>;
        control: Form_Control<TFieldValues, TContext>;
        register: UseFormRegister<TFieldValues>;
        setFocus: UseFormSetFocus<TFieldValues>;
};
export type UseFormStateProps<TFieldValues extends FieldValues> = Partial<{
        control?: Form_Control<TFieldValues>;
        disabled?: boolean;
        name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[];
        exact?: boolean;
}>;
export type UseFormStateReturn<TFieldValues extends FieldValues> = FormState<TFieldValues>;
export type UseWatchProps<TFieldValues extends FieldValues = FieldValues> = {
        defaultValue?: unknown;
        disabled?: boolean;
        name?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[];
        control?: Form_Control<TFieldValues>;
        exact?: boolean;
};
export type FormProviderProps<TFieldValues extends FieldValues = FieldValues, TContext = any> = {
        children: any | any[];
} & UseFormReturn<TFieldValues, TContext>;
export {};

/** Re-export public API */

export type ResolverSuccess<TFieldValues extends FieldValues = FieldValues> = {
    values: TFieldValues;
    errors: {};
};
export type ResolverError<TFieldValues extends FieldValues = FieldValues> = {
    values: {};
    errors: FieldErrors<TFieldValues>;
};
export type ResolverResult<TFieldValues extends FieldValues = FieldValues> = ResolverSuccess<TFieldValues> | ResolverError<TFieldValues>;
export interface ResolverOptions<TFieldValues extends FieldValues> {
    criteriaMode?: CriteriaMode;
    fields: Record<InternalFieldName, Field['_f']>;
    names?: FieldName<TFieldValues>[];
    shouldUseNativeValidation: boolean | undefined;
}
export type Resolver<TFieldValues extends FieldValues = FieldValues, TContext = any> = (values: TFieldValues, context: TContext | undefined, options: ResolverOptions<TFieldValues>) => Promise<ResolverResult<TFieldValues>> | ResolverResult<TFieldValues>;

export type Noop = () => void;
interface File extends Blob {
        readonly lastModified: number;
        readonly name: string;
}
interface FileList {
        readonly length: number;
        item(index: number): File | null;
        [index: number]: File;
}
export type Primitive = null | undefined | string | number | boolean | symbol | bigint;
export type BrowserNativeObject = Date | FileList | File;
export type EmptyObject = {
        [K in string | number]: never;
};
export type NonUndefined<T> = T extends undefined ? never : T;
export type LiteralUnion<T extends U, U extends Primitive> = T | (U & {
        _?: never;
});
export type DeepPartial<T> = T extends BrowserNativeObject | NestedValue ? T : {
        [K in keyof T]?: DeepPartial<T[K]>;
};
export type DeepPartialSkipArrayKey<T> = T extends BrowserNativeObject | NestedValue ? T : T extends ReadonlyArray<any> ? {
        [K in keyof T]: DeepPartialSkipArrayKey<T[K]>;
} : {
        [K in keyof T]?: DeepPartialSkipArrayKey<T[K]>;
};
/**
    * Checks whether the type is any
    * See {@link https://stackoverflow.com/a/49928360/3406963}
    * @typeParam T - type which may be any
    * ```
    * IsAny<any> = true
    * IsAny<string> = false
    * ```
    */
export type IsAny<T> = 0 extends 1 & T ? true : false;
/**
    * Checks whether the type is never
    * @typeParam T - type which may be never
    * ```
    * IsAny<never> = true
    * IsAny<string> = false
    * ```
    */
export type IsNever<T> = [T] extends [never] ? true : false;
export type DeepMap<T, TValue> = IsAny<T> extends true ? any : T extends BrowserNativeObject | NestedValue ? TValue : T extends object ? {
        [K in keyof T]: DeepMap<NonUndefined<T[K]>, TValue>;
} : TValue;
export type IsFlatObject<T extends object> = Extract<Exclude<T[keyof T], NestedValue | Date | FileList>, any[] | object> extends never ? true : false;
export type Merge<A, B> = {
        [K in keyof A | keyof B]?: K extends keyof A & keyof B ? [A[K], B[K]] extends [object, object] ? Merge<A[K], B[K]> : A[K] | B[K] : K extends keyof A ? A[K] : K extends keyof B ? B[K] : never;
};
export {};

export type ValidationValue = boolean | number | string | RegExp;
export type ValidationRule<TValidationValue extends ValidationValue = ValidationValue> = TValidationValue | ValidationValueMessage<TValidationValue>;
export type ValidationValueMessage<TValidationValue extends ValidationValue = ValidationValue> = {
    value: TValidationValue;
    message: Message;
};
export type ValidateResult = Message | Message[] | boolean | undefined;
export type Validate<TFieldValue> = (value: TFieldValue) => ValidateResult | Promise<ValidateResult>;
export type RegisterOptions<TFieldValues extends FieldValues = FieldValues, TFieldName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = Partial<{
    required: Message | ValidationRule<boolean>;
    min: ValidationRule<number | string>;
    max: ValidationRule<number | string>;
    maxLength: ValidationRule<number>;
    minLength: ValidationRule<number>;
    pattern: ValidationRule<RegExp>;
    validate: Validate<FieldPathValue<TFieldValues, TFieldName>> | Record<string, Validate<FieldPathValue<TFieldValues, TFieldName>>>;
    valueAsNumber: boolean;
    valueAsDate: boolean;
    value: FieldPathValue<TFieldValues, TFieldName>;
    setValueAs: (value: any) => any;
    shouldUnregister?: boolean;
    onChange?: (event: any) => void;
    onBlur?: (event: any) => void;
    disabled: boolean;
    deps: InternalFieldName | InternalFieldName[];
}>;

const _default: <T>(obj: T, path: string, defaultValue?: unknown) => any;
export default _default;

export default function set(object: FieldValues, path: string, value?: unknown): FieldValues;

global {
    interface Window {
        ReactQueryClientContext?: any | undefined;
    }
}
export const useQueryClient: () => any;
export interface QueryClientProviderProps {
    client: QueryClient;
    contextSharing?: boolean;
}
export const QueryClientProvider: any;

interface QueryErrorResetBoundaryValue {
    clearReset: () => void;
    isReset: () => boolean;
    reset: () => void;
}
export const useQueryErrorResetBoundary: () => any;
export interface QueryErrorResetBoundaryProps {
    children: ((value: QueryErrorResetBoundaryValue) => any) | any;
}
export const QueryErrorResetBoundary: any;
export {};

export function useIsFetching(filters?: QueryFilters): number;
export function useIsFetching(queryKey?: QueryKey, filters?: QueryFilters): number;

export function useIsMutating(filters?: MutationFilters): number;
export function useIsMutating(queryKey?: QueryKey, filters?: MutationFilters): number;

export function useMutation<TData = unknown, TError = unknown, TVariables = void, TContext = unknown>(options: UseMutationOptions<TData, TError, TVariables, TContext>): UseMutationResult<TData, TError, TVariables, TContext>;
export function useMutation(mutationFn: any, options?: any): any;
export function useMutation<TData = unknown, TError = unknown, TVariables = void, TContext = unknown>(mutationKey: MutationKey, options?: Omit<UseMutationOptions<TData, TError, TVariables, TContext>, 'mutationKey'>): UseMutationResult<TData, TError, TVariables, TContext>;
export function useMutation<TData = unknown, TError = unknown, TVariables = void, TContext = unknown>(mutationKey: MutationKey, mutationFn?: MutationFunction<TData, TVariables>, options?: Omit<UseMutationOptions<TData, TError, TVariables, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<TData, TError, TVariables, TContext>;

export function useQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>): UseQueryResult<TData, TError>;
export function useQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(queryKey: TQueryKey, options?: Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'queryKey'>): UseQueryResult<TData, TError>;
export function useQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(queryKey: TQueryKey, queryFn: QueryFunction<TQueryFnData, TQueryKey>, options?: Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'queryKey' | 'queryFn'>): UseQueryResult<TData, TError>;

type MAXIMUM_DEPTH = 20;
type GetOptions<T extends any> = T extends {
        queryFnData: infer TQueryFnData;
        error?: infer TError;
        data: infer TData;
} ? UseQueryOptions<TQueryFnData, TError, TData> : T extends {
        queryFnData: infer TQueryFnData;
        error?: infer TError;
} ? UseQueryOptions<TQueryFnData, TError> : T extends {
        data: infer TData;
        error?: infer TError;
} ? UseQueryOptions<unknown, TError, TData> : T extends [infer TQueryFnData, infer TError, infer TData] ? UseQueryOptions<TQueryFnData, TError, TData> : T extends [infer TQueryFnData, infer TError] ? UseQueryOptions<TQueryFnData, TError> : T extends [infer TQueryFnData] ? UseQueryOptions<TQueryFnData> : T extends {
        queryFn?: QueryFunction<infer TQueryFnData>;
        select: (data: any) => infer TData;
} ? UseQueryOptions<TQueryFnData, unknown, TData> : T extends {
        queryFn?: QueryFunction<infer TQueryFnData>;
} ? UseQueryOptions<TQueryFnData> : UseQueryOptions;
type GetResults<T> = T extends {
        queryFnData: any;
        error?: infer TError;
        data: infer TData;
} ? UseQueryResult<TData, TError> : T extends {
        queryFnData: infer TQueryFnData;
        error?: infer TError;
} ? UseQueryResult<TQueryFnData, TError> : T extends {
        data: infer TData;
        error?: infer TError;
} ? UseQueryResult<TData, TError> : T extends [any, infer TError, infer TData] ? UseQueryResult<TData, TError> : T extends [infer TQueryFnData, infer TError] ? UseQueryResult<TQueryFnData, TError> : T extends [infer TQueryFnData] ? UseQueryResult<TQueryFnData> : T extends {
        queryFn?: QueryFunction<any>;
        select: (data: any) => infer TData;
} ? UseQueryResult<TData> : T extends {
        queryFn?: QueryFunction<infer TQueryFnData>;
} ? UseQueryResult<TQueryFnData> : UseQueryResult;
/**
    * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param
    */
type QueriesOptions<T extends any[], Result extends any[] = [], Depth extends ReadonlyArray<number> = []> = Depth['length'] extends MAXIMUM_DEPTH ? UseQueryOptions[] : T extends [] ? [] : T extends [infer Head] ? [...Result, GetOptions<Head>] : T extends [infer Head, ...infer Tail] ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]> : unknown[] extends T ? T : T extends UseQueryOptions<infer TQueryFnData, infer TError, infer TData>[] ? UseQueryOptions<TQueryFnData, TError, TData>[] : UseQueryOptions[];
/**
    * QueriesResults reducer recursively maps type param to results
    */
type QueriesResults<T extends any[], Result extends any[] = [], Depth extends ReadonlyArray<number> = []> = Depth['length'] extends MAXIMUM_DEPTH ? UseQueryResult[] : T extends [] ? [] : T extends [infer Head] ? [...Result, GetResults<Head>] : T extends [infer Head, ...infer Tail] ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]> : T extends UseQueryOptions<infer TQueryFnData, infer TError, infer TData>[] ? UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[] : UseQueryResult[];
export function useQueries<T extends any[]>(queries: readonly [...QueriesOptions<T>]): QueriesResults<T>;
export {};

export function useInfiniteQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(options: UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>): UseInfiniteQueryResult<TData, TError>;
export function useInfiniteQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(queryKey: TQueryKey, options?: Omit<UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>, 'queryKey'>): UseInfiniteQueryResult<TData, TError>;
export function useInfiniteQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(queryKey: TQueryKey, queryFn: QueryFunction<TQueryFnData, TQueryKey>, options?: Omit<UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>, 'queryKey' | 'queryFn'>): UseInfiniteQueryResult<TData, TError>;

export function useHydrate(state: unknown, options?: HydrateOptions): void;
export interface HydrateProps {
    state?: unknown;
    options?: HydrateOptions;
}
export const Hydrate: any;

export interface UseBaseQueryOptions<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey> {
}
export interface UseQueryOptions<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends UseBaseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey> {
}
export interface UseInfiniteQueryOptions<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey> {
}
export type UseBaseQueryResult<TData = unknown, TError = unknown> = QueryObserverResult<TData, TError>;
export type UseQueryResult<TData = unknown, TError = unknown> = UseBaseQueryResult<TData, TError>;
export type UseInfiniteQueryResult<TData = unknown, TError = unknown> = InfiniteQueryObserverResult<TData, TError>;
export interface UseMutationOptions<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> {
    mutationFn?: MutationFunction<TData, TVariables>;
    mutationKey?: MutationKey;
    onMutate?: (variables: TVariables) => Promise<TContext | undefined> | TContext | undefined;
    onSuccess?: (data: TData, variables: TVariables, context: TContext | undefined) => Promise<unknown> | void;
    onError?: (error: TError, variables: TVariables, context: TContext | undefined) => Promise<unknown> | void;
    onSettled?: (data: TData | undefined, error: TError | null, variables: TVariables, context: TContext | undefined) => Promise<unknown> | void;
    retry?: RetryValue<TError>;
    retryDelay?: RetryDelayValue<TError>;
    useErrorBoundary?: boolean | ((error: TError) => boolean);
}
export type UseMutateFunction<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> = (variables: TVariables, options?: MutateOptions<TData, TError, TVariables, TContext>) => void;
export type UseMutateAsyncFunction<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> = (variables: TVariables, options?: MutateOptions<TData, TError, TVariables, TContext>) => Promise<TData>;
export type UseBaseMutationResult<TData = unknown, TError = unknown, TVariables = unknown, TContext = unknown> = Override<MutationObserverResult<TData, TError, TVariables, TContext>, {
    mutate: UseMutateFunction<TData, TError, TVariables, TContext>;
}> & {
    mutateAsync: UseMutateAsyncFunction<TData, TError, TVariables, TContext>;
};
export type UseMutationResult<TData = unknown, TError = unknown, TVariables = unknown, TContext = unknown> = UseBaseMutationResult<TData, TError, TVariables, TContext>;
type Override<A, B> = {
    [K in keyof A]: K extends keyof B ? B[K] : A[K];
};
export {};

export const GET_LIST = "GET_LIST";
export const GET_ONE = "GET_ONE";
export const GET_MANY = "GET_MANY";
export const GET_MANY_REFERENCE = "GET_MANY_REFERENCE";
export const CREATE = "CREATE";
export const UPDATE = "UPDATE";
export const UPDATE_MANY = "UPDATE_MANY";
export const DELETE = "DELETE";
export const DELETE_MANY = "DELETE_MANY";
export const fetchActionsWithRecordResponse: string[];
export const fetchActionsWithArrayOfIdentifiedRecordsResponse: string[];
export const fetchActionsWithArrayOfRecordsResponse: string[];
export const fetchActionsWithTotalResponse: string[];
export const reactAdminFetchActions: string[];
export const sanitizeFetchType: (fetchType: string) => string;

export const defaultDataProvider: {
    create: () => Promise<{
        data: any;
    }>;
    delete: () => Promise<{
        data: any;
    }>;
    deleteMany: () => Promise<{
        data: any[];
    }>;
    getList: () => Promise<{
        data: any[];
        total: number;
    }>;
    getMany: () => Promise<{
        data: any[];
    }>;
    getManyReference: () => Promise<{
        data: any[];
        total: number;
    }>;
    getOne: () => Promise<{
        data: any;
    }>;
    update: () => Promise<{
        data: any;
    }>;
    updateMany: () => Promise<{
        data: any[];
    }>;
};

export const _useDataProvider: () => any;
export const useDataProvider: () => any;

/**
  * Maps react-admin queries to a json-server powered REST API
  *
  * @see https://github.com/typicode/json-server
  *
  * @example
  *
  * getList          => GET http://my.api.url/posts?_sort=title&_order=ASC&_start=0&_end=24
  * getOne           => GET http://my.api.url/posts/123
  * getManyReference => GET http://my.api.url/posts?author_id=345
  * getMany          => GET http://my.api.url/posts?id=123&id=456&id=789
  * create           => POST http://my.api.url/posts/123
  * update           => PUT http://my.api.url/posts/123
  * updateMany       => PUT http://my.api.url/posts/123, PUT http://my.api.url/posts/456, PUT http://my.api.url/posts/789
  * delete           => DELETE http://my.api.url/posts/123
  *
  * @example
  *
  * import * as React from "react";
  * import { Admin, Resource } from 'react-admin';
  * import jsonServerProvider from 'ra-data-json-server';
  *
  * import { PostList } from './posts';
  *
  * const App = () => (
  *     <Admin dataProvider={jsonServerProvider('http://jsonplaceholder.typicode.com')}>
  *         <Resource name="posts" list={PostList} />
  *     </Admin>
  * );
  *
  * export default App;
  */
export const WebApiDataProvider: (apiUrl: any, httpClient?: (url: any, options?: fetchUtils.Options) => Promise<{
    status: number;
    headers: Headers;
    body: string;
    json: any;
}>) => any;

/**
  * Call the dataProvider.getList() method and return the resolved result
  * as well as the loading state.
  *
  * The return value updates according to the request state:
  *
  * - start: { isLoading: true, refetch }
  * - success: { data: [data from store], total: [total from response], isLoading: false, refetch }
  * - error: { error: [error from response], isLoading: false, refetch }
  *
  * This hook will return the cached result when called a second time
  * with the same parameters, until the response arrives.
  *
  * @param {string} resource The resource name, e.g. 'posts'
  * @param {Params} params The getList parameters { pagination, sort, filter, meta }
  * @param {Object} options Options object to pass to the queryClient.
  * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }
  *
  * @typedef Params
  * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }
  * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }
  * @prop params.filter The request filters, e.g. { title: 'hello, world' }
  * @prop params.meta Optional meta parameters
  *
  * @returns The current request state. Destructure as { data, total, error, isLoading, refetch }.
  *
  * @example
  *
  * import { useGetList } from 'react-admin';
  *
  * const LatestNews = () => {
  *     const { data, total, isLoading, error } = useGetList(
  *         'posts',
  *         { pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }
  *     );
  *     if (isLoading) { return <Loading />; }
  *     if (error) { return <p>ERROR</p>; }
  *     return <ul>{data.map(item =>
  *         <li key={item.id}>{item.title}</li>
  *     )}</ul>;
  * };
  */
export const useGetList: (resource: string, params?: Partial<any>, options?: any) => any;
export type UseGetListHookValue = any & {
    total?: number;
    pageInfo?: {
        hasNextPage?: boolean;
        hasPreviousPage?: boolean;
    };
};

/**
  * Call the dataProvider.getOne() method and return the resolved value
  * as well as the loading state.
  *
  * The return value updates according to the request state:
  *
  * - start: { isLoading: true, isFetching: true, refetch }
  * - success: { data: [data from response], isLoading: false, refetch }
  * - error: { error: [error from response], isLoading: false, refetch }
  *
  * This hook will return the cached result when called a second time
  * with the same parameters, until the response arrives.
  *
  * @param resource The resource name, e.g. 'posts'
  * @param {Params} params The getOne parameters { id, meta }, e.g. { id: 123 }
  * @param {Options} options Options object to pass to the react-query queryClient.
  *
  * @typedef Params
  * @prop id a resource identifier, e.g. 123
  *
  * @typedef Options
  * @prop enabled Flag to conditionally run the query. If it's false, the query will not run
  * @prop onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }
  * @prop onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }
  *
  * @returns The current request state. Destructure as { data, error, isLoading, refetch }.
  *
  * @example
  *
  * import { useGetOne } from 'react-admin';
  *
  * const UserProfile = ({ record }) => {
  *     const { data, isLoading, error } = useGetOne('users', { id: record.id });
  *     if (isLoading) { return <Loading />; }
  *     if (error) { return <p>ERROR</p>; }
  *     return <div>User {data.username}</div>;
  * };
  */
export const useGetOne: (resource: string, { id, meta }: any, options?: any) => any;

/**
  * Get a callback to call the dataProvider.create() method, the result and the loading state.
  *
  * @param {string} resource
  * @param {Params} params The create parameters { data }
  * @param {Object} options Options object to pass to the queryClient.
  * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }
  *
  * @typedef Params
  * @prop params.data The record to create, e.g. { title: 'hello, world' }
  *
  * @returns The current mutation state. Destructure as [create, { data, error, isLoading }].
  *
  * The return value updates according to the request state:
  *
  * - initial: [create, { isLoading: false, isIdle: true }]
  * - start:   [create, { isLoading: true }]
  * - success: [create, { data: [data from response], isLoading: false, isSuccess: true }]
  * - error:   [create, { error: [error from response], isLoading: false, isError: true }]
  *
  * The create() function must be called with a resource and a parameter object: create(resource, { data, meta }, options)
  *
  * This hook uses react-query useMutation under the hood.
  * This means the state object contains mutate, isIdle, reset and other react-query methods.
  *
  * @see https://react-query-v3.tanstack.com/reference/useMutation
  *
  * @example // set params when calling the create callback
  *
  * import { useCreate, useRecordContext } from 'react-admin';
  *
  * const LikeButton = () => {
  *     const record = useRecordContext();
  *     const like = { postId: record.id };
  *     const [create, { isLoading, error }] = useCreate();
  *     const handleClick = () => {
  *         create('likes', { data: like })
  *     }
  *     if (error) { return <p>ERROR</p>; }
  *     return <button disabled={isLoading} onClick={handleClick}>Like</button>;
  * };
  *
  * @example // set params when calling the hook
  *
  * import { useCreate, useRecordContext } from 'react-admin';
  *
  * const LikeButton = () => {
  *     const record = useRecordContext();
  *     const like = { postId: record.id };
  *     const [create, { isLoading, error }] = useCreate('likes', { data: like });
  *     if (error) { return <p>ERROR</p>; }
  *     return <button disabled={isLoading} onClick={() => create()}>Like</button>;
  * };
  *
  * @example // TypeScript
  * const [create, { data }] = useCreate<Product>('products', { data: product });
  *                    \-- data is Product
  */
export const useCreate: (resource?: string, params?: any, options?: any) => any;

/**
    * Context to store a record.
    *
    * @see RecordContextProvider
    * @see useRecordContext
    */
export const RecordContext: {
        _id: any;
        _defaultValue: any;
        Consumer(props: any, contextValue: any): any;
        Provider(props: any): any;
};
/**
    * Provider for the Record Context, to store a record.
    *
    * Use the useRecordContext() hook to read the context.
    * That's what the Edit and Show components do in react-admin.
    *
    * Many react-admin components read the RecordContext, including all Field
    * components.
    *
    * @example
    *
    * import { useGetOne, RecordContextProvider } from 'ra-core';
    *
    * const Show = ({ resource, id }) => {
    *     const { data } = useGetOne(resource, { id });
    *     return (
    *         <RecordContextProvider value={data}>
    *             ...
    *         </RecordContextProvider>
    *     );
    * };
    */
export const RecordContextProvider: ({ children, value, }: any) => any;
export interface RecordContextProviderProps<RecordType> {
        children: any;
        value?: RecordType;
}

/**
  * Hook to read the record from a RecordContext.
  *
  * Must be used within a <RecordContext> such as provided by the <EditContextProvider>
  * (e.g. as a descendent of <Edit> or <EditBase>) or within a <ShowContextProvider>
  * (e.g. as a descendent of <Show> or <ShowBase>)
  *
  * @example // basic usage
  *
  * import { useRecordContext } from 'ra-core';
  *
  * const TitleField = () => {
  *     const record = useRecordContext();
  *     return <span>{record && record.title}</span>;
  * };
  *
  * @example // allow record override via props
  *
  * import { useRecordContext } from 'ra-core';
  *
  * const TitleField = (props) => {
  *     const record = useRecordContext(props);
  *     return <span>{record && record.title}</span>;
  * };
  * render(<TextField record={record} />);
  *
  * @returns {RaRecord} A record object
  */
export const useRecordContext: (props?: any) => any | undefined;

/**
  * Render prop version of useRecordContext
  *
  * @example
  * const BookShow = () => (
  *    <Show>
  *       <SimpleShowLayout>
  *          <WithRecord render={record => <span>{record.title}</span>} />
  *      </SimpleShowLayout>
  *   </Show>
  * );
  */
export const WithRecord: <RecordType extends unknown>({ render, }: WithRecordProps<RecordType>) => any;
export interface WithRecordProps<RecordType extends any> {
    render: (record: RecordType) => any;
    label?: string;
}

/**
  * Wrap children with a RecordContext provider only if the value is defined.
  *
  * Allows a component to work outside of a record context.
  *
  * @example
  *
  * import { OptionalRecordContextProvider, TextField } from 'react-admin';
  *
  * const RecordTitle = ({ record }) => (
  *     <OptionalRecordContextProvider value={record}>
  *         <TextField source="title" />
  *     </OptionalRecordContextProvider>
  * );
  */
export const OptionalRecordContextProvider: ({ value, children, }: {
    children: any;
    value?: any;
}) => any;

export interface MemoryRouterProps {
        basename?: string;
        children?: any;
        initialEntries?: InitialEntry[];
        initialIndex?: number;
}
/**
    * A <Router> that stores all entries in memory.
    *
    * @see https://reactrouter.com/docs/en/v6/api#memoryrouter
    */
export function MemoryRouter({ basename, children, initialEntries, initialIndex, }: MemoryRouterProps): any;
export interface NavigateProps {
        to: To;
        replace?: boolean;
        state?: any;
}
/**
    * Changes the current location.
    *
    * Note: This API is mostly useful in React.Component subclasses that are not
    * able to use hooks. In functional components, we recommend you use the
    * `useNavigate` hook instead.
    *
    * @see https://reactrouter.com/docs/en/v6/api#navigate
    */
export function Navigate({ to, replace, state }: NavigateProps): null;
export interface OutletProps {
        context?: unknown;
}
/**
    * Renders the child route's element, if there is one.
    *
    * @see https://reactrouter.com/docs/en/v6/api#outlet
    */
export function Outlet(props: OutletProps): any | null;
export interface RouteProps {
        caseSensitive?: boolean;
        children?: any;
        element?: any | null;
        index?: boolean;
        path?: string;
}
export interface PathRouteProps {
        caseSensitive?: boolean;
        children?: any;
        element?: any | null;
        index?: false;
        path: string;
}
export interface LayoutRouteProps {
        children?: any;
        element?: any | null;
}
export interface IndexRouteProps {
        element?: any | null;
        index: true;
}
/**
    * Declares an element that should be rendered at a certain URL path.
    *
    * @see https://reactrouter.com/docs/en/v6/api#route
    */
export function Route(_props: PathRouteProps | LayoutRouteProps | IndexRouteProps): any | null;
export interface RouterProps {
        basename?: string;
        children?: any;
        location: Partial<Location> | string;
        navigationType?: NavigationType;
        navigator: Navigator;
        static?: boolean;
}
/**
    * Provides location context for the rest of the app.
    *
    * Note: You usually won't render a <Router> directly. Instead, you'll render a
    * router that is more specific to your environment such as a <BrowserRouter>
    * in web browsers or a <StaticRouter> for server rendering.
    *
    * @see https://reactrouter.com/docs/en/v6/api#router
    */
export function Router({ basename: basenameProp, children, location: locationProp, navigationType, navigator, static: staticProp, }: RouterProps): any | null;
export interface RoutesProps {
        children?: any;
        location?: Partial<Location> | string;
}
/**
    * A container for a nested tree of <Route> elements that renders the branch
    * that best matches the current location.
    *
    * @see https://reactrouter.com/docs/en/v6/api#routes
    */
export function Routes({ children, location, }: RoutesProps): any | null;
/**
    * Creates a route config from a React "children" object, which is usually
    * either a `<Route>` element or an array of them. Used internally by
    * `<Routes>` to create a route config from its children.
    *
    * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren
    */
export function createRoutesFromChildren(children: any): RouteObject[];
/**
    * Renders the result of `matchRoutes()` into a React element.
    */
export function renderMatches(matches: RouteMatch[] | null): null;

/**
  * A Navigator is a "location changer"; it's how you get to different locations.
  *
  * Every history instance conforms to the Navigator interface, but the
  * distinction is useful primarily when it comes to the low-level <Router> API
  * where both the location and a navigator must be provided separately in order
  * to avoid "tearing" that may occur in a suspense-enabled app if the action
  * and/or location were to be read directly from the history instance.
  */
export type Navigator = Pick<History, "go" | "push" | "replace" | "createHref">;
export const NavigationContext: {
    _id: any;
    _defaultValue: any;
    Consumer(props: any, contextValue: any): any;
    Provider(props: any): any;
};
export const LocationContext: {
    _id: any;
    _defaultValue: any;
    Consumer(props: any, contextValue: any): any;
    Provider(props: any): any;
};
export const RouteContext: {
    _id: any;
    _defaultValue: any;
    Consumer(props: any, contextValue: any): any;
    Provider(props: any): any;
};

/**
    * Returns the full href for the given "to" value. This is useful for building
    * custom links that are also accessible and preserve right-click behavior.
    *
    * @see https://reactrouter.com/docs/en/v6/api#usehref
    */
export function useHref(to: To): string;
/**
    * Returns true if this component is a descendant of a <Router>.
    *
    * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext
    */
export function useInRouterContext(): boolean;
/**
    * Returns the current location object, which represents the current URL in web
    * browsers.
    *
    * Note: If you're using this it may mean you're doing some of your own
    * "routing" in your app, and we'd like to know what your use case is. We may
    * be able to provide something higher-level to better suit your needs.
    *
    * @see https://reactrouter.com/docs/en/v6/api#uselocation
    */
export function useLocation(): Location;
/**
    * Returns the current navigation action which describes how the router came to
    * the current location, either by a pop, push, or replace on the history stack.
    *
    * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype
    */
export function useNavigationType(): NavigationType;
/**
    * Returns true if the URL for the given "to" value matches the current URL.
    * This is useful for components that need to know "active" state, e.g.
    * <NavLink>.
    *
    * @see https://reactrouter.com/docs/en/v6/api#usematch
    */
export function useMatch<ParamKey extends ParamParseKey<Path>, Path extends string>(pattern: PathPattern<Path> | Path): PathMatch<ParamKey> | null;
/**
    * The interface for the navigate() function returned from useNavigate().
    */
export interface NavigateFunction {
        (to: To, options?: NavigateOptions): void;
        (delta: number): void;
}
export interface NavigateOptions {
        replace?: boolean;
        state?: any;
}
/**
    * Returns an imperative method for changing the location. Used by <Link>s, but
    * may also be used by other elements to change the location.
    *
    * @see https://reactrouter.com/docs/en/v6/api#usenavigate
    */
export function useNavigate(): NavigateFunction;
/**
    * Returns the context (if provided) for the child route at this level of the route
    * hierarchy.
    * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext
    */
export function useOutletContext<Context = unknown>(): Context;
/**
    * Returns the element for the child route at this level of the route
    * hierarchy. Used internally by <Outlet> to render child routes.
    *
    * @see https://reactrouter.com/docs/en/v6/api#useoutlet
    */
export function useOutlet(context?: unknown): any;
/**
    * Returns an object of key/value pairs of the dynamic params from the current
    * URL that were matched by the route path.
    *
    * @see https://reactrouter.com/docs/en/v6/api#useparams
    */
export function useParams<ParamsOrKey extends string | Record<string, string | undefined> = string>(): Readonly<[
        ParamsOrKey
] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>>;
/**
    * Resolves the pathname of the given `to` value against the current location.
    *
    * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath
    */
export function useResolvedPath(to: To): Path;
/**
    * Returns the element of the route that matched the current location, prepared
    * with the correct context to render the remainder of the route tree. Route
    * elements in the tree must render an <Outlet> to render their child route's
    * element.
    *
    * @see https://reactrouter.com/docs/en/v6/api#useroutes
    */
export function useRoutes(routes: RouteObject[], locationArg?: Partial<Location> | string): any;
export function _renderMatches(matches: RouteMatch[] | null, parentMatches?: RouteMatch[]): any;

export function invariant(cond: any, message: string): asserts cond;
export function warning(cond: any, message: string): void;
export function warningOnce(key: string, cond: boolean, message: string): void;
type ParamParseFailed = {
        failed: true;
};
type ParamParseSegment<Segment extends string> = Segment extends `${infer LeftSegment}/${infer RightSegment}` ? ParamParseSegment<LeftSegment> extends infer LeftResult ? ParamParseSegment<RightSegment> extends infer RightResult ? LeftResult extends string ? RightResult extends string ? LeftResult | RightResult : LeftResult : RightResult extends string ? RightResult : ParamParseFailed : ParamParseFailed : ParamParseSegment<RightSegment> extends infer RightResult ? RightResult extends string ? RightResult : ParamParseFailed : ParamParseFailed : Segment extends `:${infer Remaining}` ? Remaining : ParamParseFailed;
export type ParamParseKey<Segment extends string> = ParamParseSegment<Segment> extends string ? ParamParseSegment<Segment> : string;
/**
    * The parameters that were parsed from the URL path.
    */
export type Params<Key extends string = string> = {
        readonly [key in Key]: string | undefined;
};
/**
    * A route object represents a logical route, with (optionally) its child
    * routes organized in a tree-like structure.
    */
export interface RouteObject {
        caseSensitive?: boolean;
        children?: RouteObject[];
        element?: any;
        index?: boolean;
        path?: string;
}
/**
    * Returns a path with params interpolated.
    *
    * @see https://reactrouter.com/docs/en/v6/api#generatepath
    */
export function generatePath(path: string, params?: Params): string;
/**
    * A RouteMatch contains info about how a route matched a URL.
    */
export interface RouteMatch<ParamKey extends string = string> {
        /**
            * The names and values of dynamic parameters in the URL.
            */
        params: Params<ParamKey>;
        /**
            * The portion of the URL pathname that was matched.
            */
        pathname: string;
        /**
            * The portion of the URL pathname that was matched before child routes.
            */
        pathnameBase: string;
        /**
            * The route object that was used to match.
            */
        route: RouteObject;
}
/**
    * Matches the given routes to a location and returns the match data.
    *
    * @see https://reactrouter.com/docs/en/v6/api#matchroutes
    */
export function matchRoutes(routes: RouteObject[], locationArg: Partial<Location> | string, basename?: string): RouteMatch[] | null;
/**
    * A PathPattern is used to match on some portion of a URL pathname.
    */
export interface PathPattern<Path extends string = string> {
        /**
            * A string to match against a URL pathname. May contain `:id`-style segments
            * to indicate placeholders for dynamic parameters. May also end with `/*` to
            * indicate matching the rest of the URL pathname.
            */
        path: Path;
        /**
            * Should be `true` if the static portions of the `path` should be matched in
            * the same case.
            */
        caseSensitive?: boolean;
        /**
            * Should be `true` if this pattern should match the entire URL pathname.
            */
        end?: boolean;
}
/**
    * A PathMatch contains info about how a PathPattern matched on a URL pathname.
    */
export interface PathMatch<ParamKey extends string = string> {
        /**
            * The names and values of dynamic parameters in the URL.
            */
        params: Params<ParamKey>;
        /**
            * The portion of the URL pathname that was matched.
            */
        pathname: string;
        /**
            * The portion of the URL pathname that was matched before child routes.
            */
        pathnameBase: string;
        /**
            * The pattern that was used to match.
            */
        pattern: PathPattern;
}
/**
    * Performs pattern matching on a URL pathname and returns information about
    * the match.
    *
    * @see https://reactrouter.com/docs/en/v6/api#matchpath
    */
export function matchPath<ParamKey extends ParamParseKey<Path>, Path extends string>(pattern: PathPattern<Path> | Path, pathname: string): PathMatch<ParamKey> | null;
/**
    * Returns a resolved path object relative to the given pathname.
    *
    * @see https://reactrouter.com/docs/en/v6/api#resolvepath
    */
export function resolvePath(to: To, fromPathname?: string): Path;
export function resolveTo(toArg: To, routePathnames: string[], locationPathname: string): Path;
export function getToPathname(to: To): string | undefined;
export function stripBasename(pathname: string, basename: string): string | null;
export const joinPaths: (paths: string[]) => string;
export const normalizePathname: (pathname: string) => string;
export {};

/**
    * Render a Preact virtual node into a DOM element
    * @param {import('./internal').ComponentChild} vnode The virtual node to render
    * @param {import('./internal').PreactElement} parentDom The DOM element to
    * render into
    * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an
    * existing DOM tree rooted at `replaceNode`
    */
export function render(vnode: any, parentDom: any, replaceNode?: any): void;
/**
    * Update an existing DOM element with data from a Preact virtual node
    * @param {import('./internal').ComponentChild} vnode The virtual node to render
    * @param {import('./internal').PreactElement} parentDom The DOM element to
    * update
    */
export function hydrate(vnode: any, parentDom: any): void;

/**
    * Create an virtual node (used for JSX)
    * @param {import('./internal').VNode["type"]} type The node name or Component
    * constructor for this virtual node
    * @param {object | null | undefined} [props] The properties of the virtual node
    * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node
    * @returns {import('./internal').VNode}
    */
export function createElement(type: any, props: any, children?: any): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
};
/**
    * Create a VNode (used internally by Preact)
    * @param {import('./internal').VNode["type"]} type The node name or Component
    * Constructor for this virtual node
    * @param {object | string | number | null} props The properties of this virtual node.
    * If this virtual node represents a text node, this is the text of the node (string or number).
    * @param {string | number | null} key The key for this virtual node, used when
    * diffing it against its children
    * @param {import('./internal').VNode["ref"]} ref The ref property that will
    * receive a reference to its created child
    * @returns {import('./internal').VNode}
    */
export function createVNode(type: any, props: any, key: any, ref: any, original: any): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
};
export function createRef(ref: any): any;
export function createRef(): any;
export function Fragment(props: any): any;
/**
    * Check if a the argument is a valid Preact VNode.
    * @param {*} vnode
    * @returns {vnode is import('./internal').VNode}
    */
export const isValidElement: (vnode: any) => boolean;

/**
    * Base Component class. Provides `setState()` and `forceUpdate()`, which
    * trigger rendering
    * @param {object} props The initial component props
    * @param {object} context The initial context from parent components'
    * getChildContext
    */
export class Component {
        props: any;
        context: any;
        state: any;
        _vnode: any;
        _force: boolean;
        _renderCallbacks: any[];
        isReactComponent: any;
        constructor(props?: any, context?: any);
        /**
    * Update component state and schedule a re-render.
    * @this {import('./internal').Component}
    * @param {object | ((s: object, p: object) => object)} update A hash of state
    * properties to update with new values or a function that given the current
    * state and props returns a new partial state
    * @param {() => void} [callback] A function to be called once component state is
    * updated
    */
        setState(update: any, callback?: any): void;
        /**
            * Immediately perform a synchronous re-render of the component
            * @this {import('./internal').Component}
            * @param {() => void} [callback] A function to be called after component is
            * re-rendered
            */
        forceUpdate(callback?: any): void;
        /**
            * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.
            * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).
            * @param {object} props Props (eg: JSX attributes) received from parent
            * element/component
            * @param {object} state The component's current state
            * @param {object} context Context object, as returned by the nearest
            * ancestor's `getChildContext()`
            * @returns {import('./index').ComponentChildren | void}
            */
        render(props: any): void;
}
/**
    * @param {import('./internal').VNode} vnode
    * @param {number | null} [childIndex]
    */
export function getDomSibling(vnode: any, childIndex?: any): any;
/**
    * Enqueue a rerender of a component
    * @param {import('./internal').Component} c The component to rerender
    */
export function enqueueRender(c: any): void;

/**
  * Clones the given VNode, optionally adding attributes/props and replacing its children.
  * @param {import('./internal').VNode} vnode The virtual DOM element to clone
  * @param {object} props Attributes/props to add when cloning
  * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used as replacement children.
  * @returns {import('./internal').VNode}
  */
export function cloneElement(vnode: any, props: any, children?: any): {
    type: any;
    props: any;
    key: any;
    ref: any;
    _children: any;
    _parent: any;
    _depth: number;
    _dom: any;
    _nextDom: any;
    _component: any;
    _hydrating: any;
    constructor: any;
    _original: any;
};

export let i: number;
export function createContext(defaultValue: any, contextId?: any): {
    _id: any;
    _defaultValue: any;
    /** @type {import('./internal').FunctionComponent} */
    Consumer(props: any, contextValue: any): any;
    /** @type {import('./internal').FunctionComponent} */
    Provider(props: any): any;
};

/**
    * Diff the children of a virtual node
    * @param {import('../internal').PreactElement} parentDom The DOM element whose
    * children are being diffed
    * @param {import('../internal').ComponentChildren[]} renderResult
    * @param {import('../internal').VNode} newParentVNode The new virtual
    * node whose children should be diff'ed against oldParentVNode
    * @param {import('../internal').VNode} oldParentVNode The old virtual
    * node whose children should be diff'ed against newParentVNode
    * @param {object} globalContext The current context object - modified by getChildContext
    * @param {boolean} isSvg Whether or not this DOM node is an SVG node
    * @param {Array<import('../internal').PreactElement>} excessDomChildren
    * @param {Array<import('../internal').Component>} commitQueue List of components
    * which have callbacks to invoke in commitRoot
    * @param {import('../internal').PreactElement} oldDom The current attached DOM
    * element any new dom elements should be placed around. Likely `null` on first
    * render (except when hydrating). Can be a sibling DOM element when diffing
    * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.
    * @param {boolean} isHydrating Whether or not we are in hydration
    */
export function diffChildren(parentDom: any, renderResult: any, newParentVNode: any, oldParentVNode: any, globalContext: any, isSvg: any, excessDomChildren: any, commitQueue: any, oldDom: any, isHydrating: any): void;
/**
    * Flatten and loop through the children of a virtual node
    * @param {import('../index').ComponentChildren} children The unflattened
    * children of a virtual node
    * @returns {import('../internal').VNode[]}
    */
export function toChildArray(children: any, out?: any): any;

/**
  * The `option` object can potentially contain callback functions
  * that are called during various stages of our renderer. This is the
  * foundation on which all our addons like `preact/debug`, `preact/compat`,
  * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`
  * for a full list of available option hooks (most editors/IDEs allow you to
  * ctrl+click or cmd+click on mac the type definition below).
  * @type {import('./internal').Options}
  */
const options: any;
export default options;

export enum MouseButtons {
    None = 0,
    Left = 1048576,
    Right = 2097152,
    Middle = 4194304,
    XButton1 = 8388608,
    XButton2 = 16777216
}

export class TextMultiComboBoxItem extends MultiComboBoxItem {
    constructor(text: string);
    constructor(key: string, text: string);
    GetItemTemplate(): any;
    ToObject(): any;
}

export class TreeNodeCollection extends List<TreeNode> {
    TreeView: TTreeView;
    constructor();
    Add(text: string): TreeNode;
    Add(key: int, text: string): TreeNode;
    Add(key: string, text: string): TreeNode;
    Add(treeNode: TreeNode): int;
    GetByKey(key: string): TreeNode;
    ToObject(): any[];
}

export class TreeViewCancelEventHandler extends Delegate<(sender: any, e: TreeViewCancelEventArgs) => void> {
}

export class TreeViewEventHandler extends Delegate<(sender: any, e: TreeViewEventArgs) => void> {
}

export enum TreeViewAction {
    Unknown = 0,
    ByKeyboard = 1,
    ByMouse = 2,
    Collapse = 3,
    Expand = 4
}

export class ColumnCollection extends List<GridColumn> {
    GridView: GridViewBase;
    constructor(gridview: GridViewBase);
    Add(header: string): GridColumn;
    Add(header: string, field: string): GridColumn;
    Add(treeNode: GridColumn): int;
    Clear(): int;
}

export class RibbonTabCollection extends List<RibbonTab> {
    RibbonMenu: RibbonMenu;
    constructor(ribbonMenu: RibbonMenu);
    Add(text: string): RibbonTab;
    Add(treeNode: RibbonTab): int;
    ToModel(): any[];
}

export class RibbonGroupCollection extends List<RibbonGroup> {
    constructor(ribbonMenu: RibbonMenu);
    Add(text: string): RibbonGroup;
    Add(treeNode: RibbonGroup): int;
}

export class ListViewItemCollection extends List<ListViewItem> {
    ListView: ListView;
    constructor(listView: ListView);
    Add(text: string, icon: string): ListViewItem;
    Add(treeNode: ListViewItem): int;
}

export class CardViewItemCollection extends List<CardViewItem> {
    ListView: CardView;
    constructor(listView: CardView);
    Add(text: string, icon: string): CardViewItem;
    Add(treeNode: CardViewItem): int;
    Clear(): int;
}

export class ListMenuItemCollection extends List<ListMenuItemBase> {
    ListView: ListMenu;
    constructor(listView: ListMenu);
    Add(text: string): ListMenuItem;
    Add(treeNode: ListMenuItemBase): int;
}

export class ListMenuRenderer extends ControlHtmlRenderer<ListMenu> {
    get UseShadowDom(): boolean;
    GenerateElement(obj: ListMenu): boolean;
    GenerateBody(obj: ListMenu): void;
    protected CreateItems(obj: ListMenu): any[];
    protected CreateControls(obj: ListMenu): any[];
}

export class RadioGroupItemCollection extends List<RadioButtonGroupItem> {
    RadioButtonGroup: RadioButtonGroup;
    constructor(comboBox: RadioButtonGroup);
    Add(text: string): RadioButtonGroupItem;
    Add(key: int, text: string): RadioButtonGroupItem;
    Add(key: string, text: string): RadioButtonGroupItem;
    Add(treeNode: RadioButtonGroupItem): int;
    Clear(): int;
    ToObject(): any[];
}

export interface IFontIcon extends IControl {
    FontFamily: string;
    Size: int;
    Color: CGColor;
}

export declare abstract class XmlTransformer<T extends any> extends React.Component {
    constructor(props: any);
    WriteStartElement(name: string): void;
    WriteStartFragment(): void;
    WriteEndElement(): void;
    WriteAttrVal(name: string, val: any): string;
    WriteStyleAttrVal(name: string, val: any): string;
    WriteTextBody(text: string): void;
    WriteControl(control: Control<any>): void;
    WriteComponent(text: any): void;
    InvalidateCache(): void;
    abstract DecideCache(obj: T): void;
    abstract GenerateElement(obj: T): boolean;
    abstract GenerateAttributes(obj: T): void;
    abstract GenerateBody(obj: T): void;
    abstract GenerateElementFinish(obj: T): void;
    Render(result: any[], obj: T): any;
}

export class DropdownComponent extends React.Component {
    static defaultProps: {
        id: any;
        inputRef: any;
        name: any;
        value: any;
        options: any;
        optionLabel: any;
        optionValue: any;
        optionDisabled: any;
        optionGroupLabel: any;
        optionGroupChildren: any;
        optionGroupTemplate: any;
        valueTemplate: any;
        itemTemplate: any;
        style: any;
        className: any;
        virtualScrollerOptions: any;
        scrollHeight: string;
        filter: boolean;
        filterBy: any;
        filterMatchMode: string;
        filterPlaceholder: any;
        filterLocale: any;
        emptyMessage: any;
        emptyFilterMessage: any;
        editable: boolean;
        placeholder: any;
        required: boolean;
        disabled: boolean;
        appendTo: any;
        tabIndex: any;
        autoFocus: boolean;
        filterInputAutoFocus: boolean;
        resetFilterOnHide: boolean;
        showFilterClear: boolean;
        panelClassName: any;
        panelStyle: any;
        dataKey: any;
        inputId: any;
        showClear: boolean;
        maxLength: any;
        tooltip: any;
        tooltipOptions: any;
        ariaLabel: any;
        ariaLabelledBy: any;
        transitionOptions: any;
        dropdownIcon: string;
        showOnFocus: boolean;
        onChange: any;
        onFocus: any;
        onBlur: any;
        onMouseDown: any;
        onContextMenu: any;
        onShow: any;
        onHide: any;
        onFilter: any;
    };
    overlayRef: any;
    inputRef: any;
    focusInput: any;
    container: any;
    searchTimeout: any;
    currentSearchChar: any;
    previousSearchChar: any;
    searchValue: any;
    selectedOptionUpdated: boolean;
    input: any;
    documentClickListener: any;
    scrollHandler: any;
    resizeListener: any;
    tooltip: any;
    hideTimeout: any;
    trigger: any;
    constructor(props: any);
    onClick(event: any): void;
    onInputFocus(event: any): void;
    onInputBlur(event: any): void;
    onPanelClick(event: any): void;
    onInputKeyDown(event: any): void;
    onFilterInputKeyDown(event: any): void;
    onUpKey(event: any): void;
    onDownKey(event: any): void;
    findNextOption(index: any): any;
    findNextOptionInList(list: any, index?: any): any;
    findPrevOption(index: any): any;
    findPrevOptionInList(list: any, index: any): any;
    search(event: any): void;
    searchOption(index: any): any;
    searchOptionInRange(start: any, end: any): any;
    searchOptionInGroup(index: any): any;
    matchesSearchValue(option: any): any;
    onEditableInputChange(event: any): void;
    onEditableInputFocus(event: any): void;
    onOptionClick(event: any): void;
    onFilterInputChange(event: any): void;
    onFilterClearIconClick(callback: any): void;
    resetFilter(callback?: any): void;
    clear(event: any): void;
    selectItem(event: any): void;
    getSelectedOption(): any;
    getSelectedOptionIndex(): number | {
        group: number;
        option: number;
    };
    findOptionIndexInList(value: any, list: any): number;
    isSelected(option: any): boolean;
    equalityKey(): any;
    showOverlay(): void;
    hideOverlay(): void;
    onOverlayEnter(callback: any): void;
    onOverlayEntered(callback: any): void;
    onOverlayExit(): void;
    onOverlayExited(): void;
    alignOverlay(): void;
    scrollInView(): void;
    bindDocumentClickListener(): void;
    unbindDocumentClickListener(): void;
    bindScrollListener(): void;
    unbindScrollListener(): void;
    bindResizeListener(): void;
    unbindResizeListener(): void;
    isOutsideClicked(event: any): boolean;
    isClearClicked(event: any): any;
    updateEditableLabel(option?: any): void;
    hasFilter(): boolean;
    getOptionLabel(option: any): any;
    getOptionValue(option: any): any;
    getOptionRenderKey(option: any): any;
    isOptionDisabled(option: any): any;
    getOptionGroupRenderKey(optionGroup: any): any;
    getOptionGroupLabel(optionGroup: any): any;
    getOptionGroupChildren(optionGroup: any): any;
    checkValidity(): any;
    isLazy(): any;
    getVisibleOptions(): any;
    updateInputField(): void;
    updateInputRef(): void;
    componentDidMount(): void;
    componentWillUnmount(): void;
    componentDidUpdate(prevProps: any): void;
    renderHiddenSelect(selectedOption: any): any;
    renderTooltip(): void;
    renderKeyboardHelper(): any;
    renderLabel(selectedOption: any): any;
    renderClearIcon(): any;
    renderDropdownIcon(): any;
    render(): any;
}

export const DropdownPanel: {
    (props: any, ref: any): any;
    $$typeof: number | symbol;
    render: any;
    _forwarded: boolean;
    displayName: string;
};

export class DropdownItem extends React.Component {
    static defaultProps: {
        option: any;
        label: any;
        template: any;
        selected: boolean;
        disabled: boolean;
        onClick: any;
    };
    constructor(props: any);
    onClick(event: any): void;
    render(): any;
}

export class InputText extends React.Component {
    static defaultProps: {
        keyfilter: any;
        validateOnly: boolean;
        tooltip: any;
        tooltipOptions: any;
        onInput: any;
        onKeyPress: any;
        forwardRef: any;
    };
    elementRef: any;
    tooltip: any;
    constructor(props: any);
    isFilled(): boolean;
    onKeyPress(event: any): void;
    onInput(event: any): void;
    updateForwardRef(): void;
    componentDidMount(): void;
    componentDidUpdate(prevProps: any): void;
    componentWillUnmount(): void;
    renderTooltip(): void;
    render(): any;
}
export const TuInputElement: any;

export class PanelComponent extends React.Component {
    static defaultProps: {
        id: any;
        header: any;
        headerTemplate: any;
        toggleable: any;
        style: any;
        contentStyle: any;
        className: any;
        collapsed: any;
        expandIcon: string;
        collapseIcon: string;
        icons: any;
        transitionOptions: any;
        onExpand: any;
        onCollapse: any;
        onToggle: any;
    };
    contentRef: any;
    constructor(props: any);
    toggle(event: any): void;
    expand(event: any): void;
    collapse(event: any): void;
    isCollapsed(): any;
    componentDidMount(): void;
    renderToggleIcon(collapsed: any): any;
    renderHeader(collapsed: any): any;
    renderContent(collapsed: any): any;
    render(): any;
}

export function hasClass(element: Element | SVGElement, className: string): boolean;
export function addOneClass(element: Element | SVGElement, className: string): void;
/**
  * Removes a CSS class from a given element.
  *
  * @param element the element
  * @param className the CSS class name
  */
export function removeOneClass(element: Element | SVGElement, className: string): void;
export const addClass: (node: any, classes: any) => any;
export const removeClass: (node: any, classes: any) => any;
export class CSSTransition extends React.Component {
    constructor(props: any);
    onEnter(node: any, isAppearing: any): void;
    onEntering(node: any, isAppearing: any): void;
    onEntered(node: any, isAppearing: any): void;
    onExit(node: any): void;
    onExiting(node: any): void;
    onExited(node: any): void;
    static getTeactInstance(props: any): CSSTransition;
    render(): any;
}

export class TabPanel extends React.Component {
    static defaultProps: {
        showHeader: boolean;
        header: any;
        headerTemplate: any;
        leftIcon: any;
        rightIcon: any;
        disabled: boolean;
        headerStyle: any;
        headerClassName: any;
        contentStyle: any;
        contentClassName: any;
    };
}
export class TabView extends React.Component {
    static defaultProps: {
        id: any;
        activeIndex: number;
        style: any;
        className: any;
        renderActiveOnly: boolean;
        closable: boolean;
        onTabChange: any;
    };
    inkbar: any;
    nav: any;
    constructor(props: any);
    getActiveIndex(): any;
    isSelected(index: any): boolean;
    onTabHeaderClick(event: any, tab: any, index: any): void;
    onCloseClick(event: any, index: any): void;
    updateInkBar(): void;
    componentDidMount(): void;
    componentDidUpdate(): void;
    renderTabHeader(tab: any, index: any): any;
    renderTabHeaders(): any;
    renderNavigator(): any;
    renderContent(): any;
    createContent(tab: any, index: any): any;
    render(): any;
}

export class BlockUI extends React.Component {
    static defaultProps: {
        id: any;
        blocked: boolean;
        fullScreen: boolean;
        baseZIndex: number;
        autoZIndex: boolean;
        style: any;
        className: any;
        template: any;
        onBlocked: any;
        onUnblocked: any;
    };
    mask: any;
    container: any;
    constructor(props: any);
    block(): void;
    unblock(): void;
    onPortalMounted(): void;
    renderMask(): any;
    componentDidMount(): void;
    componentDidUpdate(prevProps: any, prevState: any): void;
    componentWillUnmount(): void;
    render(): any;
}

export abstract class HtmlRenderer<T extends IControl> extends XmlTransformer<T> {
    protected Ref: any;
    protected contextMenu: any;
    constructor(props: any);
    protected InitializeRenderer(obj: T): void;
    TranslateAlpha(c: CGColor): float;
    TranslateColor(c: CGColor): string;
    TranslateGraphicsPath(path: GraphicsPath): string;
    WriteBrushAttributes(brush: Brush): void;
    WriteEllipse(p: Pen, b: Brush, r: CGRectangle): void;
    WriteLine(p: Pen, a: CGPoint, b: CGPoint): void;
    WriteLines(p: Pen, v: CGPoint[]): void;
    WritePath(p: Pen, b: Brush, pathdesc: string): void;
    WritePenAttributes(pen: Pen): void;
    WritePolygon(p: Pen, b: Brush, poly: CGPoint[]): void;
    WriteRectangle(p: Pen, b: Brush, r: CGRectangle, corner: CGSize): void;
    protected OnShadowDomWillMount(ref: any, obj: T): void;
    protected OnShadowDomDidMount(ref: any, obj: T): void;
    protected OnShadowDomWillUnmount(ref: any, obj: T): void;
    protected OnComponentWillMount(ref: any, obj: T): void;
    protected OnComponentDidMount(ref: any, obj: T): void;
    protected OnComponentWillReceiveProps(obj: T): void;
    protected OnShouldComponentUpdate(obj: T): boolean;
    protected OnComponentWillUpdate(obj: T): void;
    protected OnComponentDidUpdate(obj: T): void;
    protected OnComponentWillUnmount(obj: T): void;
    protected GetStyleObject(): any;
    get UseShadowDom(): boolean;
    get UseFrameStyles(): boolean;
    OnStyleCreating(obj: T, sb: StringBuilder): void;
    OnCustomAttributesCreating(obj: T, attributeObject: any): void;
    GetCustomJss(obj: T): Object;
    render(param?: any): any;
}

export class UIFileUploadClass extends UIView {
    FileReady: (value: IUploadFileReady) => void;
    vp_AllowedExtensions: string;
    setController(controller: UIController): this;
    constructor();
    onFileReady(value: (param: IUploadFileReady) => void): this;
    allowedExtensions(value: string): this;
}

export class DataTableClass extends UIView {
    _value: any[];
    _columns: ColumnClass[];
    setController(controller: UIController): this;
    constructor();
    value(value: any): this;
    columns(...value: ColumnClass[]): this;
}

export type ChartType = 'line' | 'area' | 'bar' | 'histogram' | 'pie' | 'donut' | 'radialBar' | 'scatter' | 'bubble' | 'heatmap' | 'candlestick' | 'boxPlot' | 'radar' | 'polarArea' | 'rangeBar' | 'treemap';
export class ChartClass extends UIView {
    vp_ChartHeight: int;
    chartHeight(value: int): this;
    vp_ChartType: ChartType;
    chartType(value: ChartType): this;
    vp_Series: TuvalAxisChartSeries | TuvalNonAxisChartSeries;
    series(value: TuvalAxisChartSeries | TuvalNonAxisChartSeries): this;
    vp_Options: UIChartOptions;
    options(value: UIChartOptions): this;
    setController(controller: UIController): this;
    constructor();
}

export class TypographyClass extends UIView implements ILabel {
    text(value: string): this;
    setController(controller: UIController): this;
    constructor();
}

export class UIProgressBarClass extends UIView implements ILabel {
    value(value: int): this;
    labelOffset(value: int): this;
    valueTemplate(value: (option: any) => UIView | Function): this;
    setController(controller: UIController): this;
    constructor();
}

export type VariantType = 'contained' | 'text' | 'outlined';
export type ColorType = 'primary' | 'secondary' | 'danger' | 'success';
export interface IButtonProps {
    variant?: VariantType;
    color?: ColorType;
}
export class ButtonView extends UIView implements ILabel {
    loading(value: boolean): this;
    variant(value: VariantType): this;
    color(value: ColorType): this;
    setController(controller: UIController): this;
    constructor();
}

export type Observer<T> = {
    next: (value: T) => void;
};
export type Subscription = {
    unsubscribe: Noop;
};
export type Subject<T> = {
    readonly observers: Observer<T>[];
    subscribe: (value: Observer<T>) => Subscription;
    unsubscribe: Noop;
} & Observer<T>;
export default function createSubject<T>(): Subject<T>;

/**
    * Type alias to `string` which describes a lodash-like path through an object.
    * E.g. `'foo.bar.0.baz'`
    */
export type PathString = string;
/**
    * Type which can be traversed through with a {@link PathString}.
    * I.e. objects, arrays, and tuples
    */
export type Traversable = object;
/**
    * Type to query whether an array type T is a tuple type.
    * @typeParam T - type which may be an array or tuple
    * @example
    * ```
    * IsTuple<[number]> = true
    * IsTuple<number[]> = false
    * ```
    */
export type IsTuple<T extends ReadonlyArray<any>> = number extends T['length'] ? false : true;
/**
    * Type which can be used to index an array or tuple type.
    */
export type ArrayKey = number;
/**
    * Type which can be used to index an object.
    */
export type Key = string;
/**
    * Type to assert that a type is a {@link Key}.
    * @typeParam T - type which may be a {@link Key}
    */
export type AsKey<T> = Extract<T, Key>;
/**
    * Type to convert a type to a {@link Key}.
    * @typeParam T - type which may be converted to a {@link Key}
    */
export type ToKey<T> = T extends ArrayKey ? `${T}` : AsKey<T>;
/**
    * Type which describes a path through an object
    * as a list of individual {@link Key}s.
    */
export type PathTuple = Key[];
/**
    * Type to assert that a type is a {@link PathTuple}.
    * @typeParam T - type which may be a {@link PathTuple}
    */
export type AsPathTuple<T> = Extract<T, PathTuple>;
/**
    * Type to intersect a union type.
    * See https://fettblog.eu/typescript-union-to-intersection/
    * @typeParam U - union
    * @example
    * ```
    * UnionToIntersection<{ foo: string } | { bar: number }>
    *   = { foo: string; bar: number }
    * ```
    */
export type UnionToIntersection<U> = (U extends any ? (_: U) => any : never) extends (_: infer I) => any ? I : never;
/**
    * Type which appends a {@link Key} to the {@link PathTuple} only if it is not
    * blank, i.e. not the empty string.
    * @typeParam PT - path
    * @typeParam K  - key
    * @example
    * ```
    * AppendNonBlankKey<['foo'], 'bar'> = ['foo', 'bar']
    * AppendNonBlankKey<['foo'], ''> = ['foo']
    * ```
    */
type AppendNonBlankKey<PT extends PathTuple, K extends Key> = K extends '' ? PT : [...PT, K];
/**
    * Type to implement {@link SplitPathString} tail recursively.
    * @typeParam PS - remaining {@link PathString} which should be split into its
    *                 individual {@link Key}s
    * @typeParam PT - accumulator of the {@link Key}s which have been split from
    *                 the original {@link PathString} already
    */
type SplitPathStringImpl<PS extends PathString, PT extends PathTuple> = PS extends `${infer K}.${infer R}` ? SplitPathStringImpl<R, AppendNonBlankKey<PT, K>> : AppendNonBlankKey<PT, PS>;
/**
    * Type to split a {@link PathString} into a {@link PathTuple}.
    * The individual {@link Key}s may be empty strings.
    * @typeParam PS  - {@link PathString} which should be split into its
    *                  individual {@link Key}s
    * @example
    * ```
    * SplitPathString<'foo'> = ['foo']
    * SplitPathString<'foo.bar.0.baz'> = ['foo', 'bar', '0', 'baz']
    * SplitPathString<'.'> = []
    * ```
    */
export type SplitPathString<PS extends PathString> = SplitPathStringImpl<PS, [
]>;
/**
    * Type to implement {@link JoinPathTuple} tail-recursively.
    * @typeParam PT - remaining {@link Key}s which needs to be joined
    * @typeParam PS - accumulator of the already joined {@link Key}s
    */
type JoinPathTupleImpl<PT extends PathTuple, PS extends PathString> = PT extends [infer K, ...infer R] ? JoinPathTupleImpl<AsPathTuple<R>, `${PS}.${AsKey<K>}`> : PS;
/**
    * Type to join a {@link PathTuple} to a {@link PathString}.
    * @typeParam PT - {@link PathTuple} which should be joined.
    * @example
    * ```
    * JoinPathTuple<['foo']> = 'foo'
    * JoinPathTuple<['foo', 'bar', '0', 'baz']> = 'foo.bar.0.baz'
    * JoinPathTuple<[]> = never
    * ```
    */
export type JoinPathTuple<PT extends PathTuple> = PT extends [
        infer K,
        ...infer R
] ? JoinPathTupleImpl<AsPathTuple<R>, AsKey<K>> : never;
/**
    * Type which converts all keys of an object to {@link Key}s.
    * @typeParam T - object type
    * @example
    * ```
    * MapKeys<{0: string}> = {'0': string}
    * ```
    */
type MapKeys<T> = {
        [K in keyof T as ToKey<K>]: T[K];
};
/**
    * Type to access a type by a key.
    *  - Returns undefined if it can't be indexed by that key.
    *  - Returns null if the type is null.
    *  - Returns undefined if the type is not traversable.
    * @typeParam T - type which is indexed by the key
    * @typeParam K - key into the type
    * ```
    * TryAccess<{foo: string}, 'foo'> = string
    * TryAccess<{foo: string}, 'bar'> = undefined
    * TryAccess<null, 'foo'> = null
    * TryAccess<string, 'foo'> = undefined
    * ```
    */
type TryAccess<T, K> = K extends keyof T ? T[K] : T extends null ? null : undefined;
/**
    * Type to access an array type by a key.
    * Returns undefined if the key is non-numeric.
    * @typeParam T - type which is indexed by the key
    * @typeParam K - key into the type
    * ```
    * TryAccessArray<string[], '0'> = string
    * TryAccessArray<string[], 'foo'> = undefined
    * ```
    */
type TryAccessArray<T extends ReadonlyArray<any>, K extends Key> = K extends `${ArrayKey}` ? T[number] : TryAccess<T, K>;
/**
    * Type to evaluate the type which the given key points to.
    * @typeParam T - type which is indexed by the key
    * @typeParam K - key into the type
    * @example
    * ```
    * EvaluateKey<{foo: string}, 'foo'> = string
    * EvaluateKey<[number, string], '1'> = string
    * EvaluateKey<string[], '1'> = string
    * ```
    */
export type EvaluateKey<T, K extends Key> = T extends ReadonlyArray<any> ? IsTuple<T> extends true ? TryAccess<T, K> : TryAccessArray<T, K> : TryAccess<MapKeys<T>, K>;
/**
    * Type to evaluate the type which the given path points to.
    * @typeParam T  - deeply nested type which is indexed by the path
    * @typeParam PT - path into the deeply nested type
    * @example
    * ```
    * EvaluatePath<{foo: {bar: string}}, ['foo', 'bar']> = string
    * EvaluatePath<[number, string], ['1']> = string
    * EvaluatePath<number, []> = number
    * EvaluatePath<number, ['foo']> = undefined
    * ```
    */
export type EvaluatePath<T, PT extends PathTuple> = PT extends [
        infer K,
        ...infer R
] ? EvaluatePath<EvaluateKey<T, AsKey<K>>, AsPathTuple<R>> : T;
/**
    * Type which given a tuple type returns its own keys, i.e. only its indices.
    * @typeParam T - tuple type
    * @example
    * ```
    * TupleKeys<[number, string]> = '0' | '1'
    * ```
    */
export type TupleKeys<T extends ReadonlyArray<any>> = Exclude<keyof T, keyof any[]>;
/**
    * Type which extracts all numeric keys from an object.
    * @typeParam T - type
    * @example
    * ```
    * NumericObjectKeys<{0: string, '1': string, foo: string}> = '0' | '1'
    * ```
    */
type NumericObjectKeys<T extends Traversable> = ToKey<Extract<keyof T, ArrayKey | `${ArrayKey}`>>;
/**
    * Type which extracts all numeric keys from an object, tuple, or array.
    * If a union is passed, it evaluates to the overlapping numeric keys.
    * @typeParam T - type
    * @example
    * ```
    * NumericKeys<{0: string, '1': string, foo: string}> = '0' | '1'
    * NumericKeys<number[]> = `${number}`
    * NumericKeys<[string, number]> = '0' | '1'
    * NumericKeys<{0: string, '1': string} | [number] | number[]> = '0'
    * ```
    */
export type NumericKeys<T extends Traversable> = UnionToIntersection<T extends ReadonlyArray<any> ? IsTuple<T> extends true ? [TupleKeys<T>] : [ToKey<ArrayKey>] : [NumericObjectKeys<T>]>[never];
/**
    * Type which extracts all keys from an object.
    * If a union is passed, it evaluates to the overlapping keys.
    * @typeParam T - object type
    * @example
    * ```
    * ObjectKeys<{foo: string, bar: string}, string> = 'foo' | 'bar'
    * ObjectKeys<{foo: string, bar: number}, string> = 'foo'
    * ```
    */
export type ObjectKeys<T extends Traversable> = Exclude<ToKey<keyof T>, `${string}.${string}` | ''>;
/**
    * Type to check whether a type's property matches the constraint type
    * and return its key. Converts the key to a {@link Key}.
    * @typeParam T - type whose property should be checked
    * @typeParam K - key of the property
    * @typeParam U - constraint type
    * @example
    * ```
    * CheckKeyConstraint<{foo: string}, 'foo', string> = 'foo'
    * CheckKeyConstraint<{foo: string}, 'foo', number> = never
    * CheckKeyConstraint<string[], number, string> = `${number}`
    * ```
    */
export type CheckKeyConstraint<T, K extends Key, U> = K extends any ? EvaluateKey<T, K> extends U ? K : never : never;
/**
    * Type which evaluates to true when the type is an array or tuple or is a union
    * which contains an array or tuple.
    * @typeParam T - type
    * @example
    * ```
    * ContainsIndexable<{foo: string}> = false
    * ContainsIndexable<{foo: string} | number[]> = true
    * ```
    */
export type ContainsIndexable<T> = IsNever<Extract<T, ReadonlyArray<any>>> extends true ? false : true;
/**
    * Type to implement {@link Keys} for non-nullable values.
    * @typeParam T - non-nullable type whose property should be checked
    */
type KeysImpl<T> = [T] extends [Traversable] ? ContainsIndexable<T> extends true ? NumericKeys<T> : ObjectKeys<T> : never;
/**
    * Type to find all properties of a type that match the constraint type
    * and return their keys.
    * If a union is passed, it evaluates to the overlapping keys.
    * @typeParam T - type whose property should be checked
    * @typeParam U - constraint type
    * @example
    * ```
    * Keys<{foo: string, bar: string}, string> = 'foo' | 'bar'
    * Keys<{foo?: string, bar?: string}> = 'foo' | 'bar'
    * Keys<{foo: string, bar: number}, string> = 'foo'
    * Keys<[string, number], string> = '0'
    * Keys<string[], string> = `${number}`
    * Keys<{0: string, '1': string} | [number] | number[]> = '0'
    * ```
    */
export type Keys<T, U = unknown> = IsAny<T> extends true ? Key : IsNever<T> extends true ? Key : IsNever<NonNullable<T>> extends true ? never : CheckKeyConstraint<T, KeysImpl<NonNullable<T>>, U>;
/**
    * Type to check whether a {@link Key} is present in a type.
    * If a union of {@link Key}s is passed, all {@link Key}s have to be present
    * in the type.
    * @typeParam T - type which is introspected
    * @typeParam K - key
    * @example
    * ```
    * HasKey<{foo: string}, 'foo'> = true
    * HasKey<{foo: string}, 'bar'> = false
    * HasKey<{foo: string}, 'foo' | 'bar'> = false
    * ```
    */
export type HasKey<T, K extends Key> = IsNever<Exclude<K, Keys<T>>>;
/**
    * Type to implement {@link ValidPathPrefix} tail recursively.
    * @typeParam T   - type which the path should be checked against
    * @typeParam PT  - path which should exist within the given type
    * @typeParam VPT - accumulates the prefix of {@link Key}s which have been
    *                  confirmed to exist already
    */
type ValidPathPrefixImpl<T, PT extends PathTuple, VPT extends PathTuple> = PT extends [infer K, ...infer R] ? HasKey<T, AsKey<K>> extends true ? ValidPathPrefixImpl<EvaluateKey<T, AsKey<K>>, AsPathTuple<R>, AsPathTuple<[...VPT, K]>> : VPT : VPT;
/**
    * Type to find the longest path prefix which is still valid,
    * i.e. exists within the given type.
    * @typeParam T  - type which the path should be checked against
    * @typeParam PT - path which should exist within the given type
    * @example
    * ```
    * ValidPathPrefix<{foo: {bar: string}}, ['foo', 'bar']> = ['foo', 'bar']
    * ValidPathPrefix<{foo: {bar: string}}, ['foo', 'ba']> = ['foo']
    * ```
    */
export type ValidPathPrefix<T, PT extends PathTuple> = ValidPathPrefixImpl<T, PT, [
]>;
/**
    * Type to check whether a path through a type exists.
    * @typeParam T  - type which the path should be checked against
    * @typeParam PT - path which should exist within the given type
    * @example
    * ```
    * HasPath<{foo: {bar: string}}, ['foo', 'bar']> = true
    * HasPath<{foo: {bar: string}}, ['foo', 'ba']> = false
    * ```
    */
export type HasPath<T, PT extends PathTuple> = ValidPathPrefix<T, PT> extends PT ? true : false;
export {};

/**
    * Helper type for recursively constructing paths through a type.
    * See {@link Path}
    */
type PathImpl<K extends string | number, V> = V extends Primitive | BrowserNativeObject ? `${K}` : `${K}` | `${K}.${Path<V>}`;
/**
    * Type which eagerly collects all paths through a type
    * @typeParam T - type which should be introspected
    * @example
    * ```
    * Path<{foo: {bar: string}}> = 'foo' | 'foo.bar'
    * ```
    */
export type Path<T> = T extends ReadonlyArray<infer V> ? IsTuple<T> extends true ? {
        [K in TupleKeys<T>]-?: PathImpl<K & string, T[K]>;
}[TupleKeys<T>] : PathImpl<ArrayKey, V> : {
        [K in keyof T]-?: PathImpl<K & string, T[K]>;
}[keyof T];
/**
    * See {@link Path}
    */
export type FieldPath<TFieldValues extends FieldValues> = Path<TFieldValues>;
/**
    * Helper type for recursively constructing paths through a type.
    * See {@link ArrayPath}
    */
type ArrayPathImpl<K extends string | number, V> = V extends Primitive | BrowserNativeObject ? never : V extends ReadonlyArray<infer U> ? U extends Primitive | BrowserNativeObject ? never : `${K}` | `${K}.${ArrayPath<V>}` : `${K}.${ArrayPath<V>}`;
/**
    * Type which eagerly collects all paths through a type which point to an array
    * type.
    * @typeParam T - type which should be introspected
    * @example
    * ```
    * Path<{foo: {bar: string[], baz: number[]}}> = 'foo.bar' | 'foo.baz'
    * ```
    */
export type ArrayPath<T> = T extends ReadonlyArray<infer V> ? IsTuple<T> extends true ? {
        [K in TupleKeys<T>]-?: ArrayPathImpl<K & string, T[K]>;
}[TupleKeys<T>] : ArrayPathImpl<ArrayKey, V> : {
        [K in keyof T]-?: ArrayPathImpl<K & string, T[K]>;
}[keyof T];
/**
    * See {@link ArrayPath}
    */
export type FieldArrayPath<TFieldValues extends FieldValues> = ArrayPath<TFieldValues>;
/**
    * Type to evaluate the type which the given path points to.
    * @typeParam T - deeply nested type which is indexed by the path
    * @typeParam P - path into the deeply nested type
    * @example
    * ```
    * PathValue<{foo: {bar: string}}, 'foo.bar'> = string
    * PathValue<[number, string], '1'> = string
    * ```
    */
export type PathValue<T, P extends Path<T> | ArrayPath<T>> = T extends any ? P extends `${infer K}.${infer R}` ? K extends keyof T ? R extends Path<T[K]> ? PathValue<T[K], R> : never : K extends `${ArrayKey}` ? T extends ReadonlyArray<infer V> ? PathValue<V, R & Path<V>> : never : never : P extends keyof T ? T[P] : P extends `${ArrayKey}` ? T extends ReadonlyArray<infer V> ? V : never : never : never;
/**
    * See {@link PathValue}
    */
export type FieldPathValue<TFieldValues extends FieldValues, TFieldPath extends FieldPath<TFieldValues>> = PathValue<TFieldValues, TFieldPath>;
/**
    * See {@link PathValue}
    */
export type FieldArrayPathValue<TFieldValues extends FieldValues, TFieldArrayPath extends FieldArrayPath<TFieldValues>> = PathValue<TFieldValues, TFieldArrayPath>;
/**
    * Type to evaluate the type which the given paths point to.
    * @typeParam TFieldValues - field values which are indexed by the paths
    * @typeParam TPath        - paths into the deeply nested field values
    * @example
    * ```
    * FieldPathValues<{foo: {bar: string}}, ['foo', 'foo.bar']>
    *   = [{bar: string}, string]
    * ```
    */
export type FieldPathValues<TFieldValues extends FieldValues, TPath extends FieldPath<TFieldValues>[] | readonly FieldPath<TFieldValues>[]> = {} & {
        [K in keyof TPath]: FieldPathValue<TFieldValues, TPath[K] & FieldPath<TFieldValues>>;
};
/**
    * Type which eagerly collects all paths through a fieldType that matches a give type
    * @typeParam TFieldValues - field values which are indexed by the paths
    * @typeParam TValue       - the value you want to match into each type
    * @example
    * ```typescript
    * FieldPathByValue<{foo: {bar: number}, baz: number, bar: string}, number>
    *   = 'foo.bar' | 'baz'
    * ```
    */
export type FieldPathByValue<TFieldValues extends FieldValues, TValue> = {
        [Key in FieldPath<TFieldValues>]: FieldPathValue<TFieldValues, Key> extends TValue ? Key : never;
}[FieldPath<TFieldValues>];
export {};

export type QueryKey = string | readonly unknown[];
export type EnsuredQueryKey<T extends QueryKey> = T extends string ? [T] : Exclude<T, string>;
export type QueryFunction<T = unknown, TQueryKey extends QueryKey = QueryKey> = (context: QueryFunctionContext<TQueryKey>) => T | Promise<T>;
export interface QueryFunctionContext<TQueryKey extends QueryKey = QueryKey, TPageParam = any> {
        queryKey: EnsuredQueryKey<TQueryKey>;
        signal?: AbortSignal;
        pageParam?: TPageParam;
        meta: QueryMeta | undefined;
}
export type InitialDataFunction<T> = () => T | undefined;
export type PlaceholderDataFunction<TResult> = () => TResult | undefined;
export type QueryKeyHashFunction<TQueryKey extends QueryKey> = (queryKey: TQueryKey) => string;
export type GetPreviousPageParamFunction<TQueryFnData = unknown> = (firstPage: TQueryFnData, allPages: TQueryFnData[]) => unknown;
export type GetNextPageParamFunction<TQueryFnData = unknown> = (lastPage: TQueryFnData, allPages: TQueryFnData[]) => unknown;
export interface InfiniteData<TData> {
        pages: TData[];
        pageParams: unknown[];
}
export type QueryMeta = Record<string, unknown>;
export interface QueryOptions<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> {
        /**
            * If `false`, failed queries will not retry by default.
            * If `true`, failed queries will retry infinitely., failureCount: num
            * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.
            * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.
            */
        retry?: RetryValue<TError>;
        retryDelay?: RetryDelayValue<TError>;
        cacheTime?: number;
        isDataEqual?: (oldData: TData | undefined, newData: TData) => boolean;
        queryFn?: QueryFunction<TQueryFnData, TQueryKey>;
        queryHash?: string;
        queryKey?: TQueryKey;
        queryKeyHashFn?: QueryKeyHashFunction<TQueryKey>;
        initialData?: TData | InitialDataFunction<TData>;
        initialDataUpdatedAt?: number | (() => number | undefined);
        behavior?: QueryBehavior<TQueryFnData, TError, TData>;
        /**
            * Set this to `false` to disable structural sharing between query results.
            * Defaults to `true`.
            */
        structuralSharing?: boolean;
        /**
            * This function can be set to automatically get the previous cursor for infinite queries.
            * The result will also be used to determine the value of `hasPreviousPage`.
            */
        getPreviousPageParam?: GetPreviousPageParamFunction<TQueryFnData>;
        /**
            * This function can be set to automatically get the next cursor for infinite queries.
            * The result will also be used to determine the value of `hasNextPage`.
            */
        getNextPageParam?: GetNextPageParamFunction<TQueryFnData>;
        _defaulted?: boolean;
        /**
            * Additional payload to be stored on each query.
            * Use this property to pass information that can be used in other places.
            */
        meta?: QueryMeta;
}
export interface QueryObserverOptions<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey> {
        /**
            * Set this to `false` to disable automatic refetching when the query mounts or changes query keys.
            * To refetch the query, use the `refetch` method returned from the `useQuery` instance.
            * Defaults to `true`.
            */
        enabled?: boolean;
        /**
            * The time in milliseconds after data is considered stale.
            * If set to `Infinity`, the data will never be considered stale.
            */
        staleTime?: number;
        /**
            * If set to a number, the query will continuously refetch at this frequency in milliseconds.
            * If set to a function, the function will be executed with the latest data and query to compute a frequency
            * Defaults to `false`.
            */
        refetchInterval?: number | false | ((data: TData | undefined, query: Query<TQueryFnData, TError, TQueryData, TQueryKey>) => number | false);
        /**
            * If set to `true`, the query will continue to refetch while their tab/window is in the background.
            * Defaults to `false`.
            */
        refetchIntervalInBackground?: boolean;
        /**
            * If set to `true`, the query will refetch on window focus if the data is stale.
            * If set to `false`, the query will not refetch on window focus.
            * If set to `'always'`, the query will always refetch on window focus.
            * Defaults to `true`.
            */
        refetchOnWindowFocus?: boolean | 'always';
        /**
            * If set to `true`, the query will refetch on reconnect if the data is stale.
            * If set to `false`, the query will not refetch on reconnect.
            * If set to `'always'`, the query will always refetch on reconnect.
            * Defaults to `true`.
            */
        refetchOnReconnect?: boolean | 'always';
        /**
            * If set to `true`, the query will refetch on mount if the data is stale.
            * If set to `false`, will disable additional instances of a query to trigger background refetches.
            * If set to `'always'`, the query will always refetch on mount.
            * Defaults to `true`.
            */
        refetchOnMount?: boolean | 'always';
        /**
            * If set to `false`, the query will not be retried on mount if it contains an error.
            * Defaults to `true`.
            */
        retryOnMount?: boolean;
        /**
            * If set, the component will only re-render if any of the listed properties change.
            * When set to `['data', 'error']`, the component will only re-render when the `data` or `error` properties change.
            * When set to `tracked`, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.
            */
        notifyOnChangeProps?: Array<keyof InfiniteQueryObserverResult> | 'tracked';
        /**
            * If set, the component will not re-render if any of the listed properties change.
            */
        notifyOnChangePropsExclusions?: Array<keyof InfiniteQueryObserverResult>;
        /**
            * This callback will fire any time the query successfully fetches new data or the cache is updated via `setQueryData`.
            */
        onSuccess?: (data: TData) => void;
        /**
            * This callback will fire if the query encounters an error and will be passed the error.
            */
        onError?: (err: TError) => void;
        /**
            * This callback will fire any time the query is either successfully fetched or errors and be passed either the data or error.
            */
        onSettled?: (data: TData | undefined, error: TError | null) => void;
        /**
            * Whether errors should be thrown instead of setting the `error` property.
            * If set to `true` or `suspense` is `true`, all errors will be thrown to the error boundary.
            * If set to `false` and `suspense` is `false`, errors are returned as state.
            * If set to a function, it will be passed the error and should return a boolean indicating whether to show the error in an error boundary (`true`) or return the error as state (`false`).
            * Defaults to `false`.
            */
        useErrorBoundary?: boolean | ((error: TError) => boolean);
        /**
            * This option can be used to transform or select a part of the data returned by the query function.
            */
        select?: (data: TQueryData) => TData;
        /**
            * If set to `true`, the query will suspend when `status === 'loading'`
            * and throw errors when `status === 'error'`.
            * Defaults to `false`.
            */
        suspense?: boolean;
        /**
            * Set this to `true` to keep the previous `data` when fetching based on a new query key.
            * Defaults to `false`.
            */
        keepPreviousData?: boolean;
        /**
            * If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `loading` data and no initialData has been provided.
            */
        placeholderData?: TQueryData | PlaceholderDataFunction<TQueryData>;
        /**
            * If set, the observer will optimistically set the result in fetching state before the query has actually started fetching.
            * This is to make sure the results are not lagging behind.
            * Defaults to `true`.
            */
        optimisticResults?: boolean;
}
export interface InfiniteQueryObserverOptions<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends QueryObserverOptions<TQueryFnData, TError, InfiniteData<TData>, InfiniteData<TQueryData>, TQueryKey> {
}
export interface FetchQueryOptions<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends QueryOptions<TQueryFnData, TError, TData, TQueryKey> {
        /**
            * The time in milliseconds after data is considered stale.
            * If the data is fresh it will be returned from the cache.
            */
        staleTime?: number;
}
export interface FetchInfiniteQueryOptions<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends FetchQueryOptions<TQueryFnData, TError, InfiniteData<TData>, TQueryKey> {
}
export interface ResultOptions {
        throwOnError?: boolean;
}
export interface RefetchPageFilters<TPageData = unknown> {
        refetchPage?: (lastPage: TPageData, index: number, allPages: TPageData[]) => boolean;
}
export interface RefetchOptions extends ResultOptions {
        cancelRefetch?: boolean;
}
export interface InvalidateQueryFilters<TPageData = unknown> extends QueryFilters, RefetchPageFilters<TPageData> {
        refetchActive?: boolean;
        refetchInactive?: boolean;
}
export interface RefetchQueryFilters<TPageData = unknown> extends QueryFilters, RefetchPageFilters<TPageData> {
}
export interface ResetQueryFilters<TPageData = unknown> extends QueryFilters, RefetchPageFilters<TPageData> {
}
export interface InvalidateOptions extends RefetchOptions {
}
export interface ResetOptions extends RefetchOptions {
}
export interface FetchNextPageOptions extends ResultOptions {
        cancelRefetch?: boolean;
        pageParam?: unknown;
}
export interface FetchPreviousPageOptions extends ResultOptions {
        cancelRefetch?: boolean;
        pageParam?: unknown;
}
export type QueryStatus = 'idle' | 'loading' | 'error' | 'success';
export interface QueryObserverBaseResult<TData = unknown, TError = unknown> {
        data: TData | undefined;
        dataUpdatedAt: number;
        error: TError | null;
        errorUpdatedAt: number;
        failureCount: number;
        isError: boolean;
        isFetched: boolean;
        isFetchedAfterMount: boolean;
        isFetching: boolean;
        isIdle: boolean;
        isLoading: boolean;
        isLoadingError: boolean;
        isPlaceholderData: boolean;
        isPreviousData: boolean;
        isRefetchError: boolean;
        isRefetching: boolean;
        isStale: boolean;
        isSuccess: boolean;
        refetch: <TPageData>(options?: RefetchOptions & RefetchQueryFilters<TPageData>) => Promise<QueryObserverResult<TData, TError>>;
        remove: () => void;
        status: QueryStatus;
}
export interface QueryObserverIdleResult<TData = unknown, TError = unknown> extends QueryObserverBaseResult<TData, TError> {
        data: undefined;
        error: null;
        isError: false;
        isIdle: true;
        isLoading: false;
        isLoadingError: false;
        isRefetchError: false;
        isSuccess: false;
        status: 'idle';
}
export interface QueryObserverLoadingResult<TData = unknown, TError = unknown> extends QueryObserverBaseResult<TData, TError> {
        data: undefined;
        error: null;
        isError: false;
        isIdle: false;
        isLoading: true;
        isLoadingError: false;
        isRefetchError: false;
        isSuccess: false;
        status: 'loading';
}
export interface QueryObserverLoadingErrorResult<TData = unknown, TError = unknown> extends QueryObserverBaseResult<TData, TError> {
        data: undefined;
        error: TError;
        isError: true;
        isIdle: false;
        isLoading: false;
        isLoadingError: true;
        isRefetchError: false;
        isSuccess: false;
        status: 'error';
}
export interface QueryObserverRefetchErrorResult<TData = unknown, TError = unknown> extends QueryObserverBaseResult<TData, TError> {
        data: TData;
        error: TError;
        isError: true;
        isIdle: false;
        isLoading: false;
        isLoadingError: false;
        isRefetchError: true;
        isSuccess: false;
        status: 'error';
}
export interface QueryObserverSuccessResult<TData = unknown, TError = unknown> extends QueryObserverBaseResult<TData, TError> {
        data: TData;
        error: null;
        isError: false;
        isIdle: false;
        isLoading: false;
        isLoadingError: false;
        isRefetchError: false;
        isSuccess: true;
        status: 'success';
}
export type QueryObserverResult<TData = unknown, TError = unknown> = QueryObserverIdleResult<TData, TError> | QueryObserverLoadingErrorResult<TData, TError> | QueryObserverLoadingResult<TData, TError> | QueryObserverRefetchErrorResult<TData, TError> | QueryObserverSuccessResult<TData, TError>;
export interface InfiniteQueryObserverBaseResult<TData = unknown, TError = unknown> extends QueryObserverBaseResult<InfiniteData<TData>, TError> {
        fetchNextPage: (options?: FetchNextPageOptions) => Promise<InfiniteQueryObserverResult<TData, TError>>;
        fetchPreviousPage: (options?: FetchPreviousPageOptions) => Promise<InfiniteQueryObserverResult<TData, TError>>;
        hasNextPage?: boolean;
        hasPreviousPage?: boolean;
        isFetchingNextPage: boolean;
        isFetchingPreviousPage: boolean;
}
export interface InfiniteQueryObserverIdleResult<TData = unknown, TError = unknown> extends InfiniteQueryObserverBaseResult<TData, TError> {
        data: undefined;
        error: null;
        isError: false;
        isIdle: true;
        isLoading: false;
        isLoadingError: false;
        isRefetchError: false;
        isSuccess: false;
        status: 'idle';
}
export interface InfiniteQueryObserverLoadingResult<TData = unknown, TError = unknown> extends InfiniteQueryObserverBaseResult<TData, TError> {
        data: undefined;
        error: null;
        isError: false;
        isIdle: false;
        isLoading: true;
        isLoadingError: false;
        isRefetchError: false;
        isSuccess: false;
        status: 'loading';
}
export interface InfiniteQueryObserverLoadingErrorResult<TData = unknown, TError = unknown> extends InfiniteQueryObserverBaseResult<TData, TError> {
        data: undefined;
        error: TError;
        isError: true;
        isIdle: false;
        isLoading: false;
        isLoadingError: true;
        isRefetchError: false;
        isSuccess: false;
        status: 'error';
}
export interface InfiniteQueryObserverRefetchErrorResult<TData = unknown, TError = unknown> extends InfiniteQueryObserverBaseResult<TData, TError> {
        data: InfiniteData<TData>;
        error: TError;
        isError: true;
        isIdle: false;
        isLoading: false;
        isLoadingError: false;
        isRefetchError: true;
        isSuccess: false;
        status: 'error';
}
export interface InfiniteQueryObserverSuccessResult<TData = unknown, TError = unknown> extends InfiniteQueryObserverBaseResult<TData, TError> {
        data: InfiniteData<TData>;
        error: null;
        isError: false;
        isIdle: false;
        isLoading: false;
        isLoadingError: false;
        isRefetchError: false;
        isSuccess: true;
        status: 'success';
}
export type InfiniteQueryObserverResult<TData = unknown, TError = unknown> = InfiniteQueryObserverIdleResult<TData, TError> | InfiniteQueryObserverLoadingErrorResult<TData, TError> | InfiniteQueryObserverLoadingResult<TData, TError> | InfiniteQueryObserverRefetchErrorResult<TData, TError> | InfiniteQueryObserverSuccessResult<TData, TError>;
export type MutationKey = string | readonly unknown[];
export type MutationStatus = 'idle' | 'loading' | 'success' | 'error';
export type MutationFunction<TData = unknown, TVariables = unknown> = (variables: TVariables) => Promise<TData>;
export interface MutationOptions<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> {
        mutationFn?: MutationFunction<TData, TVariables>;
        mutationKey?: MutationKey;
        variables?: TVariables;
        onMutate?: (variables: TVariables) => Promise<TContext | undefined> | TContext | undefined;
        onSuccess?: (data: TData, variables: TVariables, context: TContext) => Promise<unknown> | void;
        onError?: (error: TError, variables: TVariables, context: TContext | undefined) => Promise<unknown> | void;
        onSettled?: (data: TData | undefined, error: TError | null, variables: TVariables, context: TContext | undefined) => Promise<unknown> | void;
        retry?: RetryValue<TError>;
        retryDelay?: RetryDelayValue<TError>;
        _defaulted?: boolean;
}
export interface MutationObserverOptions<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> extends MutationOptions<TData, TError, TVariables, TContext> {
        useErrorBoundary?: boolean | ((error: TError) => boolean);
}
export interface MutateOptions<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> {
        onSuccess?: (data: TData, variables: TVariables, context: TContext) => Promise<unknown> | void;
        onError?: (error: TError, variables: TVariables, context: TContext | undefined) => Promise<unknown> | void;
        onSettled?: (data: TData | undefined, error: TError | null, variables: TVariables, context: TContext | undefined) => Promise<unknown> | void;
}
export type MutateFunction<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> = (variables: TVariables, options?: MutateOptions<TData, TError, TVariables, TContext>) => Promise<TData>;
export interface MutationObserverBaseResult<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> extends MutationState<TData, TError, TVariables, TContext> {
        isError: boolean;
        isIdle: boolean;
        isLoading: boolean;
        isSuccess: boolean;
        mutate: MutateFunction<TData, TError, TVariables, TContext>;
        reset: () => void;
}
export interface MutationObserverIdleResult<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {
        data: undefined;
        error: null;
        isError: false;
        isIdle: true;
        isLoading: false;
        isSuccess: false;
        status: 'idle';
}
export interface MutationObserverLoadingResult<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {
        data: undefined;
        error: null;
        isError: false;
        isIdle: false;
        isLoading: true;
        isSuccess: false;
        status: 'loading';
}
export interface MutationObserverErrorResult<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {
        data: undefined;
        error: TError;
        isError: true;
        isIdle: false;
        isLoading: false;
        isSuccess: false;
        status: 'error';
}
export interface MutationObserverSuccessResult<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {
        data: TData;
        error: null;
        isError: false;
        isIdle: false;
        isLoading: false;
        isSuccess: true;
        status: 'success';
}
export type MutationObserverResult<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> = MutationObserverIdleResult<TData, TError, TVariables, TContext> | MutationObserverLoadingResult<TData, TError, TVariables, TContext> | MutationObserverErrorResult<TData, TError, TVariables, TContext> | MutationObserverSuccessResult<TData, TError, TVariables, TContext>;
export interface DefaultOptions<TError = unknown> {
        queries?: QueryObserverOptions<unknown, TError>;
        mutations?: MutationObserverOptions<unknown, TError, unknown, unknown>;
}
export interface CancelOptions {
        revert?: boolean;
        silent?: boolean;
}
export interface SetDataOptions {
        updatedAt?: number;
}

export interface QueryFilters {
        /**
            * Include or exclude active queries
            */
        active?: boolean;
        /**
            * Match query key exactly
            */
        exact?: boolean;
        /**
            * Include or exclude inactive queries
            */
        inactive?: boolean;
        /**
            * Include queries matching this predicate function
            */
        predicate?: (query: Query) => boolean;
        /**
            * Include queries matching this query key
            */
        queryKey?: QueryKey;
        /**
            * Include or exclude stale queries
            */
        stale?: boolean;
        /**
            * Include or exclude fetching queries
            */
        fetching?: boolean;
}
export interface MutationFilters {
        /**
            * Match mutation key exactly
            */
        exact?: boolean;
        /**
            * Include mutations matching this predicate function
            */
        predicate?: (mutation: Mutation<any, any, any>) => boolean;
        /**
            * Include mutations matching this mutation key
            */
        mutationKey?: MutationKey;
        /**
            * Include or exclude fetching mutations
            */
        fetching?: boolean;
}
export type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput;
export type Updater<TInput, TOutput> = TOutput | DataUpdateFunction<TInput, TOutput>;
export type QueryStatusFilter = 'all' | 'active' | 'inactive' | 'none';
export const isServer: boolean;
export function noop(): undefined;
export function functionalUpdate<TInput, TOutput>(updater: Updater<TInput, TOutput>, input: TInput): TOutput;
export function isValidTimeout(value: unknown): value is number;
export function ensureQueryKeyArray<T extends QueryKey>(value: T): EnsuredQueryKey<T>;
export function difference<T>(array1: T[], array2: T[]): T[];
export function replaceAt<T>(array: T[], index: number, value: T): T[];
export function timeUntilStale(updatedAt: number, staleTime?: number): number;
export function parseQueryArgs<TOptions extends QueryOptions<any, any, any, TQueryKey>, TQueryKey extends QueryKey = QueryKey>(arg1: TQueryKey | TOptions, arg2?: QueryFunction<any, TQueryKey> | TOptions, arg3?: TOptions): TOptions;
export function parseMutationArgs<TOptions extends MutationOptions<any, any, any, any>>(arg1: MutationKey | MutationFunction<any, any> | TOptions, arg2?: MutationFunction<any, any> | TOptions, arg3?: TOptions): TOptions;
export function parseFilterArgs<TFilters extends QueryFilters, TOptions = unknown>(arg1?: QueryKey | TFilters, arg2?: TFilters | TOptions, arg3?: TOptions): [TFilters, TOptions | undefined];
export function parseMutationFilterArgs(arg1?: QueryKey | MutationFilters, arg2?: MutationFilters): MutationFilters | undefined;
export function mapQueryStatusFilter(active?: boolean, inactive?: boolean): QueryStatusFilter;
export function matchQuery(filters: QueryFilters, query: Query<any, any, any, any>): boolean;
export function matchMutation(filters: MutationFilters, mutation: Mutation<any, any>): boolean;
export function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(queryKey: TQueryKey, options?: QueryOptions<any, any, any, TQueryKey>): string;
/**
    * Default query keys hash function.
    */
export function hashQueryKey(queryKey: QueryKey): string;
/**
    * Hashes the value into a stable hash.
    */
export function stableValueHash(value: any): string;
/**
    * Checks if key `b` partially matches with key `a`.
    */
export function partialMatchKey(a: QueryKey, b: QueryKey): boolean;
/**
    * Checks if `b` partially matches with `a`.
    */
export function partialDeepEqual(a: any, b: any): boolean;
/**
    * This function returns `a` if `b` is deeply equal.
    * If not, it will replace any deeply equal children of `b` with those of `a`.
    * This can be used for structural sharing between JSON values for example.
    */
export function replaceEqualDeep<T>(a: unknown, b: T): T;
/**
    * Shallow compare objects. Only works with objects that always have the same properties.
    */
export function shallowEqualObjects<T>(a: T, b: T): boolean;
export function isPlainObject(o: any): o is Object;
export function isQueryKey(value: any): value is QueryKey;
export function isError(value: any): value is Error;
export function sleep(timeout: number): Promise<void>;
/**
    * Schedules a microtask.
    * This can be useful to schedule state updates after rendering.
    */
export function scheduleMicrotask(callback: () => void): void;
export function getAbortController(): AbortController | undefined;

interface RetryerConfig<TData = unknown, TError = unknown> {
    fn: () => TData | Promise<TData>;
    abort?: () => void;
    onError?: (error: TError) => void;
    onSuccess?: (data: TData) => void;
    onFail?: (failureCount: number, error: TError) => void;
    onPause?: () => void;
    onContinue?: () => void;
    retry?: RetryValue<TError>;
    retryDelay?: RetryDelayValue<TError>;
}
export type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>;
type ShouldRetryFunction<TError = unknown> = (failureCount: number, error: TError) => boolean;
export type RetryDelayValue<TError> = number | RetryDelayFunction<TError>;
type RetryDelayFunction<TError = unknown> = (failureCount: number, error: TError) => number;
interface Cancelable {
    cancel(): void;
}
export function isCancelable(value: any): value is Cancelable;
export class CancelledError {
    revert?: boolean;
    silent?: boolean;
    constructor(options?: CancelOptions);
}
export function isCancelledError(value: any): value is CancelledError;
export class Retryer<TData = unknown, TError = unknown> {
    cancel: (options?: CancelOptions) => void;
    cancelRetry: () => void;
    continue: () => void;
    failureCount: number;
    isPaused: boolean;
    isResolved: boolean;
    isTransportCancelable: boolean;
    promise: Promise<TData>;
    constructor(config: RetryerConfig<TData, TError>);
}
export {};

export interface Options extends RequestInit {
    user?: {
        authenticated?: boolean;
        token?: string;
    };
}
export const createHeadersFromOptions: (options: Options) => Headers;
export const fetchJson: (url: any, options?: Options) => Promise<{
    status: number;
    headers: Headers;
    body: string;
    json: any;
}>;
export const queryParameters: typeof stringify;
export const flattenObject: (value: any, path?: any[]) => any;

export class RibbonGroup {
    Text: string;
    Items: RibbonItemCollection;
    ToModel(): any;
}

export abstract class XmlTransformer<T extends any> extends React.Component {
    constructor(props: any);
    WriteStartElement(name: string): void;
    WriteStartFragment(): void;
    WriteEndElement(): void;
    WriteAttrVal(name: string, val: any): string;
    WriteStyleAttrVal(name: string, val: any): string;
    WriteTextBody(text: string): void;
    WriteControl(control: Control<any>): void;
    WriteComponent(text: any): void;
    InvalidateCache(): void;
    abstract DecideCache(obj: T): void;
    abstract GenerateElement(obj: T): boolean;
    abstract GenerateAttributes(obj: T): void;
    abstract GenerateBody(obj: T): void;
    abstract GenerateElementFinish(obj: T): void;
    Render(result: any[], obj: T): any;
}

export interface ILabel {
}

interface QueryCacheConfig {
    onError?: (error: unknown, query: Query<unknown, unknown, unknown>) => void;
    onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void;
}
interface NotifyEventQueryAdded {
    type: 'queryAdded';
    query: Query<any, any, any, any>;
}
interface NotifyEventQueryRemoved {
    type: 'queryRemoved';
    query: Query<any, any, any, any>;
}
interface NotifyEventQueryUpdated {
    type: 'queryUpdated';
    query: Query<any, any, any, any>;
    action: Action<any, any>;
}
interface NotifyEventObserverAdded {
    type: 'observerAdded';
    query: Query<any, any, any, any>;
    observer: QueryObserver<any, any, any, any, any>;
}
interface NotifyEventObserverRemoved {
    type: 'observerRemoved';
    query: Query<any, any, any, any>;
    observer: QueryObserver<any, any, any, any, any>;
}
interface NotifyEventObserverResultsUpdated {
    type: 'observerResultsUpdated';
    query: Query<any, any, any, any>;
}
type QueryCacheNotifyEvent = NotifyEventQueryAdded | NotifyEventQueryRemoved | NotifyEventQueryUpdated | NotifyEventObserverAdded | NotifyEventObserverRemoved | NotifyEventObserverResultsUpdated;
type QueryCacheListener = (event?: QueryCacheNotifyEvent) => void;
export class QueryCache extends Subscribable<QueryCacheListener> {
    config: QueryCacheConfig;
    constructor(config?: QueryCacheConfig);
    build<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(client: QueryClient, options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>, state?: QueryState<TData, TError>): Query<TQueryFnData, TError, TData, TQueryKey>;
    add(query: Query<any, any, any, any>): void;
    remove(query: Query<any, any, any, any>): void;
    clear(): void;
    get<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueyKey extends QueryKey = QueryKey>(queryHash: string): Query<TQueryFnData, TError, TData, TQueyKey> | undefined;
    getAll(): Query[];
    find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(arg1: QueryKey, arg2?: QueryFilters): Query<TQueryFnData, TError, TData> | undefined;
    findAll(queryKey?: QueryKey, filters?: QueryFilters): Query[];
    findAll(filters?: QueryFilters): Query[];
    findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[];
    notify(event: QueryCacheNotifyEvent): void;
    onFocus(): void;
    onOnline(): void;
}
export {};

interface QueryClientConfig {
    queryCache?: QueryCache;
    mutationCache?: MutationCache;
    defaultOptions?: DefaultOptions;
}
export class QueryClient {
    constructor(config?: QueryClientConfig);
    mount(): void;
    unmount(): void;
    isFetching(filters?: QueryFilters): number;
    isFetching(queryKey?: QueryKey, filters?: QueryFilters): number;
    isMutating(filters?: MutationFilters): number;
    getQueryData<TData = unknown>(queryKey: QueryKey, filters?: QueryFilters): TData | undefined;
    getQueriesData<TData = unknown>(queryKey: QueryKey): [QueryKey, TData][];
    getQueriesData<TData = unknown>(filters: QueryFilters): [QueryKey, TData][];
    setQueryData<TData>(queryKey: QueryKey, updater: Updater<TData | undefined, TData>, options?: SetDataOptions): TData;
    setQueriesData<TData>(queryKey: QueryKey, updater: Updater<TData | undefined, TData>, options?: SetDataOptions): [QueryKey, TData][];
    setQueriesData<TData>(filters: QueryFilters, updater: Updater<TData | undefined, TData>, options?: SetDataOptions): [QueryKey, TData][];
    getQueryState<TData = unknown, TError = undefined>(queryKey: QueryKey, filters?: QueryFilters): QueryState<TData, TError> | undefined;
    removeQueries(filters?: QueryFilters): void;
    removeQueries(queryKey?: QueryKey, filters?: QueryFilters): void;
    resetQueries<TPageData = unknown>(filters?: ResetQueryFilters<TPageData>, options?: ResetOptions): Promise<void>;
    resetQueries<TPageData = unknown>(queryKey?: QueryKey, filters?: ResetQueryFilters<TPageData>, options?: ResetOptions): Promise<void>;
    cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>;
    cancelQueries(queryKey?: QueryKey, filters?: QueryFilters, options?: CancelOptions): Promise<void>;
    invalidateQueries<TPageData = unknown>(filters?: InvalidateQueryFilters<TPageData>, options?: InvalidateOptions): Promise<void>;
    invalidateQueries<TPageData = unknown>(queryKey?: QueryKey, filters?: InvalidateQueryFilters<TPageData>, options?: InvalidateOptions): Promise<void>;
    refetchQueries<TPageData = unknown>(filters?: RefetchQueryFilters<TPageData>, options?: RefetchOptions): Promise<void>;
    refetchQueries<TPageData = unknown>(queryKey?: QueryKey, filters?: RefetchQueryFilters<TPageData>, options?: RefetchOptions): Promise<void>;
    fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>): Promise<TData>;
    fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(queryKey: TQueryKey, options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>): Promise<TData>;
    fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(queryKey: TQueryKey, queryFn: QueryFunction<TQueryFnData, TQueryKey>, options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>): Promise<TData>;
    prefetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>): Promise<void>;
    prefetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(queryKey: TQueryKey, options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>): Promise<void>;
    prefetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(queryKey: TQueryKey, queryFn: QueryFunction<TQueryFnData, TQueryKey>, options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>): Promise<void>;
    fetchInfiniteQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>): Promise<InfiniteData<TData>>;
    fetchInfiniteQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(queryKey: TQueryKey, options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>): Promise<InfiniteData<TData>>;
    fetchInfiniteQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(queryKey: TQueryKey, queryFn: QueryFunction<TQueryFnData, TQueryKey>, options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>): Promise<InfiniteData<TData>>;
    prefetchInfiniteQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>): Promise<void>;
    prefetchInfiniteQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(queryKey: TQueryKey, options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>): Promise<void>;
    prefetchInfiniteQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(queryKey: TQueryKey, queryFn: QueryFunction<TQueryFnData, TQueryKey>, options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>): Promise<void>;
    cancelMutations(): Promise<void>;
    resumePausedMutations(): Promise<void>;
    executeMutation<TData = unknown, TError = unknown, TVariables = void, TContext = unknown>(options: MutationOptions<TData, TError, TVariables, TContext>): Promise<TData>;
    getQueryCache(): QueryCache;
    getMutationCache(): MutationCache;
    getDefaultOptions(): DefaultOptions;
    setDefaultOptions(options: DefaultOptions): void;
    setQueryDefaults(queryKey: QueryKey, options: QueryObserverOptions<any, any, any, any>): void;
    getQueryDefaults(queryKey?: QueryKey): QueryObserverOptions<any, any, any, any, any> | undefined;
    setMutationDefaults(mutationKey: MutationKey, options: MutationObserverOptions<any, any, any, any>): void;
    getMutationDefaults(mutationKey?: MutationKey): MutationObserverOptions<any, any, any, any> | undefined;
    defaultQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey extends QueryKey>(options?: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>): QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>;
    defaultQueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey extends QueryKey>(options?: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>): QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>;
    defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(options?: T): T;
    clear(): void;
}
export {};

type QueryObserverListener<TData, TError> = (result: QueryObserverResult<TData, TError>) => void;
export interface NotifyOptions {
    cache?: boolean;
    listeners?: boolean;
    onError?: boolean;
    onSuccess?: boolean;
}
export interface ObserverFetchOptions extends FetchOptions {
    throwOnError?: boolean;
}
export class QueryObserver<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends Subscribable<QueryObserverListener<TData, TError>> {
    options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>;
    constructor(client: QueryClient, options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>);
    protected bindMethods(): void;
    protected onSubscribe(): void;
    protected onUnsubscribe(): void;
    shouldFetchOnReconnect(): boolean;
    shouldFetchOnWindowFocus(): boolean;
    destroy(): void;
    setOptions(options?: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>, notifyOptions?: NotifyOptions): void;
    getOptimisticResult(options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>): QueryObserverResult<TData, TError>;
    getCurrentResult(): QueryObserverResult<TData, TError>;
    trackResult(result: QueryObserverResult<TData, TError>): QueryObserverResult<TData, TError>;
    getNextResult(options?: ResultOptions): Promise<QueryObserverResult<TData, TError>>;
    getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey>;
    remove(): void;
    refetch<TPageData>(options?: RefetchOptions & RefetchQueryFilters<TPageData>): Promise<QueryObserverResult<TData, TError>>;
    fetchOptimistic(options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>): Promise<QueryObserverResult<TData, TError>>;
    protected fetch(fetchOptions?: ObserverFetchOptions): Promise<QueryObserverResult<TData, TError>>;
    protected createResult(query: Query<TQueryFnData, TError, TQueryData, TQueryKey>, options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>): QueryObserverResult<TData, TError>;
    updateResult(notifyOptions?: NotifyOptions): void;
    onQueryUpdate(action: Action<TData, TError>): void;
}
export {};

type QueriesObserverListener = (result: QueryObserverResult[]) => void;
export class QueriesObserver extends Subscribable<QueriesObserverListener> {
    constructor(client: QueryClient, queries?: QueryObserverOptions[]);
    protected onSubscribe(): void;
    protected onUnsubscribe(): void;
    destroy(): void;
    setQueries(queries: QueryObserverOptions[], notifyOptions?: NotifyOptions): void;
    getCurrentResult(): QueryObserverResult[];
    getOptimisticResult(queries: QueryObserverOptions[]): QueryObserverResult[];
}
export {};

type InfiniteQueryObserverListener<TData, TError> = (result: InfiniteQueryObserverResult<TData, TError>) => void;
export class InfiniteQueryObserver<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryData = TQueryFnData> extends QueryObserver<TQueryFnData, TError, InfiniteData<TData>, InfiniteData<TQueryData>> {
    subscribe: (listener?: InfiniteQueryObserverListener<TData, TError>) => () => void;
    getCurrentResult: () => InfiniteQueryObserverResult<TData, TError>;
    protected fetch: (fetchOptions?: ObserverFetchOptions) => Promise<InfiniteQueryObserverResult<TData, TError>>;
    constructor(client: QueryClient, options: InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryData>);
    protected bindMethods(): void;
    setOptions(options?: InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryData>): void;
    getOptimisticResult(options: InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryData>): InfiniteQueryObserverResult<TData, TError>;
    fetchNextPage(options?: FetchNextPageOptions): Promise<InfiniteQueryObserverResult<TData, TError>>;
    fetchPreviousPage(options?: FetchPreviousPageOptions): Promise<InfiniteQueryObserverResult<TData, TError>>;
    protected createResult(query: Query<TQueryFnData, TError, InfiniteData<TQueryData>>, options: InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryData>): InfiniteQueryObserverResult<TData, TError>;
}
export {};

interface MutationCacheConfig {
    onError?: (error: unknown, variables: unknown, context: unknown, mutation: Mutation<unknown, unknown, unknown, unknown>) => void;
    onSuccess?: (data: unknown, variables: unknown, context: unknown, mutation: Mutation<unknown, unknown, unknown, unknown>) => void;
}
type MutationCacheListener = (mutation?: Mutation) => void;
export class MutationCache extends Subscribable<MutationCacheListener> {
    config: MutationCacheConfig;
    constructor(config?: MutationCacheConfig);
    build<TData, TError, TVariables, TContext>(client: QueryClient, options: MutationOptions<TData, TError, TVariables, TContext>, state?: MutationState<TData, TError, TVariables, TContext>): Mutation<TData, TError, TVariables, TContext>;
    add(mutation: Mutation<any, any, any, any>): void;
    remove(mutation: Mutation<any, any, any, any>): void;
    clear(): void;
    getAll(): Mutation[];
    find<TData = unknown, TError = unknown, TVariables = any, TContext = unknown>(filters: MutationFilters): Mutation<TData, TError, TVariables, TContext> | undefined;
    findAll(filters: MutationFilters): Mutation[];
    notify(mutation?: Mutation<any, any, any, any>): void;
    onFocus(): void;
    onOnline(): void;
    resumePausedMutations(): Promise<void>;
}
export {};

type MutationObserverListener<TData, TError, TVariables, TContext> = (result: MutationObserverResult<TData, TError, TVariables, TContext>) => void;
export class MutationObserver<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> extends Subscribable<MutationObserverListener<TData, TError, TVariables, TContext>> {
    options: MutationObserverOptions<TData, TError, TVariables, TContext>;
    constructor(client: QueryClient, options: MutationObserverOptions<TData, TError, TVariables, TContext>);
    protected bindMethods(): void;
    setOptions(options?: MutationObserverOptions<TData, TError, TVariables, TContext>): void;
    protected onUnsubscribe(): void;
    onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void;
    getCurrentResult(): MutationObserverResult<TData, TError, TVariables, TContext>;
    reset(): void;
    mutate(variables?: TVariables, options?: MutateOptions<TData, TError, TVariables, TContext>): Promise<TData>;
}
export {};

export interface Logger {
    log: LogFunction;
    warn: LogFunction;
    error: LogFunction;
}
type LogFunction = (...args: any[]) => void;
export function getLogger(): Logger;
export function setLogger(newLogger: Logger): void;
export {};

type NotifyCallback = () => void;
type NotifyFunction = (callback: () => void) => void;
type BatchNotifyFunction = (callback: () => void) => void;
export class NotifyManager {
        constructor();
        batch<T>(callback: () => T): T;
        schedule(callback: NotifyCallback): void;
        /**
            * All calls to the wrapped function will be batched.
            */
        batchCalls<T extends Function>(callback: T): T;
        flush(): void;
        /**
            * Use this method to set a custom notify function.
            * This can be used to for example wrap notifications with `React.act` while running tests.
            */
        setNotifyFunction(fn: NotifyFunction): void;
        /**
            * Use this method to set a custom function to batch notifications together into a single tick.
            * By default React Query will use the batch function provided by ReactDOM or React Native.
            */
        setBatchNotifyFunction(fn: BatchNotifyFunction): void;
}
export const notifyManager: NotifyManager;
export {};

class FocusManager extends Subscribable {
    protected onSubscribe(): void;
    setEventListener(setup: (setFocused: (focused?: boolean) => void) => () => void): void;
    setFocused(focused?: boolean): void;
    onFocus(): void;
    isFocused(): boolean;
}
export const focusManager: FocusManager;
export {};

class OnlineManager extends Subscribable {
    protected onSubscribe(): void;
    setEventListener(setup: (setOnline: (online?: boolean) => void) => () => void): void;
    setOnline(online?: boolean): void;
    onOnline(): void;
    isOnline(): boolean;
}
export const onlineManager: OnlineManager;
export {};

export interface DehydrateOptions {
    dehydrateMutations?: boolean;
    dehydrateQueries?: boolean;
    shouldDehydrateMutation?: ShouldDehydrateMutationFunction;
    shouldDehydrateQuery?: ShouldDehydrateQueryFunction;
}
export interface HydrateOptions {
    defaultOptions?: {
        queries?: QueryOptions;
        mutations?: MutationOptions;
    };
}
interface DehydratedMutation {
    mutationKey?: MutationKey;
    state: MutationState;
}
interface DehydratedQuery {
    queryHash: string;
    queryKey: QueryKey;
    state: QueryState;
}
export interface DehydratedState {
    mutations: DehydratedMutation[];
    queries: DehydratedQuery[];
}
export type ShouldDehydrateQueryFunction = (query: Query) => boolean;
export type ShouldDehydrateMutationFunction = (mutation: Mutation) => boolean;
export function dehydrate(client: QueryClient, options?: DehydrateOptions): DehydratedState;
export function hydrate(client: QueryClient, dehydratedState: unknown, options?: HydrateOptions): void;
export {};

interface QueryConfig<TQueryFnData, TError, TData, TQueryKey extends QueryKey = QueryKey> {
    cache: QueryCache;
    queryKey: TQueryKey;
    queryHash: string;
    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>;
    defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>;
    state?: QueryState<TData, TError>;
    meta: QueryMeta | undefined;
}
export interface QueryState<TData = unknown, TError = unknown> {
    data: TData | undefined;
    dataUpdateCount: number;
    dataUpdatedAt: number;
    error: TError | null;
    errorUpdateCount: number;
    errorUpdatedAt: number;
    fetchFailureCount: number;
    fetchMeta: any;
    isFetching: boolean;
    isInvalidated: boolean;
    isPaused: boolean;
    status: QueryStatus;
}
export interface FetchContext<TQueryFnData, TError, TData, TQueryKey extends QueryKey = QueryKey> {
    fetchFn: () => unknown | Promise<unknown>;
    fetchOptions?: FetchOptions;
    options: QueryOptions<TQueryFnData, TError, TData, any>;
    queryKey: EnsuredQueryKey<TQueryKey>;
    state: QueryState<TData, TError>;
    meta: QueryMeta | undefined;
}
export interface QueryBehavior<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> {
    onFetch: (context: FetchContext<TQueryFnData, TError, TData, TQueryKey>) => void;
}
export interface FetchOptions {
    cancelRefetch?: boolean;
    meta?: any;
}
interface FailedAction {
    type: 'failed';
}
interface FetchAction {
    type: 'fetch';
    meta?: any;
}
interface SuccessAction<TData> {
    data: TData | undefined;
    type: 'success';
    dataUpdatedAt?: number;
}
interface ErrorAction<TError> {
    type: 'error';
    error: TError;
}
interface InvalidateAction {
    type: 'invalidate';
}
interface PauseAction {
    type: 'pause';
}
interface ContinueAction {
    type: 'continue';
}
interface SetStateAction<TData, TError> {
    type: 'setState';
    state: QueryState<TData, TError>;
    setStateOptions?: SetStateOptions;
}
export type Action<TData, TError> = ContinueAction | ErrorAction<TError> | FailedAction | FetchAction | InvalidateAction | PauseAction | SetStateAction<TData, TError> | SuccessAction<TData>;
export interface SetStateOptions {
    meta?: any;
}
export class Query<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> {
    queryKey: TQueryKey;
    queryHash: string;
    options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>;
    initialState: QueryState<TData, TError>;
    revertState?: QueryState<TData, TError>;
    state: QueryState<TData, TError>;
    cacheTime: number;
    meta: QueryMeta | undefined;
    constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>);
    setDefaultOptions(options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>): void;
    setData(updater: Updater<TData | undefined, TData>, options?: SetDataOptions): TData;
    setState(state: QueryState<TData, TError>, setStateOptions?: SetStateOptions): void;
    cancel(options?: CancelOptions): Promise<void>;
    destroy(): void;
    reset(): void;
    isActive(): boolean;
    isFetching(): boolean;
    isStale(): boolean;
    isStaleByTime(staleTime?: number): boolean;
    onFocus(): void;
    onOnline(): void;
    addObserver(observer: QueryObserver<any, any, any, any, any>): void;
    removeObserver(observer: QueryObserver<any, any, any, any, any>): void;
    getObserversCount(): number;
    invalidate(): void;
    fetch(options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>, fetchOptions?: FetchOptions): Promise<TData>;
    protected getDefaultState(options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>): QueryState<TData, TError>;
    protected reducer(state: QueryState<TData, TError>, action: Action<TData, TError>): QueryState<TData, TError>;
}
export {};

interface MutationConfig<TData, TError, TVariables, TContext> {
    mutationId: number;
    mutationCache: MutationCache;
    options: MutationOptions<TData, TError, TVariables, TContext>;
    defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>;
    state?: MutationState<TData, TError, TVariables, TContext>;
}
export interface MutationState<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> {
    context: TContext | undefined;
    data: TData | undefined;
    error: TError | null;
    failureCount: number;
    isPaused: boolean;
    status: MutationStatus;
    variables: TVariables | undefined;
}
interface FailedAction {
    type: 'failed';
}
interface LoadingAction<TVariables, TContext> {
    type: 'loading';
    variables?: TVariables;
    context?: TContext;
}
interface SuccessAction<TData> {
    type: 'success';
    data: TData;
}
interface ErrorAction<TError> {
    type: 'error';
    error: TError;
}
interface PauseAction {
    type: 'pause';
}
interface ContinueAction {
    type: 'continue';
}
interface SetStateAction<TData, TError, TVariables, TContext> {
    type: 'setState';
    state: MutationState<TData, TError, TVariables, TContext>;
}
export type Action<TData, TError, TVariables, TContext> = ContinueAction | ErrorAction<TError> | FailedAction | LoadingAction<TVariables, TContext> | PauseAction | SetStateAction<TData, TError, TVariables, TContext> | SuccessAction<TData>;
export class Mutation<TData = unknown, TError = unknown, TVariables = void, TContext = unknown> {
    state: MutationState<TData, TError, TVariables, TContext>;
    options: MutationOptions<TData, TError, TVariables, TContext>;
    mutationId: number;
    constructor(config: MutationConfig<TData, TError, TVariables, TContext>);
    setState(state: MutationState<TData, TError, TVariables, TContext>): void;
    addObserver(observer: MutationObserver<any, any, any, any>): void;
    removeObserver(observer: MutationObserver<any, any, any, any>): void;
    cancel(): Promise<void>;
    continue(): Promise<TData>;
    execute(): Promise<TData>;
}
export function getDefaultState<TData, TError, TVariables, TContext>(): MutationState<TData, TError, TVariables, TContext>;
export {};

export class RibbonItemCollection extends List<RibbonItem> {
    constructor(ribbonMenu: RibbonMenu);
    AddButton(text: string, icon: string): RibbonButton;
}

type Listener = () => void;
export class Subscribable<TListener extends Function = Listener> {
    protected listeners: TListener[];
    constructor();
    subscribe(listener?: TListener): () => void;
    hasListeners(): boolean;
    protected onSubscribe(): void;
    protected onUnsubscribe(): void;
}
export {};

export abstract class RibbonItem {
    protected abstract Get_RibbonItemType(): RibbonItemTypes;
    get Type(): RibbonItemTypes;
    Text: string;
    Icon: string;
    OnClick: Event<EventHandler>;
    abstract ToModel(): any;
}
export class RibbonButton extends RibbonItem {
    protected Get_RibbonItemType(): RibbonItemTypes;
    ToModel(): {
        type: string;
        text: string;
        icon: string;
        onClick: Event<EventHandler>;
    };
}

export enum RibbonItemTypes {
    RibbonButton = 0,
    RibbonGroupDivider = 1,
    RibbonFlexLayout = 2,
    RibbonIconButton = 3,
    RibbonToolButton = 4,
    RibbonSplitButton = 5
}

